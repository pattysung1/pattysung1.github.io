[{"categories":["Programming"],"contents":"\n\u0026lt;解題\u0026gt; Time: O() Space: O()\n","permalink":"https://pattysung1.github.io/works/leetcode-/","tags":["leetcode","graph"],"title":"Leetcode-"},{"categories":["Programming"],"contents":"Given a binary tree\nstruct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\nExample 1:\nInput: root = [1,2,3,4,5,null,7] Output: [1,#,2,3,#,4,5,7,#] Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with \u0026#39;#\u0026#39; signifying the end of each level. Example 2:\nInput: root = [] Output: [] \u0026lt;解題\u0026gt; /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { if(root==null) return null; Node head = null; Node prev = null; Node curr = root; while(curr!=null){ while(curr!=null){ if(curr.left!=null){ if(head==null){ head = curr.left; prev = curr.left; }else{ prev.next = curr.left; prev = prev.next; } } if(curr.right!=null){ if(head==null){ head = curr.right; prev = curr.right; }else{ prev.next = curr.right; prev = prev.next; } } curr = curr.next; } curr = head; prev = null; head = null; } return root; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-117/","tags":["leetcode","tree"],"title":"Leetcode-117. Populating Next Right Pointers in Each Node II"},{"categories":["Programming"],"contents":"Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0\u0026rsquo;s.\nYou must do it in place.\nExample 1:\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2:\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] \u0026lt;解題\u0026gt; 先建立一個mxn Array，跑迴圈，如果matrix[i][j]==0，則設置rowsArray[i]=0、colsArray[j]=0; 再跑一次迴圈，如果rowsArray[i]=0、colsArray[j]=0，則其matrix[i][j]==0 class Solution { public void setZeroes(int[][] matrix){ int m=matrix.length, n=matrix[0].length; int rowsArray[]= new int[m]; int colsArray[]= new int[n]; Arrays.fill(rowsArray,1); //rows填滿1 Arrays.fill(colsArray,1); //columns填滿1 for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;n;j++){ if(matrix[i][j]==0){ rowsArray[i]=0; colsArray[j]=0; } } } for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;n;j++){ if(rowsArray[i]==0 || colsArray[j]==0) matrix[i][j]=0; } } } } Time: O(mn) Space: O(m+n)\n\u0026lt;解題\u0026gt; class Solution { public void setZeroes(int[][] matrix){ int m=matrix.length, n=matrix[0].length; boolean isRow0=false, isCol0=false; for(int j=0;j\u0026lt;n;j++){ if(matrix[0][j]==0) isRow0=true; } for(int i=0;i\u0026lt;m;i++){ if(matrix[i][0]==0) isCol0=true; } for(int i=1;i\u0026lt;m;i++){ for(int j=1;j\u0026lt;n;j++){ if(matrix[i][j]==0){ matrix[i][0]=0; matrix[0][j]=0; } } } for(int i=1;i\u0026lt;m;i++){ for(int j=1;j\u0026lt;n;j++){ if(matrix[0][j]==0 || matrix[i][0]==0) matrix[i][j]=0; } } if(isRow0){ for(int j=0;j\u0026lt;n;j++) matrix[0][j]=0; } if(isCol0){ for(int i=0;i\u0026lt;m;i++) matrix[i][0]=0; } } } Time: O(m*n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-73/","tags":["leetcode","matrix"],"title":"Leetcode-73. Set Matrix Zeroes"},{"categories":["Programming"],"contents":"Given an integer numRows, return the first numRows of Pascal\u0026rsquo;s triangle.\nIn Pascal\u0026rsquo;s triangle, each number is the sum of the two numbers directly above it as shown:\nExample 1:\nInput: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] Example 2:\nInput: numRows = 1 Output: [[1]] \u0026lt;解題\u0026gt; class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; generate(int numRows) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; triangle = new ArrayList\u0026lt;\u0026gt;(); if(numRows==0) return triangle; List\u0026lt;Integer\u0026gt; first_row = new ArrayList\u0026lt;\u0026gt;(); first_row.add(1); //第一列的1 triangle.add(first_row); for ( int i =1 ; i \u0026lt; numRows ; i++){ List\u0026lt;Integer\u0026gt; pre_row = triangle.get(i-1); List\u0026lt;Integer\u0026gt; row = new ArrayList\u0026lt;\u0026gt;(); row.add(1); //每一列先加上最前面的1 for (int j = 1 ; j \u0026lt; i ; j++ ){ row.add(pre_row.get(j-1) + pre_row.get(j)); } row.add(1); triangle.add(row); } return triangle; } } Time: O(n2) Space: O(n2)\n","permalink":"https://pattysung1.github.io/works/leetcode-118/","tags":["leetcode","ArrayList"],"title":"Leetcode-118. Pascal's Triangle"},{"categories":["Programming"],"contents":"Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\nclass Node { public int val; public List neighbors; } Test case format:\nFor simplicity, each node’s value is the same as the node’s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\n-\u0026gt; 複製一個給定的 graph。可以分別用 BFS 跟 DFS 走訪每個 node 並複製，然後也將其連接的 nodes 複製並接上。 \u0026lt;解題\u0026gt; 深度優先搜索（DFS） class Solution { private Map\u0026lt;Node, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public Node cloneGraph(Node node) { if (node == null) return null; if (map.containsKey(node)) return map.get(node); Node clone = new Node(node.val); map.put(node, clone); for (Node neighbor : node.neighbors) { clone.neighbors.add(cloneGraph(neighbor)); } return clone; } } Time: O() Space: O()\n\u0026lt;解題\u0026gt; 廣度優先搜索（BFS） class Solution { public Node cloneGraph(Node node) { if (node == null) return null; Queue\u0026lt;Node\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); Map\u0026lt;Node, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Node clone = new Node(node.val); queue.offer(node); map.put(node, clone); while (!queue.isEmpty()) { Node curr = queue.poll(); Node currClone = map.get(curr); for (Node neighbor : curr.neighbors) { if (!map.containsKey(neighbor)) { Node neighborClone = new Node(neighbor.val); map.put(neighbor, neighborClone); queue.offer(neighbor); } currClone.neighbors.add(map.get(neighbor)); } } return clone; } } Time: O() Space: O()\n","permalink":"https://pattysung1.github.io/works/leetcode-133/","tags":["leetcode","graph"],"title":"Leetcode-133. Clone Graph"},{"categories":["Programming"],"contents":"Given an m x n 2D binary grid grid which represents a map of \u0026lsquo;1\u0026rsquo;s (land) and \u0026lsquo;0\u0026rsquo;s (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1:\nInput: grid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;] ] Output: 1 Example 2:\nInput: grid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] ] Output: 3 \u0026lt;解題\u0026gt; 用i,j表示行列，用迴圈去找如果[i][j]==1，就用conut+1，代表找到一個島，並callBFS看看是否周圍也有地(1)連接 callBFS中，把當前的1翻成0，並找他前後左右：if(i \u0026lt;0 || i\u0026gt;=grid.length || j\u0026lt;0 || j\u0026gt;=grid[i].length || grid[i][j] ==\u0026lsquo;0\u0026rsquo;) return，代表已經沒有連續的1了 class Solution { public int numIslands(char[][] grid) { int count = 0; for(int i =0 ; i\u0026lt;grid.length; i++){ for(int j = 0 ; j\u0026lt;grid[i].length ; j++){ if(grid[i][j]==\u0026#39;1\u0026#39;){ count +=1 ; callBFS(grid, i,j); } } } return count; } public void callBFS(char[][]grid, int i, int j){ if(i \u0026lt;0 || i\u0026gt;=grid.length || j\u0026lt;0 || j\u0026gt;=grid[i].length || grid[i][j] ==\u0026#39;0\u0026#39;) return; grid[i][j] = \u0026#39;0\u0026#39;; callBFS(grid, i+1 , j);//up callBFS(grid, i-1 , j);//down callBFS(grid, i , j+1);//right callBFS(grid, i , j-1);//left } } Time: O() Space: O()\n","permalink":"https://pattysung1.github.io/works/leetcode-200/","tags":["leetcode","graph"],"title":"Leetcode-200. Number of Islands"},{"categories":["Programming"],"contents":"Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample 1:\nInput: board = [[\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;E\u0026#34;],[\u0026#34;S\u0026#34;,\u0026#34;F\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;S\u0026#34;],[\u0026#34;A\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;E\u0026#34;]], word = \u0026#34;ABCCED\u0026#34; Output: true Example 2:\nInput: board = [[\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;E\u0026#34;],[\u0026#34;S\u0026#34;,\u0026#34;F\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;S\u0026#34;],[\u0026#34;A\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;E\u0026#34;]], word = \u0026#34;SEE\u0026#34; Output: true Example 3:\nInput: board = [[\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;E\u0026#34;],[\u0026#34;S\u0026#34;,\u0026#34;F\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;S\u0026#34;],[\u0026#34;A\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;E\u0026#34;]], word = \u0026#34;ABCB\u0026#34; Output: false -\u0026gt;題目會給一個word單字，我們要找在這個board中，是否可以找到這個字詞。有點類似Leetcode-200. Number of Islands的題目\n\u0026lt;解題\u0026gt; 可以先用迴圈來跑，看第一個char是否有在這個board當中，如果有的話，我們來搜尋這個char的前後左右有沒有符合接下來的字詞，所以我們建立一個search方法 由於被訪問過的字在同一次搜尋中，不能被再度訪問，所以我們在前面要設置一個boolean visited方法，如果被訪問到時，要設置為true。 搜尋其上下左右（index+1)，如果都符合接下來的字詞，return true，都沒有的話return false if(index == word.length())，代表已經成功找到完整的單詞匹配，所以return true public class Solution { static boolean[][] visited; public boolean exist(char[][] board, String word) { visited = new boolean[board.length][board[0].length]; for(int i = 0; i \u0026lt; board.length; i++){ for(int j = 0; j \u0026lt; board[i].length; j++){ if((word.charAt(0) == board[i][j]) \u0026amp;\u0026amp; search(board, word, i, j, 0)){ return true; } } } return false; } private boolean search(char[][]board, String word, int i, int j, int index){ if(index == word.length()){ return true; } if(i \u0026gt;= board.length || i \u0026lt; 0 || j \u0026gt;= board[i].length || j \u0026lt; 0 || board[i][j] != word.charAt(index) || visited[i][j]){ return false; } visited[i][j] = true; if(search(board, word, i-1, j, index+1) || search(board, word, i+1, j, index+1) || search(board, word, i, j-1, index+1) || search(board, word, i, j+1, index+1)){ return true; } visited[i][j] = false; return false; } } Time: O((rows * columns)^2) Space: O((rows * columns))\n","permalink":"https://pattysung1.github.io/works/leetcode-79/","tags":["leetcode","graph"],"title":"Leetcode-79. Word Search"},{"categories":["Programming"],"contents":"There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.\nYou are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.\nExample 1:\nInput: edges = [[1,2],[2,3],[4,2]] Output: 2 Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center. Example 2:\nInput: edges = [[1,2],[5,1],[1,3],[1,4]] Output: 1 \u0026lt;解題\u0026gt; 和997. Find the Town Judge這個想法有點像，如果是中間的節點，代表他重複的次數等於edges.length 一開始建立陣列大小為edges.length+2，因為從1開始算，且節點數為edges長度+1 計算到的次數+1，if(count[i] == edges.length ) return i class Solution { public int findCenter(int[][] edges) { int [] count = new int [edges.length+2]; for(int[] e : edges){ count[e[0]]++; count[e[1]]++; } for(int i =1 ; i\u0026lt;edges.length+2 ; i++){ if(count[i] == edges.length ) return i; } return -1; } } Time: O(N) Space: O(N)\n","permalink":"https://pattysung1.github.io/works/leetcode-1791/","tags":["leetcode","graph"],"title":"Leetcode-1791. Find Center of Star Graph"},{"categories":["Programming"],"contents":"There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.\nExample 1:\nInput: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2 Output: true Explanation: There are two paths from vertex 0 to vertex 2: - 0 → 1 → 2 - 0 → 2 Example 2:\nInput: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5 Output: false Explanation: There is no path from vertex 0 to vertex 5. \u0026lt;解題\u0026gt; 建立一個used的boolean陣列，來記錄哪些節點已被使用。 一開始，起點 start 被標記為已使用，並將 newUsedFound 設置為 true，並使用一個迴圈來尋找從起點到終點的路徑。 在每次迴圈中，程式遍歷 edges 數組中的每個邊，檢查邊的兩個節點是否有其中一個已被使用。 如果其中一個節點已被使用，則將另一個節點標記為已使用，並將 newUsedFound 設置為 true。 class Solution { public boolean validPath(int n, int[][] edges, int start, int end) { boolean[] used = new boolean[n]; used[start] = true; boolean newUsedFound = true; while (!used[end] \u0026amp;\u0026amp; newUsedFound) { newUsedFound = false; for (int i = edges.length - 1; i \u0026gt;= 0; i--) { if (used[edges[i][0]]) { if (!used[edges[i][1]]) newUsedFound = used[edges[i][1]] = true; } else if (used[edges[i][1]]) { newUsedFound = used[edges[i][0]] = true; } } } return used[end]; } } Time: O(E)-\u0026gt;邊的數量 Space: O(n)-\u0026gt;boolean[] used = new boolean[n];\n","permalink":"https://pattysung1.github.io/works/leetcode-1971/","tags":["leetcode","graph"],"title":"Leetcode-1971. Find if Path Exists in Graph"},{"categories":["Programming"],"contents":"In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.\nIf the town judge exists, then:\nThe town judge trusts nobody. Everybody (except for the town judge) trusts the town judge. There is exactly one person that satisfies properties 1 and 2. You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.\nReturn the label of the town judge if the town judge exists and can be identified, or return -1 otherwise. -\u0026gt;有n個人，可能有一個法官存在，所有的人都會信任他，但法官不會信任任何人；也可能沒有法官存在。\nExample 1:\nInput: n = 2, trust = [[1,2]] Output: 2 Example 2:\nInput: n = 3, trust = [[1,3],[2,3]] Output: 3 Example 3:\nInput: n = 3, trust = [[1,3],[2,3],[3,1]] Output: -1 \u0026lt;解題\u0026gt; 建立陣列，把1~n的index放進去，所以要建立new int [n+1] 由於[a,b]，前者信任後者，所以我們可以計算t[1]後者出現的次數，每計算到一次++；而再前者t[0]出現的話，就\u0026ndash; 迴圈：如果count[i]==n-1，代表每個人都信任他，所以他是法官 class Solution { public int findJudge(int n, int[][] trust) { int [] count = new int [n+1]; for(int[] t : trust){ count[t[0]]--; //trust別人的人-- count[t[1]]++; //被trust的人++ } for(int i=1 ; i\u0026lt;=n ; i++){ if(count[i]== n-1) return i; } return -1; } } Time: O(N) Space: O(N)\n","permalink":"https://pattysung1.github.io/works/leetcode-997/","tags":["leetcode","graph"],"title":"Leetcode-997. Find the Town Judge"},{"categories":["Programming"],"contents":"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\nExample 1: Input: root = [3,1,4,null,2], k = 1 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3 \u0026lt;解題\u0026gt; 用count 用於計數遍歷到的節點數量，變數 result 用於儲存第 k 小的節點的值 在每次遞迴中，先遞迴處理左子樹，然後對當前節點進行計數 count++。如果 count 等於 k，表示已經遍歷到第 k 個節點，將當前節點的值給 result。最後，遞迴處理右子樹。 當遍歷結束後，變數 result 將保存第 k 小的元素的值，並在 kthSmallest 方法中返回。 Recursive:\nint count = 0; int result = Integer.MIN_VALUE; public int kthSmallest(TreeNode root, int k) { traverse(root, k); return result; } public void traverse(TreeNode root, int k) { if(root == null) return; traverse(root.left, k); count ++; if(count == k) result = root.val; traverse(root.right, k); } Time: O(n) Space: O(n)\nIterative:\npublic int kthSmallest(TreeNode root, int k) { Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;TreeNode\u0026gt;(); TreeNode p = root; int count = 0; while(!stack.isEmpty() || p != null) { if(p != null) { stack.push(p); // Just like recursion p = p.left; } else { TreeNode node = stack.pop(); if(++count == k) return node.val; p = node.right; } } return Integer.MIN_VALUE; } ","permalink":"https://pattysung1.github.io/works/leetcode-230/","tags":["leetcode","tree"],"title":"Leetcode-230. Kth Smallest Element in a BST"},{"categories":["Programming"],"contents":"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\nExample 1:\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7] Example 2:\nInput: preorder = [-1], inorder = [-1] Output: [-1] \u0026lt;解題\u0026gt; class Solution { private int i = 0; private int p = 0; public TreeNode buildTree(int[] preorder, int[] inorder) { return build(preorder, inorder, Integer.MIN_VALUE); } private TreeNode build(int[] preorder, int[] inorder, int stop) { if (p \u0026gt;= preorder.length) { return null; } if (inorder[i] == stop) { ++i; return null; } TreeNode node = new TreeNode(preorder[p++]); node.left = build(preorder, inorder, node.val); node.right = build(preorder, inorder, stop); return node; } } Time: O() Space: O()\n","permalink":"https://pattysung1.github.io/works/leetcode-105/","tags":["leetcode","tree"],"title":"Leetcode-105. Construct Binary Tree from Preorder and Inorder Traversal"},{"categories":["Programming"],"contents":"Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\nExample 1:\nInput: root = [1,2,2,3,4,4,3] Output: true Example 2:\nInput: root = [1,2,2,null,3,null,3] Output: false \u0026lt;解題\u0026gt; 如果root==null，直接為ture，沒有的話用isSymmetricHelp一一檢查其左右子節點 isSymmetricHelp： a. 左子樹 left 和右子樹 right 都為空，表示當前的節點的左右子樹均為空，即對稱性保持，返回 true。 b. 如果左子樹 left 和右子樹 right 中只有其中一個為空，而另一個不為空，表示左右子樹的結構不對稱，返回 false。 c. return isSymmetricHelp(left.left, right.right) \u0026amp;\u0026amp; isSymmetricHelp(left.right, right.left); public boolean isSymmetric(TreeNode root) { return root==null || isSymmetricHelp(root.left, root.right); } private boolean isSymmetricHelp(TreeNode left, TreeNode right){ if(left==null || right==null) return left==right; if(left.val!=right.val) return false; return isSymmetricHelp(left.left, right.right) \u0026amp;\u0026amp; isSymmetricHelp(left.right, right.left); } Time: O(N) Space: O(H)\n","permalink":"https://pattysung1.github.io/works/leetcode-101/","tags":["leetcode","tree"],"title":"Leetcode-101. Symmetric Tree"},{"categories":["Programming"],"contents":"Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.\nExample 1:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Explanation: The root-to-leaf path with the target sum is shown. Example 2:\nInput: root = [1,2,3], targetSum = 5 Output: false Explanation: There two root-to-leaf paths in the tree: (1 --\u0026gt; 2): The sum is 3. (1 --\u0026gt; 3): The sum is 4. There is no root-to-leaf path with sum = 5. Example 3:\nInput: root = [], targetSum = 0 Output: false Explanation: Since the tree is empty, there are no root-to-leaf paths. \u0026lt;解題\u0026gt; 如果root==null，return false if(root.left == null \u0026amp;\u0026amp; root.right == null \u0026amp;\u0026amp; sum - root.val == 0) return true; 如果以上兩個條件都不滿足，則遞迴地檢查左子樹和右子樹。將目標和減去當前節點的值，並遞迴調用 hasPathSum 方法。如果左子樹或右子樹中存在滿足條件的路徑，即存在從根節點到葉子節點的路徑使得總和等於目標和，則返回 true。 public class Solution { public boolean hasPathSum(TreeNode root, int sum) { if(root == null) return false; if(root.left == null \u0026amp;\u0026amp; root.right == null \u0026amp;\u0026amp; sum - root.val == 0) return true; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); } } Time: O(n) Space: O(H)\npublic class Solution { public boolean hasPathSum(TreeNode root, int sum) { // iteration method if (root == null) {return false;} Stack\u0026lt;TreeNode\u0026gt; node_stack = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;Integer\u0026gt; sum_stack = new Stack\u0026lt;\u0026gt;(); node_stack.push(root); sum_stack.push(sum-root.val); while(!node_stack.isEmpty()){ TreeNode current_node = node_stack.pop(); int current_sum = sum_stack.pop(); if(current_node.left==null \u0026amp;\u0026amp; current_node.right==null \u0026amp;\u0026amp; current_sum ==0){ return true; } if(current_node.left!=null){ node_stack.push(current_node.left); sum_stack.push(current_sum-current_node.left.val); } if(current_node.right!=null){ node_stack.push(current_node.right); sum_stack.push(current_sum-current_node.right.val); } } return false; } } ","permalink":"https://pattysung1.github.io/works/leetcode-112/","tags":["leetcode","tree"],"title":"Leetcode-112. Path Sum"},{"categories":["Programming"],"contents":"Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nExample 1:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Example 3:\nInput: root = [2,1], p = 2, q = 1 Output: 2 \u0026lt;解題\u0026gt;方法一 因為是Binary Search Tree，所以可以用val的方式做思考（左小右大），如果： a. if(p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) ：從root.left找 b. if(p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) ：從root.right找 c. p,q分別在左、右，直接返回root public class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) { return lowestCommonAncestor(root.left , p ,q); } if(p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) { return lowestCommonAncestor(root.right , p ,q); } return root; } } Time: O(N) Space: O(H)\n\u0026lt;解題\u0026gt;方法二 和236二元樹一樣的思考方式： public class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left != null \u0026amp;\u0026amp; right != null) return root; return left != null ? left : right; } } Time: O(N) Space: O(H)\n此題可和Leetcode-236. Lowest Common Ancestor of a Binary Tree做比較\n","permalink":"https://pattysung1.github.io/works/leetcode-235/","tags":["leetcode","tree"],"title":"Leetcode-235. Lowest Common Ancestor of a Binary Search Tree"},{"categories":["Programming"],"contents":"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Example 3:\nInput: root = [1,2], p = 1, q = 2 Output: 1 \u0026lt;解題\u0026gt; 如果(root == null || root == p || root == q) return root，直接是他自己本身 建立左、右邊的尋找方式 public class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left != null \u0026amp;\u0026amp; right != null) return root; //表示 p 和 q 分別在左子樹和右子樹中 return left != null ? left : right; //表示 p 和 q 同時存在於左子樹或右子樹中，或者其中一個節點是另一個節點的祖先。 } } Time: O(N) Space: O(H)\n此題可和Leetcode-235. Lowest Common Ancestor of a Binary Search Tree做比較\n","permalink":"https://pattysung1.github.io/works/leetcode-236/","tags":["leetcode","tree"],"title":"Leetcode-236. Lowest Common Ancestor of a Binary Tree"},{"categories":["Programming"],"contents":"Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.\nExample 1:\nInput: root = [4,2,6,1,3] Output: 1 Example 2:\nInput: root = [1,0,48,null,null,12,49] Output: 1 \u0026lt;解題\u0026gt; 由於是InOrder，所以已經sorted了，故從左邊開始至右邊 去計算兩兩相減的值並更新至min，且更新prev的值 public class Solution { int min = Integer.MAX_VALUE; Integer prev = null; public int getMinimumDifference(TreeNode root) { if (root == null) return min; getMinimumDifference(root.left); if (prev != null) { min = Math.min(min, root.val - prev); } prev = root.val; getMinimumDifference(root.right); return min; } } In-Order traverse Time complexity: O(N) Space complexity: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-530/","tags":["leetcode","tree"],"title":"Leetcode-530. Minimum Absolute Difference in BST"},{"categories":["Programming"],"contents":"Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.\nExample 1:\nInput: root = [3,9,20,null,null,15,7] Output: [3.00000,14.50000,11.00000] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Example 2:\nInput: root = [3,9,20,15,7] Output: [3.00000,14.50000,11.00000] \u0026lt;解題\u0026gt; .offer(root) 是將元素添加到隊列的操作，用於初始化遍歷二叉樹的起始節點。 先用Queue把root加入，以及一個ArrayList存之後要回傳的陣列 當queue.size()\u0026gt;0，跑迴圈去計算每列的sum，若當前節點的左右節點非為空，則將它們加入queue中 計算每列平均 class Solution { public List\u0026lt;Double\u0026gt; averageOfLevels(TreeNode root) { List\u0026lt;Double\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(List.of(root)); //queue.offer(root); while(queue.size()\u0026gt;0){ double size = queue.size(),level_sum = 0; for(int i =0 ; i\u0026lt;size;i++){ TreeNode current = queue.poll(); level_sum += current.val; if(current.left != null) queue.offer(current.left); if(current.right != null) queue.offer(current.right); } double level_avg = level_sum/ size; result.add(level_avg); } return result; } } Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); 可以寫成： Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(List.of(root)); ","permalink":"https://pattysung1.github.io/works/leetcode-637/","tags":["leetcode","tree","queue"],"title":"Leetcode-637. Average of Levels in Binary Tree"},{"categories":["Programming"],"contents":"Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\nExample 1:\nInput: p = [1,2,3], q = [1,2,3] Output: true Example 2:\nInput: p = [1,2], q = [1,null,2] Output: false Example 3:\nInput: p = [1,2,1], q = [1,1,2] Output: false \u0026lt;解題\u0026gt; 如果兩者皆null，則相同true 只有任一null，則false p.val != q.val，則false return 判斷兩者左子樹與右子樹是否相同 class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { // If both p and q are null, then they are the same tree if (p == null \u0026amp;\u0026amp; q == null) return true; // If only one of p and q is null, then they are not the same tree if (p == null || q == null) return false; // If the values of p and q are different, then they are not the same tree if (p.val != q.val) return false; // Recursively check the left and right subtrees of p and q // If both the left and right subtrees are the same, then p and q are the same tree return isSameTree(p.left, q.left) \u0026amp;\u0026amp; isSameTree(p.right, q.right); } } ","permalink":"https://pattysung1.github.io/works/leetcode-100/","tags":["leetcode","tree"],"title":"Leetcode-100. Same Tree"},{"categories":["Programming"],"contents":"Given a binary tree, determine if it is height-balanced.\nExample 1:\nInput: root = [3,9,20,null,null,15,7] Output: true Example 2: Input: root = [1,2,2,3,3,null,null,4,4] Output: false Example 3:\nInput: root = [] Output: true \u0026lt;解題\u0026gt; Height Function如果return -1，代表是不平衡樹 用遞迴方式，去計算左子樹和右子數的分別高度 class Solution { public boolean isBalanced(TreeNode root) { if (root == null) return true; // Height Function will return -1, when it’s an unbalanced tree... if (Height(root) == -1) return false; return true; } public int Height(TreeNode root) { if (root == null) return 0; int leftHeight = Height(root.left); int rightHight = Height(root.right); // In case of left subtree or right subtree unbalanced, return -1... if (leftHeight == -1 || rightHight == -1) return -1; // If their heights differ by more than ‘1’, return -1... if (Math.abs(leftHeight - rightHight) \u0026gt; 1) return -1; // Otherwise, return the height of this subtree as max(leftHeight, rightHight) + 1... return Math.max(leftHeight, rightHight) + 1; } } Time：O(N) Space：O(H)\n單純計算節點的高度 public int height(TreeNode node) { // 如果節點為空，返回高度 0 if (node == null) { return 0; } // 遞歸計算左子樹的高度 int leftHeight = height(node.left); // 遞歸計算右子樹的高度 int rightHeight = height(node.right); // 返回左子樹和右子樹中較大的高度加 1 return Math.max(leftHeight, rightHeight) + 1; } ","permalink":"https://pattysung1.github.io/works/leetcode-110/","tags":["leetcode","tree"],"title":"Leetcode-110. Balanced Binary Tree"},{"categories":["Programming"],"contents":"Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node\u0026rsquo;s descendants. The tree tree could also be considered as a subtree of itself.\nExample 1:\nInput: root = [3,4,5,1,2], subRoot = [4,1,2] Output: true Example 2:\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] Output: false \u0026lt;解題\u0026gt; 首先檢查 s 是否為空，如果是，則檢查 t 是否也為空，如果是，則返回 true，表示 t 是空樹也是 s 的子樹。 用isSame(s, t)，判斷兩者是否相同，相同的話t就是s的子樹；若不相同，再來用遞迴方式看左子樹或右子樹是否有包含t class Solution { public boolean isSubtree(TreeNode s, TreeNode t) { if (s == null) { return t == null; } return isSame(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t); } private boolean isSame(TreeNode t1, TreeNode t2) { if (t1 == null \u0026amp;\u0026amp; t2 == null) return true; if (t1 == null || t2 == null) return false; if (t1.val != t2.val) return false; return isSame(t1.left, t2.left) \u0026amp;\u0026amp; isSame(t1.right, t2.right); } } Time: O(mxn) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-572/","tags":["leetcode","tree"],"title":"Leetcode-572. Subtree of Another Tree"},{"categories":["Programming"],"contents":"在使用 Java 的 Queue 接口時，可以使用以下方法進行操作： offer(element): 將元素插入到佇列的尾部，如果成功插入，返回 true；如果無法插入（例如因為佇列已滿），返回 false。\nadd(element): 將元素插入到佇列的尾部，如果成功插入，返回 true；如果無法插入（例如因為佇列已滿），則拋出一個 unchecked 異常（IllegalStateException）。\npoll(): 移除並返回佇列的頭部元素，如果佇列為空，則返回 null。\nremove(): 移除並返回佇列的頭部元素，如果佇列為空，則拋出一個異常（NoSuchElementException）。\npeek(): 返回佇列的頭部元素，但不移除該元素，如果佇列為空，則返回 null。\nelement(): 返回佇列的頭部元素，但不移除該元素，如果佇列為空，則拋出一個異常（NoSuchElementException）。\npublic class Main { public static void main(String[] args) { //add()和remove()方法在失败的时候会抛出异常(不推荐) Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;String\u0026gt;(); //添加元素 queue.offer(\u0026#34;a\u0026#34;); queue.offer(\u0026#34;b\u0026#34;); queue.offer(\u0026#34;c\u0026#34;); queue.offer(\u0026#34;d\u0026#34;); queue.offer(\u0026#34;e\u0026#34;); for(String q : queue){ System.out.println(q); } System.out.println(\u0026#34;===\u0026#34;); System.out.println(\u0026#34;poll=\u0026#34;+queue.poll()); //返回第一个元素，并在队列中删除 for(String q : queue){ System.out.println(q); } System.out.println(\u0026#34;===\u0026#34;); System.out.println(\u0026#34;element=\u0026#34;+queue.element()); //返回第一个元素 for(String q : queue){ System.out.println(q); } System.out.println(\u0026#34;===\u0026#34;); System.out.println(\u0026#34;peek=\u0026#34;+queue.peek()); //返回第一个元素 for(String q : queue){ System.out.println(q); } } } 輸出結果： a b c d e === poll=a b c d e === element=b b c d e === peek=b b c d e 資料來源：https://www.runoob.com/java/data-queue.html\n","permalink":"https://pattysung1.github.io/works/queue/","tags":["leetcode","tree"],"title":"Queue"},{"categories":["Programming"],"contents":"Given the root of a binary tree, return its maximum depth.\nA binary tree\u0026rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. -\u0026gt;給定一個二元樹並找到它的最大深度，最大深度是指從最上層節點至最下層節點之間所經過的節點數。\nExample 1:\nInput: root = [3,9,20,null,null,15,7] Output: 3 Example 2:\nInput: root = [1,null,2] Output: 2 \u0026lt;解題\u0026gt; 找左子樹的深度和右子樹的深度較大的 class Solution { public int maxDepth(TreeNode root) { if(root==null){ return 0; } return 1+Math.max(maxDepth(root.left),maxDepth(root.right)); } } Time complexity: O(n) Space complexity: O(n)\nclass Solution { public int maxDepth(TreeNode root) { if(root == null) { return 0; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); int count = 0; while(!queue.isEmpty()) { int size = queue.size(); while(size-- \u0026gt; 0) { TreeNode node = queue.poll(); if(node.left != null) { queue.offer(node.left); } if(node.right != null) { queue.offer(node.right); } } count++; } return count; } } ","permalink":"https://pattysung1.github.io/works/leetcode-104/","tags":["leetcode","tree"],"title":"Leetcode-104. Maximum Depth of Binary Tree"},{"categories":["Programming"],"contents":"Given the root of a binary tree, invert the tree, and return its root.\nExample 1: Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] Example 2: Input: root = [2,1,3] Output: [2,3,1] Example 3:\nInput: root = [] Output: [] \u0026lt;解題\u0026gt; 把root都存在LinkedList裏，用poll方法去從root開始去取出 *poll方法，用於從列表的頭部（也就是第一個元素）移除並返回該元素 如果該節點的左子樹不為空，將左子樹加入隊列中。 如果該節點的右子樹不為空，將右子樹加入隊列中。 交換該節點的左右子樹。 class Solution { public TreeNode invertTree(TreeNode root) { LinkedList\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;TreeNode\u0026gt;(); if(root != null){ q.add(root); } while(!q.isEmpty()){ // Dequeue front node TreeNode temp = q.poll(); // Enqueue left child of the popped node if(temp.left != null) q.add(temp.left); // Enqueue right child of the popped node if(temp.right != null) q.add(temp.right); // 左右互換 TreeNode curr = temp.left; temp.left = temp.right; temp.right = curr; } return root; } } Time Complexity : O(n) Space Complexity : O(n)\n補充 ","permalink":"https://pattysung1.github.io/works/leetcode-226/","tags":["leetcode","tree"],"title":"Leetcode-226. Invert Binary Tree"},{"categories":["Programming"],"contents":"Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\nExample 1:\nInput: s = \u0026#34;leetcode\u0026#34; Output: 0 Example 2:\nInput: s = \u0026#34;loveleetcode\u0026#34; Output: 2 Example 3:\nInput: s = \u0026#34;aabb\u0026#34; Output: -1 \u0026lt;解題\u0026gt; 像是之前做過和String算頻率的題目類似，所以可以先計算各個字母出現的頻率 在一個迴圈從頭開始算頻率為1的字母 public class Solution { public int firstUniqChar(String s) { int freq [] = new int[26]; for(int i = 0; i \u0026lt; s.length(); i ++) freq [s.charAt(i) - \u0026#39;a\u0026#39;] ++; for(int i = 0; i \u0026lt; s.length(); i ++) if(freq [s.charAt(i) - \u0026#39;a\u0026#39;] == 1) return i; return -1; } } ","permalink":"https://pattysung1.github.io/works/leetcode-387/","tags":["leetcode"],"title":"Leetcode-387. First Unique Character in a String"},{"categories":["Programming"],"contents":"Given the root of a binary tree, return the length of the diameter of the tree.\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nThe length of a path between two nodes is represented by the number of edges between them. -\u0026gt;找diameter：為兩個節點中的最長路徑\nExample 1:\nInput: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3]. Example 2:\nInput: root = [1,2] Output: 1 \u0026lt;解題\u0026gt; 用calculateHeight來計算root的高度及最大直徑值。 在calculateHeight中，先分別用遞迴計算左節點高度、右節點高度 接著，更新最大直徑：Math.max(目前最大直徑,左右高度相加) 接著，返回節點的高度 最後，將答案最大直徑maxDiameter返回 class Solution { private int maxDiameter = 0; public int diameterOfBinaryTree(TreeNode root) { calculateHeight(root); return maxDiameter; } private int calculateHeight(TreeNode node) { if (node == null) { return 0; } int leftHeight = calculateHeight(node.left); int rightHeight = calculateHeight(node.right); // 更新最大直徑 maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight); // 返回節點的高度 return Math.max(leftHeight, rightHeight) + 1; } } Time：O(N) Space：O(H)(樹的高度)\n","permalink":"https://pattysung1.github.io/works/leetcode-543/","tags":["leetcode","tree"],"title":"Leetcode-543. Diameter of Binary Tree"},{"categories":["Programming"],"contents":"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2:\nInput: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 \u0026lt;解題\u0026gt;用二元搜尋法找到目標值 1.先比較數列中間值與目標值，若相等則回傳中間值的索引。 2.若中間值大於目標值，搜尋從左半部分(前半)。 3.若中間值小於目標值，搜尋從右半部分(後半)。\nclass Solution { public int search(int[] nums, int target) { int index = -1; int begin = 0, end = nums.length - 1, middle = (end + begin) / 2; while (begin \u0026lt;= end) { if (nums[middle] == target) { return middle; } else if (nums[middle] \u0026gt; target) { end = middle - 1; } else if (nums[middle] \u0026lt; target) { begin = middle + 1; } middle = (end + begin) / 2; } return index; } } ","permalink":"https://pattysung1.github.io/works/leetcode-704/","tags":["leetcode","tree"],"title":"Leetcode-704. Binary Search"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; ","permalink":"https://pattysung1.github.io/works/leetcode-739/","tags":["leetcode"],"title":"Leetcode-739. Daily Temperatures"},{"categories":["Programming"],"contents":"Given the head of a singly linked list, return true if it is a palindrome or false otherwise.\nExample 1: Input: head = [1,2,2,1] Output: true\nExample 2:\nInput: head = [1,2] Output: false \u0026lt;解題\u0026gt; 1.把LinkedList分成一半來判斷 \u0026lt;說明\u0026gt;\n把LinkedList分成一半 反轉其中一半 從頭開始比較每個節點的值，如果不同就return false；如果全部都相同就return true class Solution { public boolean isPalindrome(ListNode head) { if (head == null || head.next == null) { return true; } ListNode fast = head; ListNode slow = head; while (fast.next != null \u0026amp;\u0026amp; fast.next.next != null) { fast = fast.next.next; slow = slow.next; } ListNode secondHalf = reverse(slow.next); while (secondHalf != null) { if (head.val != secondHalf.val) { return false; } head = head.next; secondHalf = secondHalf.next; } return true; } public ListNode reverse(ListNode head) { ListNode prev = null; while (head != null) { ListNode next = head.next; head.next = prev; prev = head; head = next; } return prev; } } Time: O(n) Space: O(1)\n2. 用兩指標分別從頭尾往內跑，檢驗是否相等 class Solution { public boolean isPalindrome(ListNode head) { if(head == null | head.next ==null) return true; List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;\u0026gt;(); while(head!=null){ l.add(head.val); head = head.next; } int start =0 , end = l.size()-1; while(start\u0026lt;end){ if(l.get(start)!= l.get(end)) return false; start++; end--; } return true; } } Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-234/","tags":["leetcode"],"title":"Leetcode-234. Palindrome Linked List"},{"categories":["Programming"],"contents":"Given a string path, which is an absolute path (starting with a slash \u0026lsquo;/\u0026rsquo;) to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\nIn a Unix-style file system, a period \u0026lsquo;.\u0026rsquo; refers to the current directory, a double period \u0026lsquo;..\u0026rsquo; refers to the directory up a level, and any multiple consecutive slashes (i.e. \u0026lsquo;//\u0026rsquo;) are treated as a single slash \u0026lsquo;/\u0026rsquo;. For this problem, any other format of periods such as \u0026lsquo;\u0026hellip;\u0026rsquo; are treated as file/directory names.\nThe canonical path should have the following format:\nThe path starts with a single slash \u0026lsquo;/\u0026rsquo;. Any two directories are separated by a single slash \u0026lsquo;/\u0026rsquo;. The path does not end with a trailing \u0026lsquo;/\u0026rsquo;. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period \u0026lsquo;.\u0026rsquo; or double period \u0026lsquo;..\u0026rsquo;) Return the simplified canonical path.\nExample 1:\nInput: path = \u0026#34;/home/\u0026#34; Output: \u0026#34;/home\u0026#34; Explanation: Note that there is no trailing slash after the last directory name. Example 2:\nInput: path = \u0026#34;/../\u0026#34; Output: \u0026#34;/\u0026#34; Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3:\nInput: path = \u0026#34;/home//foo/\u0026#34; Output: \u0026#34;/home/foo\u0026#34; Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. \u0026lt;解題\u0026gt; 1. 用Stack class Solution { public String simplifyPath(String path) { Deque\u0026lt;String\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; skip = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;..\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;\u0026#34;)); StringBuilder sb = new StringBuilder(); String[] dirs = path.split(\u0026#34;/\u0026#34;); for (String dir : dirs) { if (dir.equals(\u0026#34;..\u0026#34;) \u0026amp;\u0026amp; !stack.isEmpty()) { stack.pop(); } else if (!skip.contains(dir)) { stack.push(dir); } } while (!stack.isEmpty()) { sb.insert(0, \u0026#34;/\u0026#34; + stack.pop()); } return sb.length() == 0 ? \u0026#34;/\u0026#34; : sb.toString(); } } 2. 用使用兩個指針i和prevSlash來遍歷路徑的每個字符 class Solution { public String simplifyPath(String path) { StringBuilder sb = new StringBuilder(); int n = path.length(); int i = 0; while (i \u0026lt; n) { // 跳過多餘的斜線 while (i \u0026lt; n \u0026amp;\u0026amp; path.charAt(i) == \u0026#39;/\u0026#39;) { i++; } // 構建當前目錄名稱 StringBuilder curr = new StringBuilder(); while (i \u0026lt; n \u0026amp;\u0026amp; path.charAt(i) != \u0026#39;/\u0026#39;) { curr.append(path.charAt(i)); i++; } String dir = curr.toString(); // 處理目錄名稱 if (dir.equals(\u0026#34;..\u0026#34;)) { if (sb.length() \u0026gt; 0) { int prevSlash = sb.lastIndexOf(\u0026#34;/\u0026#34;); sb.delete(prevSlash, sb.length()); } } else if (!dir.equals(\u0026#34;.\u0026#34;) \u0026amp;\u0026amp; !dir.isEmpty()) { sb.append(\u0026#34;/\u0026#34;).append(dir); } } return sb.length() == 0 ? \u0026#34;/\u0026#34; : sb.toString(); } } Time: O(n) Space: O(m)\n","permalink":"https://pattysung1.github.io/works/leetcode-71/","tags":["leetcode","Stack"],"title":"Leetcode-71. Simplify Path"},{"categories":["Programming"],"contents":"Given a string s containing just the characters \u0026lsquo;(\u0026rsquo;, \u0026lsquo;)\u0026rsquo;, \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo;, determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.\nExample 1:\nInput: s = \u0026#34;()\u0026#34; Output: true Example 2:\nInput: s = \u0026#34;()[]{}\u0026#34; Output: true Example 3:\nInput: s = \u0026#34;(]\u0026#34; Output: false Example 4: 自己做的測試\nInput: s =\u0026#34;([{])}\u0026#34; Output: false -\u0026gt;所以一定要剛好一個相同的符號正反一對，不然會return false\n\u0026lt;解題\u0026gt; 一定要剛好一個相同的符號正反一對，不然會return false 先把正的符號先push進去stack 如果有一樣的反符號配對，且剛好在最上面的話，就pop出來；不然就false 最後如果都有成對，stack就是空的，所以stack.isEmpty()=true返回 class Solution { public boolean isValid(String s) { if(s.length()%2!=0) return false; Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); //Deque\u0026lt;String\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { if (c == \u0026#39;(\u0026#39;|| c ==\u0026#39;{\u0026#39; || c==\u0026#39;[\u0026#39;){ stack.push(c); } else if (c ==\u0026#39;}\u0026#39; \u0026amp;\u0026amp; !stack.isEmpty() \u0026amp;\u0026amp; stack.peek()==\u0026#39;{\u0026#39;){ stack.pop(); } else if (c ==\u0026#39;]\u0026#39; \u0026amp;\u0026amp; !stack.isEmpty() \u0026amp;\u0026amp; stack.peek()==\u0026#39;[\u0026#39;){ stack.pop(); } else if (c ==\u0026#39;)\u0026#39; \u0026amp;\u0026amp; !stack.isEmpty() \u0026amp;\u0026amp; stack.peek()==\u0026#39;(\u0026#39;){ stack.pop(); } else{ return false; } } return stack.isEmpty(); } } class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;Character\u0026gt;(); for (char c : s.toCharArray()) { if (c == \u0026#39;(\u0026#39;) stack.push(\u0026#39;)\u0026#39;); else if (c == \u0026#39;{\u0026#39;) stack.push(\u0026#39;}\u0026#39;); else if (c == \u0026#39;[\u0026#39;) stack.push(\u0026#39;]\u0026#39;); else{ if(stack.empty(){ return false; } char temp=stack.pop(); if(c!=temp){ return false; } } } return stack.isEmpty(); } //[{()}] // } 補充 STACK.peek() -\u0026gt; 返回值：該方法返回堆棧頂部的元素，如果堆棧為空，則返回NULL。\n舉例：\npublic class StackDemo { public static void main(String args[]) { // Creating an empty Stack Stack\u0026lt;String\u0026gt; STACK = new Stack\u0026lt;String\u0026gt;(); // Use push() to add elements into the Stack STACK.push(\u0026#34;Welcome\u0026#34;); STACK.push(\u0026#34;To\u0026#34;); STACK.push(\u0026#34;Taiwan\u0026#34;); // Displaying the Stack System.out.println(\u0026#34;Initial Stack: \u0026#34; + STACK); // Fetching the element at the head of the Stack System.out.println(\u0026#34;The element at the top of the\u0026#34; + \u0026#34; stack is: \u0026#34; + STACK.peek()); // Displaying the Stack after the Operation System.out.println(\u0026#34;Final Stack: \u0026#34; + STACK); } } 輸出：\nInitial Stack: [Welcome, To, Taiwan] The element at the top of the stack is: Taiwan Final Stack: [Welcome, To, Taiwan] ","permalink":"https://pattysung1.github.io/works/leetcode-20/","tags":["leetcode","Stack"],"title":"Leetcode-20. Valid Parentheses"},{"categories":["Programming"],"contents":"Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\nFor example, the following two linked lists begin to intersect at node c1:\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\nNote that the linked lists must retain their original structure after the function returns.\nExample 1: Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 Output: Intersected at \u0026#39;8\u0026#39; Explanation: The intersected node\u0026#39;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Example 2:\nInput: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Intersected at \u0026#39;2\u0026#39; Explanation: The intersected node\u0026#39;s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3:\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: No intersection Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null. \u0026lt;解題\u0026gt; 在迴圈中，判斷兩個指針 a 和 b 是否相等。 如果相等，表示找到了交點，跳出迴圈 while( a != b)時，如果短的那條走完，會接著走長的那條，可以確保兩個指針分別走過了鏈表 A 和鏈表 B 的長度之和 若兩者沒有交點，則會在跑完兩個head後，得到值null並返回 public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) return null; ListNode a = headA; ListNode b = headB; while( a != b){ a = a == null? headB : a.next; //如果 a 達到鏈表的尾部，則將 a 設置為 headB，以便後續遍歷 headB 的節點 b = b == null? headA : b.next; //如果 b 達到鏈表的尾部，則將 b 設置為 headA，以便後續遍歷 headA 的節點 } return a; } Time : O(m+n) Space : O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-160/","tags":["leetcode"],"title":"Leetcode-160. Intersection of Two Linked Lists"},{"categories":["Programming"],"contents":"Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\nImplement the MyQueue class:\nvoid push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise. Notes:\nYou must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack\u0026rsquo;s standard operations.\nExample 1:\nInput [\u0026#34;MyQueue\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;peek\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;empty\u0026#34;] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false\n\u0026lt;解題\u0026gt; class MyQueue { public void push(int x) { input.push(x); } public int pop() { peek(); return output.pop(); } public int peek() { if (output.isEmpty()) while (!input.isEmpty()) output.push(input.pop()); return output.peek(); } public boolean empty() { return input.isEmpty() \u0026amp;\u0026amp; output.isEmpty(); } private Deque\u0026lt;Integer\u0026gt; input = new ArrayDeque\u0026lt;\u0026gt;(); private Deque\u0026lt;Integer\u0026gt; output = new ArrayDeque\u0026lt;\u0026gt;(); } ","permalink":"https://pattysung1.github.io/works/leetcode-232/","tags":["leetcode","Queue"],"title":"Leetcode-232. Implement Queue using Stacks"},{"categories":["Programming"],"contents":"Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\nExample 1: Input: head = [1,2,3,3,4,4,5] Output: [1,2,5] Example 2:\nInput: head = [1,1,1,2,3] Output: [2,3] -\u0026gt;重複的數字就刪除\n\u0026lt;解題\u0026gt; 用slow、fast指標，若fast.next != null \u0026amp;\u0026amp; fast.val == fast.next.val，fast指標往後移 判斷：slow.next 是否為 fast： -slow.next != fast，代表有重複的數，將他移除（slow.next = fast.next)，記得將指標重置 -else，代表沒有重複的數，兩者指標繼續向後移動 迴圈結束，return dummy.next public class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode dummy = new ListNode(0); ListNode fast = head, slow = dummy; slow.next = fast; while(fast != null) { while (fast.next != null \u0026amp;\u0026amp; fast.val == fast.next.val) { fast = fast.next; //fast指標向後移 } if (slow.next != fast) { //有重複的數 slow.next = fast.next; //remove the dups fast = slow.next; //reposition the fast pointer } else { //no dup, move down both pointer slow = slow.next; fast = fast.next; } } return dummy.next; } } Time : O(n) Space : O(1)\n刪除重複的節點（但會留下重複的數字的一個） Leetcode-83. Remove Duplicates from Sorted List\n","permalink":"https://pattysung1.github.io/works/leetcode-82/","tags":["leetcode"],"title":"Leetcode-82. Remove Duplicates from Sorted List II"},{"categories":["Programming"],"contents":"Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\nExample 1:\nInput: head = [1,1,2] Output: [1,2] Example 2:\nInput: head = [1,1,2,3,3] Output: [1,2,3] \u0026lt;解題\u0026gt; 1. class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode current_node = head; while (current_node!=null \u0026amp;\u0026amp; current_node.next != null){ if(current_node.val == current_node.next.val){ current_node.next = current_node.next.next; } else{ current_node = current_node.next; } } return head; } } Time: O(n) Space: O(1)\n2.利用遞迴 class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null || head.next == null)return head; head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head; } } Time: O(n) Space: O(n)\n刪除重複的節點（但不會留下重複的數字的一個） Leetcode-82. Remove Duplicates from Sorted List II\n","permalink":"https://pattysung1.github.io/works/leetcode-83/","tags":["leetcode"],"title":"Leetcode-83. Remove Duplicates from Sorted List"},{"categories":["Programming"],"contents":"Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\nExample 1:\nInput: s = \u0026#34;the sky is blue\u0026#34; Output: \u0026#34;blue is sky the\u0026#34; Example 2:\nInput: s = \u0026#34; hello world \u0026#34; Output: \u0026#34;world hello\u0026#34; Explanation: Your reversed string should not contain leading or trailing spaces. Example 3:\nInput: s = \u0026#34;a good example\u0026#34; Output: \u0026#34;example good a\u0026#34; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. \u0026lt;解題\u0026gt; 先創建一個 StringBuilder 物件 sb，用於構建反轉後的字串 從最後一個字符開始向前遍歷原始字串 把空格先排除 找到單字後從最後一個開始找回 public class Solution { public String reverseWords(String s) { StringBuilder sb = new StringBuilder(); int n = s.length(); int i = n - 1; while(i \u0026gt;= 0) { if (s.charAt(i) == \u0026#39; \u0026#39;) { i--; continue; } int j = i; while(j \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(j) != \u0026#39; \u0026#39;) j--; sb.append(\u0026#34; \u0026#34;); sb.append(s.substring(j + 1, i + 1)); i = j; } if (sb.length() \u0026gt; 0) sb.deleteCharAt(0); return sb.toString(); } } ","permalink":"https://pattysung1.github.io/works/leetcode-151/","tags":["leetcode"],"title":"Leetcode-151. Reverse Words in a String*"},{"categories":["Programming"],"contents":"Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2:\nInput: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] ","permalink":"https://pattysung1.github.io/works/leetcode-189/","tags":["leetcode"],"title":"Leetcode-189. Rotate Array"},{"categories":["Programming"],"contents":"Given the head of a linked list, remove the nth node from the end of the list and return its head.\nExample 1:\nInput: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:\nInput: head = [1], n = 1 Output: [] Example 3:\nInput: head = [1,2], n = 1 Output: [1] \u0026lt;解題\u0026gt; 使用 fast 指針向前移動 n + 1 步，以創造出 n 個節點的間隔，這樣在 fast 達到鏈表尾部時，slow 將指向倒數第 n 個節點的前一個節點 最後指向倒數n的下一位 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); ListNode slow = dummy, fast = dummy; dummy.next = head; //先讓fast走n步 for(int i=0; i\u0026lt;=n; i++) { fast = fast.next; } //slow會走到倒數n的位置 while(fast != null) { slow = slow.next; fast = fast.next; } //跳過倒數n的下一位 dummy.next = slow.next.next; return dummy.next; } } ","permalink":"https://pattysung1.github.io/works/leetcode-19/","tags":["leetcode"],"title":"Leetcode-19. Remove Nth Node From End of List"},{"categories":["Programming"],"contents":"Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nInput: nums = [1,2,3,1] Output: true Example 2:\nInput: nums = [1,2,3,4] Output: false Example 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2] Output: true -\u0026gt;如果有重複兩次，回傳true\n\u0026lt;解題\u0026gt; 使用迴圈及HashSet看有無重複，有的話就返回true，沒有的的話就加到HashSet中 class Solution { public boolean containsDuplicate(int[] nums) { HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { if (set.contains(nums[i])) { return true; } set.add(nums[i]); } return false; } } Time complexity: O(n) Space complexity: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-217/","tags":["leetcode"],"title":"Leetcode-217. Contains Duplicate"},{"categories":["Programming"],"contents":"Given the head of a linked list, rotate the list to the right by k places.\nExample 1:\nInput: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2:\nInput: head = [0,1,2], k = 4 Output: [2,0,1] \u0026lt;解題\u0026gt; 判斷若為空，直接返回head 建立一個dummy ListNode，並將他指向head 建立fast, slow ListNode，等於dummy（從頭） 用fast指標來算出總長度 用slow指標找到要旋轉的位置 進行旋轉操作 class Solution { public ListNode rotateRight(ListNode head, int n) { if (head==null||head.next==null) return head; ListNode dummy=new ListNode(0); dummy.next=head; ListNode fast=dummy,slow=dummy; int i; for (i=0;fast.next!=null;i++)//Get the total length fast=fast.next; for (int j=i-n%i;j\u0026gt;0;j--) //Get the i-n%i th node slow=slow.next; fast.next=dummy.next; //將 fast.next（即整個鏈表的尾部）連接到 dummy.next（即原始鏈表的頭部），這樣鏈表就形成了循環連接 dummy.next=slow.next; //將 dummy.next（即原始鏈表的頭部）連接到 slow.next（即要旋轉的位置的後一個節點），這樣鏈表就被分成了兩部分。 slow.next=null; //將 slow.next（即要旋轉的位置）的 next 指針設為 null，斷開兩部分之間的連接。 return dummy.next; } } Time Complexity: O(n) Space Complexity: O(1)\n自己測試的資料 public class Main { public static void main(String[] args) { Solution solution = new Solution(); // Create a linked list from the array ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5,6}); // Rotate the linked list int n = 2; ListNode rotatedHead = solution.rotateRight(head, n); // Print the resulting linked list printLinkedList(rotatedHead); } // Helper method to create a linked list from an array private static ListNode createLinkedList(int[] nums) { ListNode dummy = new ListNode(0); ListNode current = dummy; for (int num : nums) { current.next = new ListNode(num); current = current.next; } return dummy.next; } // Helper method to print the elements of a linked list private static void printLinkedList(ListNode head) { ListNode current = head; while (current != null) { System.out.print(current.val + \u0026#34; \u0026#34;); current = current.next; } System.out.println(); } } ","permalink":"https://pattysung1.github.io/works/leetcode-61/","tags":["leetcode"],"title":"Leetcode-61. Rotate List"},{"categories":["Programming"],"contents":"Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\nInput: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,_,_] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). \u0026lt;解題\u0026gt; 前兩個數值可以直接fixed不用看，加入數組 後面的數字只要大於前兩個的index（重複數字最多兩個），即可加入數組 *圖片資料來源：Youtube-Algorithms Made Easy\npublic int removeDuplicates(int[] nums) { int i = 0; for (int n : nums) if (i \u0026lt; 2 || n \u0026gt; nums[i - 2]) nums[i++] = n; return i; } Time: T(n) Space: T(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-80/","tags":["leetcode"],"title":"Leetcode-80. Remove Duplicates from Sorted Array II"},{"categories":["Programming"],"contents":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2:\nInput: l1 = [0], l2 = [0] Output: [0] Example 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] \u0026lt;解題\u0026gt; 因為他是把陣列裡的數字反過來儲存後，再相加，所以我們必須要從第一個節點的值開始處理。 判斷l1, l2值是否處理完畢（為空）-\u0026gt;//l1 != null：表示鏈表 l1 還有數字未處理carry \u0026gt; 0：表示存在進位 同時也要用carry值來儲存值，讓下一位數進位與否。 public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode temp = new ListNode(0); ListNode result = temp; int dummy= 0; int carry = 0; while (l1!=null || l2!=null || carry\u0026gt;0){ //l1 != null：表示鏈表 l1 還有數字未處理carry \u0026gt; 0：表示存在進位 if(l1!=null) { dummy += l1.val; l1 = l1.next; } if (l2!=null){ dummy += l2.val; l2 = l2.next; } dummy += carry; if (dummy\u0026gt;9){ dummy -= 10; carry =1; //進位 } else { carry=0; //沒進位 } temp.next = new ListNode(dummy); temp = temp.next; dummy =0; } return result.next; } } Time: O(Max(m,n)) Space: O(Max(m,n))\nm and n are the size of l1 and l2 \u0026lt;補充\u0026gt; 在寫的時候，自己輸入了數字去驗證\npublic class Main { public static void main(String[] args) { ListNode l1 = createLinkedList(new int[] {2,4,3}); ListNode l2 = createLinkedList(new int[] {5,6,4}); Solution solution = new Solution(); ListNode result = solution.addTwoNumbers(l1, l2); // 輸出結果鏈表 printLinkedList(result); } // 輔助方法，將陣列轉換為鏈表 private static ListNode createLinkedList(int[] nums) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : nums) { dummy.next = new ListNode(num); dummy = dummy.next; } return curr.next; } // 輔助方法，輸出鏈表的值 private static void printLinkedList(ListNode head) { ListNode curr = head; while (curr != null) { System.out.print(curr.val + \u0026#34; \u0026#34;); curr = curr.next; } System.out.println(); } } public class ListNode { int val; ListNode next; ListNode prev; ListNode(int val) { this.val = val; } } public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode temp = new ListNode(0); ListNode result = temp; int num1 = 0; int num2 = 0; while (l1 != null || l2 != null || num2 \u0026gt; 0) { //l1 != null：表示鏈表 l1 還有數字未處理num2 \u0026gt; 0：表示存在進位 if (l1 != null) { num1 += l1.val; l1 = l1.next; } if (l2 != null) { num1 += l2.val; l2 = l2.next; } num1 += num2; if (num1 \u0026gt; 9) { num1 -= 10; num2 = 1; //進位=1 } else { num2 = 0; //沒進位=0 } temp.next = new ListNode(num1); temp = temp.next; num1 = 0; } return result.next; } } \u0026lt;補充\u0026gt; condition ? expression1 : expression2 -\u0026gt; 這個語法表示如果條件為真，則返回表達式1的結果；否則，返回表達式2的結果 和以下相同： if (condition) expression1; else expression2; ","permalink":"https://pattysung1.github.io/works/leetcode-2/","tags":["leetcode"],"title":"Leetcode-2. Add Two Numbers"},{"categories":["Programming"],"contents":"Given the head of a singly linked list, reverse the list, and return the reversed list.\nExample 1:\nInput: head = [1,2,3,4,5] Output: [5,4,3,2,1] Example 2:\nInput: head = [1,2] Output: [2,1] Example 3:\nInput: head = [] Output: [] \u0026lt;解題\u0026gt; 1. iterative solution class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; //建新的linkedlist while (head != null) { ListNode next_node = head.next; head.next = prev; prev = head; head = next_node; } return prev; } } 2. recursive solution class Solution { public ListNode reverseList(ListNode head) { return reverseListInt(head, null); } private ListNode reverseListInt(ListNode head, ListNode newHead) { if (head == null) return newHead; ListNode next_node = head.next; head.next = newHead; return reverseListInt(next_node, head); } } ","permalink":"https://pattysung1.github.io/works/leetcode-206/","tags":["leetcode"],"title":"Leetcode-206. Reverse Linked List"},{"categories":["Programming"],"contents":"You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nExample 1:\nInput: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:\nInput: list1 = [], list2 = [] Output: [] Example 3:\nInput: list1 = [], list2 = [0] Output: [0] \u0026lt;解題\u0026gt; 先判斷l1,l2是否為null，如果是的話直接返回另外一個list 兩個list皆非null情況下，比較大小，比較小的，就先接上去 若其中一個已空，判斷是哪個非空，非空的直接接回去 1. iteration 迭代 寫法 class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode current = dummy; while (l1 != null \u0026amp;\u0026amp; l2 != null) { if (l1.val \u0026lt; l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } if (l1 != null) { current.next = l1; } else { current.next = l2; } return dummy.next; } } 2. Recursion 遞迴 寫法 class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val \u0026lt; l2.val){ l1.next = mergeTwoLists(l1.next, l2); return l1; } else{ l2.next = mergeTwoLists(l1, l2.next); return l2; } } } ","permalink":"https://pattysung1.github.io/works/leetcode-21/","tags":["leetcode"],"title":"Leetcode-21. Merge Two Sorted Lists"},{"categories":["Programming"],"contents":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2:\nInput: nums = [3,2,4], target = 6 Output: [1,2] Example 3:\nInput: nums = [3,3], target = 6 Output: [0,1] \u0026lt;解題\u0026gt; 從迴圈中先找第一個數，及target和此數的相減值diff 如果diff在hashMap中，就回傳這個array 如果沒有的話，就存放在hashmap中-\u0026gt;prevMap.put(num,i); 如果整個迴圈中，沒有成立這樣的組合，就回傳空的array class Solution { public int[] twoSum(int[] nums, int target) { HashMap\u0026lt;Integer, Integer\u0026gt; prevMap = new HashMap\u0026lt;\u0026gt;(); for(int i =0 ; i\u0026lt;nums.length; i++){ int num = nums[i]; int diff = target-num; if(prevMap.containsKey(diff)){ return new int[] {i,prevMap.get(diff)}; } prevMap.put(num,i); } return new int[] {}; } } \u0026lt;補充\u0026gt; 空的array new int[] {} 等於 new int [0] 都表示一個空陣列 ","permalink":"https://pattysung1.github.io/works/leetcode-1/","tags":["leetcode"],"title":"Leetcode-1. Two Sum"},{"categories":["Programming"],"contents":"Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail\u0026rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). Example 2:\nInput: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 0th node. Example 3:\nInput: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. -\u0026gt;要找出此linkedlist中是否有環\n\u0026lt;解題\u0026gt; 用快和慢兩指針，快的一次走兩步、慢的一次走一步，如果兩者最後能後相遇，代表當中有環 可以先在一開始確認(head == null)的話，就直接return false public class Solution { public boolean hasCycle(ListNode head) { if (head == null) { return false; } ListNode slow = head; ListNode fast = head.next; while (slow != fast \u0026amp;\u0026amp; fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow == fast; } } Time Complexity: O(N) Space Complexity: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-141/","tags":["leetcode"],"title":"Leetcode-141. Linked List Cycle"},{"categories":["Programming"],"contents":"You are given an integer array nums. You are initially positioned at the array\u0026rsquo;s first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nInput: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:\nInput: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. \u0026lt;解題\u0026gt; class Solution { public boolean canJump(int[] nums) { int boundary = 0; //最遠範圍 for(int i =0;i\u0026lt;=boundary;i++){ boundary = Math.max(boundary,i+nums[i]); //boundary和跳躍最大跳躍長度取最大值 if(boundary \u0026gt;=nums.length-1) return true; } return false; } } Time Complexity : O(n) Space Complexity: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-55/","tags":["leetcode"],"title":"Leetcode-55. Jump Game"},{"categories":["Programming"],"contents":"You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2:\nInput: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. -\u0026gt;找出最低價（買）和最高價（賣）\n\u0026lt;解題\u0026gt; 找出最低價（買） 找出最高利潤Max(maxProfit, prices[i]-min) class Solution { public int maxProfit(int[] prices) { int n = prices.length; int min = Integer.MAX_VALUE; int maxProfit = 0; for (int i=0 ; i\u0026lt;n ;i++){ if(prices[i]\u0026lt; min) min = prices[i]; maxProfit = Math.max(maxProfit, prices[i]-min); } return maxProfit; } } Time Complexity: O(N) Space Complexity: O(1)\n\u0026lt;補充\u0026gt; Integer.MAX_VALUE //數字最大值 ","permalink":"https://pattysung1.github.io/works/leetcode-121/","tags":["leetcode"],"title":"Leetcode-121. Best Time to Buy and Sell Stock"},{"categories":["Programming"],"contents":"You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\nExample 1:\nInput: prices = [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Total profit is 4 + 3 = 7. Example 2:\nInput: prices = [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Total profit is 4. Example 3:\nInput: prices = [7,6,4,3,1] Output: 0 Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0. \u0026lt;解題\u0026gt; 如果後一天比前一天價格高，就相減計算兩者的利潤 返回profit class Solution { public int maxProfit(int[] prices) { int n = prices.length; int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit = profit + (prices[i] - prices[i - 1]); } } return profit; } } Time Complexity: O(N) Space Complexity: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-122/","tags":["leetcode"],"title":"Leetcode-122. Best Time to Buy and Sell Stock II"},{"categories":["Programming"],"contents":"Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: s = \u0026#34;anagram\u0026#34;, t = \u0026#34;nagaram\u0026#34; Output: true Example 2:\nInput: s = \u0026#34;rat\u0026#34;, t = \u0026#34;car\u0026#34; Output: false 判斷s、t字串，排序之後是否相等\n\u0026lt;解法\u0026gt; 1. 用陣列比較 import java.util.Arrays; class Solution { public boolean isAnagram(String s, String t) { char[] sArr = s.toCharArray(); char[] tArr = t.toCharArray(); Arrays.sort(sArr); Arrays.sort(tArr); return Arrays.equals(sArr,tArr); } } 2. 使用一個長度為 26 的陣列來統計字母出現的次數（改善空間複雜度） class Solution { public boolean isAnagram(String s, String t) { if (s.length() != t.length()) { return false; } int[] count = new int[26]; // 使用一個長度為 26 的陣列來統計字母出現的次數 // 將 s 字串中的字母計數加 1 for (char c : s.toCharArray()) { count[c - \u0026#39;a\u0026#39;]++; } // 將 t 字串中的字母計數減 1 for (char c : t.toCharArray()) { count[c - \u0026#39;a\u0026#39;]--; } // 檢查每個字母計數是否為 0，如果有非 0 的計數則表示兩個字串不是異位詞 for (int i = 0; i \u0026lt; 26; i++) { if (count[i] != 0) { return false; } } return true; } } \u0026lt;補充\u0026gt;.toCharArray() 把字串轉成字元 public class Main { public static void main(String args[]) { String Str = new String(\u0026#34;Hello word\u0026#34;); System.out.print(\u0026#34;返回值 :\u0026#34; ); System.out.println( Str.toCharArray() ); } } ","permalink":"https://pattysung1.github.io/works/leetcode-242/","tags":["leetcode"],"title":"Leetcode-242. Valid Anagram"},{"categories":["Programming"],"contents":"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k.\n給定一個排序數組，你需要在原地刪除重複出現的元素，使得每個元素只出現一次，返回移除後數組的新長度。\n不要使用額外的數組空間，你必須在原地修改輸入數組並使用O（1）額外空間的條件下完成。\nExample 1:\nInput: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). \u0026lt;解題\u0026gt; 條件檢查：程式碼確保nums不為空\u0026amp;\u0026amp;長度不為0 設定初始值=1和不重複元素值為目前第一個元素 將非重複元素放入答案的位置，指標繼續往後動 class Solution { public int removeDuplicates(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int answer = 1; // 初始化答案為1，因為第一個元素肯定是不重複的 int prev = nums[0]; // 用來記錄前一個非重複元素的值 for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] != prev) { nums[answer] = nums[i]; // 將非重複元素放入答案的位置 prev = nums[i]; // 更新prev的值為目前的元素 answer++; // 答案位置往後移動 } } return answer; } } ","permalink":"https://pattysung1.github.io/works/leetcode-26/","tags":["leetcode"],"title":"Leetcode-26. Remove Duplicates from Sorted Array"},{"categories":["Programming"],"contents":"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [\u0026hellip;]; // Input array int val = \u0026hellip;; // Value to remove int[] expectedNums = [\u0026hellip;]; // The expected answer with correct length. // It is sorted with no values equaling val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i \u0026lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1: Input: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores).\n-\u0026gt;對於返回的結果中的五個元素，它們的順序並不重要，可以以任意順序返回這五個元素，並且不需要對返回的 k 之後的元素做任何處理（可以用底線表示）\n\u0026lt;解題\u0026gt; 給一個數組nums和一個值val，需要移除所有數值等於val的元素，返回移除後數組的新長度。 建一個迴圈，開始跑每個數值，當數值和val不同，就存在本來的數列（數值相同的不存入） class Solution { public int removeElement(int[] nums, int val) { int returnValue = 0; if (nums != null \u0026amp;\u0026amp; nums.length \u0026gt; 0) { for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != val) { nums[returnValue] = nums[i]; returnValue++; } } } return returnValue; } } ","permalink":"https://pattysung1.github.io/works/leetcode-27/","tags":["leetcode"],"title":"Leetcode-27. Remove Element"},{"categories":["Programming"],"contents":"Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1: Input: haystack = \u0026#34;sadbutsad\u0026#34;, needle = \u0026#34;sad\u0026#34; Output: 0 Explanation: \u0026#34;sad\u0026#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2: Input: haystack = \u0026#34;leetcode\u0026#34;, needle = \u0026#34;leeto\u0026#34; Output: -1 Explanation: \u0026#34;leeto\u0026#34; did not occur in \u0026#34;leetcode\u0026#34;, so we return -1. \u0026lt;解題\u0026gt; haystack的長度比needle的長度長，故if(haystack.length\u0026lt;needle.length)-\u0026gt;return -1 兩者相等-\u0026gt;return 0 迴圈：從haystack中跑到每個字母的substring和needle一樣，return i 1.直接使用substring public int strStr(String haystack, String needle) { int l1=haystack.length(); int l2=needle.length(); if(l1\u0026lt;l2) { return -1; } else if(l2==0) { return 0; } for(int i=0;i\u0026lt;=l1-l2;i++) { if(haystack.substring(i,i+l2).equals(needle)) { return i; } } return -1; } 2.如果不能使用substring class Solution { public int strStr(String haystack, String needle) { int l1 = haystack.length(); int l2 = needle.length(); if (l1 \u0026lt; l2) { return -1; } else if (l2 == 0) { return 0; } else { for (int i = 0; i \u0026lt;= l1 - l2; i++) { boolean found = true; //先預設為true for (int j = 0; j \u0026lt; l2; j++) { //找接下來字母有無相同 if (haystack.charAt(i+j) != needle.charAt(j)){ found =false; break; } } if (found){ return i; } } } return -1; } } ","permalink":"https://pattysung1.github.io/works/leetcode-28/","tags":["leetcode"],"title":"Leetcode-28. Find the Index of the First Occurrence in a String"},{"categories":["Programming"],"contents":"Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: strs = [\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;,\u0026#34;tan\u0026#34;,\u0026#34;ate\u0026#34;,\u0026#34;nat\u0026#34;,\u0026#34;bat\u0026#34;] Output: [[\u0026#34;bat\u0026#34;],[\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;],[\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;]] Example 2:\nInput: strs = [\u0026#34;\u0026#34;] Output: [[\u0026#34;\u0026#34;]] Example 3:\nInput: strs = [\u0026#34;a\u0026#34;] Output: [[\u0026#34;a\u0026#34;]] 給一字符串數組，將錯位詞(相同字符不同排列的字符串)分組\n\u0026lt;解題\u0026gt; 用HashMap去建Map\u0026lt;String, ArrayList\u0026gt;，用排序後的字串為key 先把String 轉成 Char以排序 -\u0026gt;.toCharArray() 排序以作為key 再轉回String -\u0026gt; String.valueOf(str) class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { Map\u0026lt;String, ArrayList\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String s: strs){ char[] key_str = s.toCharArray(); //string 轉成char Arrays.sort(key_str); String key = String.valueOf(key_str);//轉回string if(map.containsKey(key)){//判斷此key是否在map map.get(key).add(s); //有的話將s加入該key的value中 } else{ map.put(key, new ArrayList\u0026lt;\u0026gt;());//沒有的話將key加入map，並在value建立一個類別 map.get(key).add(s); } } return new ArrayList\u0026lt;\u0026gt;(map.values()); //最後把map.values()的值，在新的ArrayList中回傳 } } ","permalink":"https://pattysung1.github.io/works/leetcode-49/","tags":["leetcode"],"title":"Leetcode-49. Group Anagrams"},{"categories":["Programming"],"contents":"You are given an integer array nums. You are initially positioned at the array\u0026rsquo;s first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nInput: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:\nInput: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. \u0026lt;解題\u0026gt; ","permalink":"https://pattysung1.github.io/works/leetcode-55/","tags":["leetcode"],"title":"Leetcode-55. Jump Game"},{"categories":["Programming"],"contents":"You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. 給定兩個有序整數數組 nums1和nums2，將nums2合併到 nums1 中，使得 num1成為一個有序數組。\n\u0026lt;解題\u0026gt; 把nums1和nums2的最後一個不含0字元設指標，接著比大小，比較大的從nums1的最後一位開始放，放完之後指標往前移 p2\u0026lt;0，代表 nums2 數組中的元素已經全部合併到 nums1，所以把num1剩下的元素處理完 p1\u0026gt;= 0，要確認num1的元素都有處理到 class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { if (null != nums1 \u0026amp;\u0026amp; null != nums2 \u0026amp;\u0026amp; nums1.length == m + n) { int p1 = m - 1 int p2 = n - 1; for (int i = m + n - 1; i \u0026gt;= 0; i--) { if (p2 \u0026lt; 0 ||(p1 \u0026gt;= 0 \u0026amp;\u0026amp; nums1[p1] \u0026gt; nums2[p2])) { nums1[i] = nums1[p1]; p1--; } else { nums1[i] = nums2[p2]; p2--; } } } } } ","permalink":"https://pattysung1.github.io/works/leetcode-88/","tags":["leetcode"],"title":"Leetcode-88. Merge Sorted Array"},{"categories":["Programming"],"contents":"以下是幾種方法可以將字元轉換為 ASCII 值： 1. 使用 (int) 類型轉換： char c = \u0026#39;a\u0026#39;; int asciiValue = (int) c; System.out.println(asciiValue); // 輸出: 97 2. 使用 Character.getNumericValue 方法： char c = \u0026#39;A\u0026#39;; int asciiValue = Character.getNumericValue(c); System.out.println(asciiValue); // 輸出: 10 3. 使用數學運算，減去對應的 ASCII 值： Copy code char c = \u0026#39;0\u0026#39;; int asciiValue = c - \u0026#39;0\u0026#39;; System.out.println(asciiValue); // 輸出: 0 ","permalink":"https://pattysung1.github.io/works/leetcode-ascii/","tags":["ASCII"],"title":"將字元轉換成ASCII值"},{"categories":["Programming"],"contents":"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer.\nExample 1: Input: s = \u0026#34;III\u0026#34; Output: 3 Explanation: III = 3. Example 2: Input: s = \u0026#34;LVIII\u0026#34; Output: 58 Explanation: L = 50, V= 5, III = 3. Example 3: Input: s = \u0026#34;MCMXCIV\u0026#34; Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. \u0026lt;解題\u0026gt; 先定義每一個字元對應的Value -\u0026gt; HashMap 值大的字母擺在越前面，故從前面往後找，當下一位字母的值比前位大時，要用減法 減法計算：記得減去前一位的2倍（因為本來被加過一次了，所以要扣回） 1. 對應字元-\u0026gt;直接用字元比較好 class Solution { public int romanToInt(String s) { int result = 0; if(s != \u0026#34;\u0026#34;){ HashMap\u0026lt;Character,Integer\u0026gt; map = new HashMap\u0026lt;Character,Integer\u0026gt;(); map.put(\u0026#39;I\u0026#39;, 1); map.put(\u0026#39;V\u0026#39;, 5); map.put(\u0026#39;X\u0026#39;, 10); map.put(\u0026#39;L\u0026#39;, 50); map.put(\u0026#39;C\u0026#39;, 100); map.put(\u0026#39;D\u0026#39;, 500); map.put(\u0026#39;M\u0026#39;, 1000); for(int i = 0 ; i\u0026lt;s.length() ; i++){ Character temp = s.charAt(i); int value = 0; if(map.containsKey(temp)){ value = map.get(temp); //字元的值 if(i != 0 \u0026amp;\u0026amp; (map.get(s.charAt(i-1)) \u0026lt; value) ){ value = value - (map.get(s.charAt(i-1))*2); //減去前面數本身*2 } result = result + value; } } } return result; } } 2. 對應字串，但之後記得要轉換 class Solution { public int romanToInt(String s) { int result = 0; if(s != \u0026#34;\u0026#34;){ HashMap\u0026lt;String,Integer\u0026gt; map = new HashMap\u0026lt;String,Integer\u0026gt;(); map.put(\u0026#34;I\u0026#34;, 1); map.put(\u0026#34;V\u0026#34;, 5); map.put(\u0026#34;X\u0026#34;, 10); map.put(\u0026#34;L\u0026#34;, 50); map.put(\u0026#34;C\u0026#34;, 100); map.put(\u0026#34;D\u0026#34;, 500); map.put(\u0026#34;M\u0026#34;, 1000); for(int i = 0 ; i\u0026lt;s.length() ; i++){ String temp = s.charAt(i)+\u0026#34;\u0026#34;; //把字元轉成字串 // String temp = Character.toString(s.charAt(i)); //把字元轉成字串 int value = 0; if(map.containsKey(temp)){ value = map.get(temp); if(i != 0 \u0026amp;\u0026amp; (map.get(s.charAt(i-1)+\u0026#34;\u0026#34;) \u0026lt; value) ){ value = value - (map.get(s.charAt(i-1)+\u0026#34;\u0026#34;))*2; } result = result + value; } } } return result; } } \u0026lt;補充\u0026gt;字元轉字串 1. String temp = s.charAt(i)+\u0026#34;\u0026#34;; //把字元轉成字串 2. String temp = Character.toString(s.charAt(i)); //把字元轉成字串 3. Integer.valueOf() 方法用於將字串轉換為整數，而不是將單個\u0026#34;字元\u0026#34;轉換為整數。 \u0026lt;補充\u0026gt;HashMap containsKey() 方法 import java.util.HashMap; class Main { public static void main(String[] args) { HashMap\u0026lt;Integer, String\u0026gt; sites = new HashMap\u0026lt;\u0026gt;(); sites.put(1, \u0026#34;Google\u0026#34;); sites.put(2, \u0026#34;Yahoo\u0026#34;); sites.put(3, \u0026#34;Apple\u0026#34;); System.out.println(\u0026#34;sites HashMap: \u0026#34; + sites); //檢查是否存在 if(sites.containsKey(1)) { System.out.printf(\u0026#34;key %d 存在於 sites 中%n\u0026#34;, 1); //若要使用格式化字符 System.out.println(\u0026#34;key \u0026#34; + 1 + \u0026#34; 存在於 sites 中\u0026#34;); } //若不存在，則新增 if (!sites.containsKey(4)){ sites.put(4, \u0026#34;Tesla\u0026#34;); } System.out.println(\u0026#34;New sites HashMap:\u0026#34; + sites); } } \u0026lt;補充\u0026gt;格式化字符 //檢查是否存在 if(sites.containsKey(1)) { System.out.printf(\u0026#34;key %d 存在於 sites 中%n\u0026#34;, 1); //若要使用格式化字符 System.out.println(\u0026#34;key \u0026#34; + 1 + \u0026#34; 存在於 sites 中\u0026#34;); } ","permalink":"https://pattysung1.github.io/works/leetcode-13/","tags":["leetcode"],"title":"Leetcode-13. Roman to Integer"},{"categories":["Programming"],"contents":"Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.\nExample 1:\nInput: s = \u0026ldquo;Hello World\u0026rdquo; Output: 5 Explanation: The last word is \u0026ldquo;World\u0026rdquo; with length 5.\n\u0026lt;解題1\u0026gt; 想用空格分離後，在找出最後一個單字的長度\nclass Solution { public int lengthOfLastWord(String s) { if( s!= null \u0026amp; s.length()\u0026gt;0){ String[] temp = s.split(\u0026#34; \u0026#34;); if (temp != null \u0026amp;\u0026amp; temp.length\u0026gt;0){ String last = temp[temp.length-1]; return last.length(); } } return 0; } } \u0026lt;解題2\u0026gt; 從最後一個字元開始算，加總字元個數，如果遇到空白就結束，代表已經數完最後一個單字\npublic static int lengthOfLastWord2(String s) { int len = 0; //計算最後一個單字的長度 int tail = s.length() - 1; //整個字串的長度 while (tail \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(tail) == \u0026#39; \u0026#39;) { tail--; //減去後面的空白 } //從後面往前算到該字元為空白為止 while (tail \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(tail) != \u0026#39; \u0026#39;) { len++; tail--; } return len; } 1. s.length() 是字串 s 的方法 length() 的調用，用於獲取字串的長度。它會返回一個整數值，表示字串的長度，所以在調用時需要使用括號。 2. temp.length 是陣列 temp 的屬性 length，用於獲取陣列的長度。在Java中，陣列的長度屬性是一個公開的屬性，不需要使用括號。 \u0026lt;補充-字串符分割\u0026gt;\npublic static void main(String args[]){ String str = \u0026#34;www-hello_world-com\u0026#34;; String[] temp; String delimeter = \u0026#34;-\u0026#34;; // 指定分割字符 temp = str.split(delimeter); // 分割字符串 for(int i =0; i \u0026lt; temp.length ; i++){ System.out.println(temp[i]); System.out.println(\u0026#34;\u0026#34;); } String str1 = \u0026#34;www.hello.world.com\u0026#34;; String[] temp1; String delimeter1 = \u0026#34;\\\\.\u0026#34;; // 指定分割字符(\\\\.) temp1 = str1.split(delimeter1); // 分割字符串 for(String x : temp1){ System.out.println(x); System.out.println(\u0026#34;\u0026#34;); } } \u0026lt;補充-chatAt()\u0026gt;\npublic class Main { public static void main(String args[]) { String s = \u0026#34;www.helloworld.com\u0026#34;; char find = s.charAt(9); System.out.println(find); } } -\u0026gt;w\n*排版快捷鍵： option + command + L\n","permalink":"https://pattysung1.github.io/works/leetcode-58/","tags":["leetcode"],"title":"Leetcode-58. Length of Last Word"},{"categories":["Programming"],"contents":"之前在寫Android Studio的時候，會使用\nLog.d(\u0026#34;Patty\u0026#34;, \u0026#34;xx功能\u0026#34;) 來追蹤程式的執行流程，看有沒有印出的值是否正確或有異常，最近在寫Java Spring Boot，這邊的Log功能，需要先於class中撰寫logger，才可以使用：\nimport org.slf4j.Logger; import org.slf4j.LoggerFactory; public class LoggingExample { private static final Logger logger = Logger.getLogger(LoggingExample.class.getName()); public static void main(String[] args) { logger.info(\u0026#34;This is an informational message.\u0026#34;); logger.warning(\u0026#34;This is a warning message.\u0026#34;); logger.severe(\u0026#34;This is a severe message.\u0026#34;); } } 另外，可以將參數帶入印出：\npublic class MyService { private static final Logger logger = LoggerFactory.getLogger(MyService.class); public void doSomething(String parameter) { logger.info(\u0026#34;Received parameter: {}\u0026#34;, parameter); logger.debug(\u0026#34;Debug message with parameter: \u0026#34; + parameter); } } ","permalink":"https://pattysung1.github.io/works/log/","tags":["Java"],"title":"Log紀錄"},{"categories":["Programming"],"contents":"目前在幫ShinyBear品牌做電商網站，在前後端的傳遞資訊時，時常使用到Json，而使用ObjectMapper，可以將Json字串及Java Object互相作轉換。\n但注意，要記得在pom.xql中加上spring-boot-starter-web\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 說明 ObjectMapper是一個Java庫，用於處理Java對象和JSON之間的相互轉換。它提供了一種簡單而靈活的方法，可將Java對象序列化為JSON格式的字符串，並將JSON字符串反序列化為Java對象。使用ObjectMapper能夠在處理JSON數據時變得更加便捷。\n以下是ObjectMapper的一些常見用法(1.2較常用)： 將Java對象轉換為JSON字符串：(writeValueAsString()) ObjectMapper objectMapper = new ObjectMapper(); YourObject obj = new YourObject(); String jsonString = objectMapper.writeValueAsString(obj); 2.將JSON字符串轉換為Java對象：(readValue())\nObjectMapper objectMapper = new ObjectMapper(); String jsonString = \u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;John\\\u0026#34;,\\\u0026#34;age\\\u0026#34;:30}\u0026#34;; YourObject obj = objectMapper.readValue(jsonString, YourObject.class); 3.格式化JSON輸出：\nObjectMapper objectMapper = new ObjectMapper(); YourObject obj = new YourObject(); String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); 可以使用ObjectMapper生成格式化的JSON字符串，以提高可讀性。\n4.處理特殊情況：\nObjectMapper objectMapper = new ObjectMapper(); objectMapper.setDateFormat(new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;)); YourObject obj = new YourObject(); String jsonString = objectMapper.writeValueAsString(obj); ObjectMapper提供了處理日期格式、處理集合類型、自定義序列化和反序列化等特殊情況的功能。 可以依照要規劃的功能做使用，不過主要還是前兩者使用的多。\n@Jsonproperty: 註解使得Json的key和Java變數可以做轉換 public class Person { @JsonProperty(\u0026#34;first_name\u0026#34;) private String firstName; @JsonProperty(\u0026#34;last_name\u0026#34;) private String lastName; @JsonProperty(\u0026#34;age\u0026#34;) private int age; // getters and setters... } ","permalink":"https://pattysung1.github.io/works/objectmapper/","tags":["Java","ObjectMapper"],"title":"ObjectMapper- Java Object和JSON之間的相互轉換"},{"categories":["Japan日本"],"contents":"自從畢業以及疫情後，已經3年多沒有出國了。看著IG上，朋友們一個個的出國旅遊，心裡好羨慕啊。終於這次趁出國唸書之前，和家人也一起出國囉！\n記得上次去日本大約是快十年前，剛要升高中的時候去的大阪\u0026hellip; 時間真的過得飛快。\n由於看到環球影城有新的瑪利歐世界，因為很喜歡瑪利歐相關的遊戲（瑪利歐、瑪利歐派對、瑪利歐賽車等等）， 於是當然想看看實際去到瑪利歐世界會是怎麼樣子囉！\n▲Mario Parade\n▲Lovely Minion\n如果有興趣看到更多的旅遊照片，可以到Pooh.travel.blog笑咪咪Pooh的旅遊日記觀看！\nps 我最喜歡的角色是耀西和害羞幽靈\n5/14-5/22的行程 由於不想再回到原點，所以搭飛機由大阪進、名古屋出。 因此，我們選擇了5/14桃園機場至大阪的長榮航空， 以及5/22早上從名古屋回桃園機場的華航。 先放上一張總覽圖： 由於主要大阪部分的其他景點以前都去過了，所以只有安排環球影城(主要想去馬力歐樂園)和購物，建議如果第一次來大阪，其實是可以停留4-5天漫遊。\n現在日幣貶值，加上信用卡回饋，買Uniqlo真的就跟台灣價格打75折差不多！ DHC藍莓精華和合力他命的價差也很大，DHC藍莓精華在台灣買大概500-600不等，在那邊的藥妝店比價，平均大概300台幣左右，如果平常會常吃這些保健食品的話，真的很推薦在日本大買特買。\n- 關於交通 這趟旅行的交通部分，主要先訂好票的有關西機場至大阪市區的特快車、大阪至名古屋的JR車票、大阪地鐵巴士一日乘車券。\n另外，有在名古屋車地鐵站，購買一日的地鐵票。\n1.關西機場至大阪市區 由於到大阪已經5點多，出關的時候人滿多的，所以當天晚上就直接到環球影城飯店入住，等待隔天早上直接開始玩。 從大阪關西機場至大阪車站，我們是直接至Klook買。\n訂票方式 關西樂享周遊券（3項設施）+ 關空特快 HARUKA 車票（關西機場→新大阪／天王寺站），除了有從關西機場至市區（可選擇至天王寺、大阪或新大阪車站）外，亦有關西樂享周遊券（3項設施）券可以使用（不過這部分後來因為時間的關係，所以我們也沒有使用到）\nps.購買此票券的時候，klook會有說明如何取票，如果是在關西機場的話，出來之後左轉直直走，接著上二樓到另一棟樓的搭車處的取票機取票，在刷卡進入站前，可以看到班次表。\n2.大阪至名古屋 大阪至名古屋的交通，我們選擇搭乘JR：新大阪到名古屋車站，車程大約50分鐘，售價折合台幣約1500多(匯率1:4左右)。\n訂票方式 官網訂票： 雖然不是中文的，但是按照上面的步驟和翻譯，一步一步的點擊購買，另外，可以選擇適合放置大行李的位子，一個月前就開放可以訂票了。 Klook訂票： Klook真的非常方便，涵蓋旅遊行程、住宿、交通、租車，都可以預訂。當然，JR車票也可以在上面預定囉～！不過，雖然方便，但每張票都要收額外的台幣300元手續費，看到的當下，立馬關掉去訂官網。 3.大阪地鐵票 大阪有one-day和two-day地鐵巴士乘車券，這部分也可以在klook上先訂票。\n訂票方式 大阪地鐵巴士乘車券(1日/2日)\n4.名古屋地鐵票 名古屋地鐵票，是在地鐵站內至詢問處購買的，同時也拿了一張捷運路線圖（也可以拍下來用手機看） ▲One day pass in Nagoya\n▲subway in Nagoya\n▲每週六日及每月8號，購買使用一日乘車券是比較便宜的：大人620日圓、小孩310日圓；剛好我們購買使用那天是星期六XD\n5.名古屋巴士站-愛·地球博紀念公園車站（吉卜力公園) 從名古屋-吉卜力公園，除了搭地鐵外，也可以搭乘巴士，地鐵的價格比巴士便宜一些，但搭乘巴士的話，車程大概35分鐘左右就到了。\n搭乘巴士的位置在名鐵巴士中心的四樓24號，可以上車之後再買付款（一人1000日圓）\n回程在愛·地球博紀念公園車站的3號車牌，就可以搭乘回名鐵巴士中心了。 ▲班次表\n▲地圖相對位置\n","permalink":"https://pattysung1.github.io/travel/post-1/","tags":["Travel","Pooh","大阪","名古屋","吉卜力公園","日本環遊影城"],"title":"2023【大阪-名古屋-黑部立山-吉卜力公園】-交通篇"},{"categories":["Japan日本"],"contents":"關於訂票 吉卜力公園門票 2022年11月1日才開幕的吉卜力公園，目前只開放開個部分：大倉庫、青春之丘、DONDOKO之森。本來想使用官網訂票，但發現好像需要有日本的手機號碼還是相關的認證（有點忘記是什麼），所以後來是在蝦皮代購（可以至上面搜尋吉卜力公園），請人幫忙買票券。價格和官網上的沒有差到很多。但因為只有提前一個多月購買，所以只有買到大倉庫門票。\n官方網站 1.吉卜力大倉庫 2.青春之丘和吉卜力大倉庫門票 3.DONDOKO之森 - 關於黑部立山三日遊 由於四月初準備預定行程時，手邊比較多忙的事情，所以是選擇KKday三天兩夜的白川鄉/高山陣屋、黑部立山、上高地/河童橋遊，包含當中的吃飯及住宿。雖然跟著遊覽車很方便，不過由於喜歡自助，所以還是不太習慣跟團\u0026hellip;.，到每個景點都在趕趕趕和集合，後來發現其實去黑部立山的交通，也可以規劃坐巴士等等，而且費用也便宜很多很多，也不用一直在坐遊覽車以及一直等集合。\n購票平台：KKday Photos 合掌村，5/17到訪天氣超熱 維尼們與mini合掌村 黑部立山上山口 維尼們與雪山 變成冰中雪人 雪的大谷 維尼與雪人 維尼與同團的夥伴 旅遊團採草莓行程，日本的草莓真的很好吃！ 河童橋 ","permalink":"https://pattysung1.github.io/travel/post-2/","tags":["Travel","Pooh","大阪","名古屋","黑部立山","吉卜力公園"],"title":"2023【大阪-名古屋-黑部立山-吉卜力公園】-訂票篇"}]