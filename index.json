[{"categories":["Programming"],"contents":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2:\nInput: l1 = [0], l2 = [0] Output: [0] Example 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] \u0026lt;解題\u0026gt; 因為他是把陣列裡的數字反過來儲存後，再相加，所以我們必須要從第一個節點的值開始處理。 判斷l1, l2值是否處理完畢（為空）-\u0026gt;//l1 != null：表示鏈表 l1 還有數字未處理carry \u0026gt; 0：表示存在進位 同時也要用carry值來儲存值，讓下一位數進位與否。 public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode temp = new ListNode(0); ListNode result = temp; int dummy= 0; int carry = 0; while (l1!=null || l2!=null || carry\u0026gt;0){ //l1 != null：表示鏈表 l1 還有數字未處理carry \u0026gt; 0：表示存在進位 if(l1!=null) { dummy += l1.val; l1 = l1.next; } if (l2!=null){ dummy += l2.val; l2 = l2.next; } dummy += carry; if (dummy\u0026gt;9){ dummy -= 10; carry =1; //進位 } else { carry=0; //沒進位 } temp.next = new ListNode(dummy); temp = temp.next; dummy =0; } return result.next; } } Time: O(Max(m,n)) Space: O(Max(m,n))\nm and n are the size of l1 and l2 \u0026lt;補充\u0026gt; 在寫的時候，自己輸入了數字去驗證\npublic class Main { public static void main(String[] args) { ListNode l1 = createLinkedList(new int[] {2,4,3}); ListNode l2 = createLinkedList(new int[] {5,6,4}); Solution solution = new Solution(); ListNode result = solution.addTwoNumbers(l1, l2); // 輸出結果鏈表 printLinkedList(result); } // 輔助方法，將陣列轉換為鏈表 private static ListNode createLinkedList(int[] nums) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : nums) { dummy.next = new ListNode(num); dummy = dummy.next; } return curr.next; } // 輔助方法，輸出鏈表的值 private static void printLinkedList(ListNode head) { ListNode curr = head; while (curr != null) { System.out.print(curr.val + \u0026#34; \u0026#34;); curr = curr.next; } System.out.println(); } } public class ListNode { int val; ListNode next; ListNode prev; ListNode(int val) { this.val = val; } } public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode temp = new ListNode(0); ListNode result = temp; int num1 = 0; int num2 = 0; while (l1 != null || l2 != null || num2 \u0026gt; 0) { //l1 != null：表示鏈表 l1 還有數字未處理num2 \u0026gt; 0：表示存在進位 if (l1 != null) { num1 += l1.val; l1 = l1.next; } if (l2 != null) { num1 += l2.val; l2 = l2.next; } num1 += num2; if (num1 \u0026gt; 9) { num1 -= 10; num2 = 1; //進位=1 } else { num2 = 0; //沒進位=0 } temp.next = new ListNode(num1); temp = temp.next; num1 = 0; } return result.next; } } \u0026lt;補充\u0026gt; condition ? expression1 : expression2 -\u0026gt; 這個語法表示如果條件為真，則返回表達式1的結果；否則，返回表達式2的結果 和以下相同： if (condition) expression1; else expression2; ","permalink":"https://pattysung1.github.io/works/leetcode-2/","tags":["leetcode"],"title":"Leetcode-2. Add Two Numbers"},{"categories":["Programming"],"contents":"You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nExample 1:\nInput: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:\nInput: list1 = [], list2 = [] Output: [] Example 3:\nInput: list1 = [], list2 = [0] Output: [0] \u0026lt;解題\u0026gt; ","permalink":"https://pattysung1.github.io/works/leetcode-21/","tags":["leetcode"],"title":"Leetcode-21. Merge Two Sorted Lists"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; ","permalink":"https://pattysung1.github.io/works/leetcode-copy-2/","tags":["leetcode"],"title":"Leetcode-"},{"categories":["Programming"],"contents":"Heading 1 Heading 2 Heading 3 Heading 4 Heading 5 Heading 6 Emphasis Emphasis, aka italics, with asterisks or underscores.\nStrong emphasis, aka bold, with asterisks or underscores.\nCombined emphasis with asterisks and underscores.\nStrikethrough uses two tildes. Scratch this.\nLink I\u0026rsquo;m an inline-style link\nI\u0026rsquo;m an inline-style link with title\nI\u0026rsquo;m a reference-style link\nI\u0026rsquo;m a relative reference to a repository file\nYou can use numbers for reference-style link definitions\nOr leave it empty and use the link text itself.\nURLs and URLs in angle brackets will automatically get turned into links. http://www.example.com or http://www.example.com and sometimes example.com (but not on Github, for example).\nSome text to show that the reference links can follow later.\nParagraph Lorem ipsum dolor sit amet consectetur adipisicing elit. Quam nihil enim maxime corporis cumque totam aliquid nam sint inventore optio modi neque laborum officiis necessitatibus, facilis placeat pariatur! Voluptatem, sed harum pariatur adipisci voluptates voluptatum cumque, porro sint minima similique magni perferendis fuga! Optio vel ipsum excepturi tempore reiciendis id quidem? Vel in, doloribus debitis nesciunt fugit sequi magnam accusantium modi neque quis, vitae velit, pariatur harum autem a! Velit impedit atque maiores animi possimus asperiores natus repellendus excepturi sint architecto eligendi non, omnis nihil. Facilis, doloremque illum. Fugit optio laborum minus debitis natus illo perspiciatis corporis voluptatum rerum laboriosam.\nList List item List item List item List item List item Unordered List List item List item List item List item List item Code and Syntax Highlighting Inline code has back-ticks around it.\nvar s = \u0026#34;JavaScript syntax highlighting\u0026#34;; alert(s); s = \u0026#34;Python syntax highlighting\u0026#34; print s No language indicated, so no syntax highlighting. But let\u0026#39;s throw in a \u0026lt;b\u0026gt;tag\u0026lt;/b\u0026gt;. Blockquote This is a blockquote example.\nInline HTML You can also use raw HTML in your Markdown, and it\u0026rsquo;ll mostly work pretty well.\nTables Colons can be used to align columns.\nTables Are Cool col 3 is right-aligned $1600 col 2 is centered $12 zebra stripes are neat $1 There must be at least 3 dashes separating each header cell. The outer pipes (|) are optional, and you don\u0026rsquo;t need to make the raw Markdown line up prettily. You can also use inline Markdown.\nMarkdown Less Pretty Still renders nicely 1 2 3 Image Youtube video ","permalink":"https://pattysung1.github.io/works/leetcode-/","tags":["leetcode"],"title":"Leetcode-"},{"categories":["Programming"],"contents":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2:\nInput: nums = [3,2,4], target = 6 Output: [1,2] Example 3:\nInput: nums = [3,3], target = 6 Output: [0,1] \u0026lt;解題\u0026gt; 從迴圈中先找第一個數，及target和此數的相減值diff 如果diff在hashMap中，就回傳這個array 如果沒有的話，就存放在hashmap中-\u0026gt;prevMap.put(num,i); 如果整個迴圈中，沒有成立這樣的組合，就回傳空的array class Solution { public int[] twoSum(int[] nums, int target) { HashMap\u0026lt;Integer, Integer\u0026gt; prevMap = new HashMap\u0026lt;\u0026gt;(); for(int i =0 ; i\u0026lt;nums.length; i++){ int num = nums[i]; int diff = target-num; if(prevMap.containsKey(diff)){ return new int[] {i,prevMap.get(diff)}; } prevMap.put(num,i); } return new int[] {}; } } \u0026lt;補充\u0026gt; 空的array new int[] {} 等於 new int [0] 都表示一個空陣列 ","permalink":"https://pattysung1.github.io/works/leetcode-1/","tags":["leetcode"],"title":"Leetcode-1. Two Sum"},{"categories":["Programming"],"contents":"Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail\u0026rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). Example 2:\nInput: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 0th node. Example 3:\nInput: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. -\u0026gt;要找出此linkedlist中是否有環\n\u0026lt;解題\u0026gt; 用快和慢兩指針，快的一次走兩步、慢的一次走一步，如果兩者最後能後相遇，代表當中有環 可以先在一開始確認(head == null)的話，就直接return false public class Solution { public boolean hasCycle(ListNode head) { if (head == null) { return false; } ListNode slow = head; ListNode fast = head.next; while (slow != fast \u0026amp;\u0026amp; fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow == fast; } } Time Complexity: O(N) Space Complexity: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-141/","tags":["leetcode"],"title":"Leetcode-141. Linked List Cycle"},{"categories":["Programming"],"contents":"You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2:\nInput: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. -\u0026gt;找出最低價（買）和最高價（賣）\n\u0026lt;解題\u0026gt; 找出最低價（買） 找出最高利潤Max(maxProfit, prices[i]-min) class Solution { public int maxProfit(int[] prices) { int n = prices.length; int min = Integer.MAX_VALUE; int maxProfit = 0; for (int i=0 ; i\u0026lt;n ;i++){ if(prices[i]\u0026lt; min) min = prices[i]; maxProfit = Math.max(maxProfit, prices[i]-min); } return maxProfit; } } Time Complexity: O(N) Space Complexity: O(1)\n\u0026lt;補充\u0026gt; Integer.MAX_VALUE //數字最大值 ","permalink":"https://pattysung1.github.io/works/leetcode-121/","tags":["leetcode"],"title":"Leetcode-121. Best Time to Buy and Sell Stock"},{"categories":["Programming"],"contents":"You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\nExample 1:\nInput: prices = [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Total profit is 4 + 3 = 7. Example 2:\nInput: prices = [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Total profit is 4. Example 3:\nInput: prices = [7,6,4,3,1] Output: 0 Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0. \u0026lt;解題\u0026gt; 如果後一天比前一天價格高，就相減計算兩者的利潤 返回profit class Solution { public int maxProfit(int[] prices) { int n = prices.length; int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit = profit + (prices[i] - prices[i - 1]); } } return profit; } } Time Complexity: O(N) Space Complexity: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-122/","tags":["leetcode"],"title":"Leetcode-122. Best Time to Buy and Sell Stock II"},{"categories":["Programming"],"contents":"Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: s = \u0026#34;anagram\u0026#34;, t = \u0026#34;nagaram\u0026#34; Output: true Example 2:\nInput: s = \u0026#34;rat\u0026#34;, t = \u0026#34;car\u0026#34; Output: false 判斷s、t字串，排序之後是否相等\n\u0026lt;解法\u0026gt; 1. 用陣列比較 import java.util.Arrays; class Solution { public boolean isAnagram(String s, String t) { char[] sArr = s.toCharArray(); char[] tArr = t.toCharArray(); Arrays.sort(sArr); Arrays.sort(tArr); return Arrays.equals(sArr,tArr); } } 2. 使用一個長度為 26 的陣列來統計字母出現的次數（改善空間複雜度） class Solution { public boolean isAnagram(String s, String t) { if (s.length() != t.length()) { return false; } int[] count = new int[26]; // 使用一個長度為 26 的陣列來統計字母出現的次數 // 將 s 字串中的字母計數加 1 for (char c : s.toCharArray()) { count[c - \u0026#39;a\u0026#39;]++; } // 將 t 字串中的字母計數減 1 for (char c : t.toCharArray()) { count[c - \u0026#39;a\u0026#39;]--; } // 檢查每個字母計數是否為 0，如果有非 0 的計數則表示兩個字串不是異位詞 for (int i = 0; i \u0026lt; 26; i++) { if (count[i] != 0) { return false; } } return true; } } \u0026lt;補充\u0026gt;.toCharArray() 把字串轉成字元 public class Main { public static void main(String args[]) { String Str = new String(\u0026#34;Hello word\u0026#34;); System.out.print(\u0026#34;返回值 :\u0026#34; ); System.out.println( Str.toCharArray() ); } } ","permalink":"https://pattysung1.github.io/works/leetcode-242/","tags":["leetcode"],"title":"Leetcode-242. Valid Anagram"},{"categories":["Programming"],"contents":"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k.\n給定一個排序數組，你需要在原地刪除重複出現的元素，使得每個元素只出現一次，返回移除後數組的新長度。\n不要使用額外的數組空間，你必須在原地修改輸入數組並使用O（1）額外空間的條件下完成。\nExample 1:\nInput: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). \u0026lt;解題\u0026gt; 條件檢查：程式碼確保nums不為空\u0026amp;\u0026amp;長度不為0 設定初始值=1和不重複元素值為目前第一個元素 將非重複元素放入答案的位置，指標繼續往後動 class Solution { public int removeDuplicates(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int answer = 1; // 初始化答案為1，因為第一個元素肯定是不重複的 int prev = nums[0]; // 用來記錄前一個非重複元素的值 for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] != prev) { nums[answer] = nums[i]; // 將非重複元素放入答案的位置 prev = nums[i]; // 更新prev的值為目前的元素 answer++; // 答案位置往後移動 } } return answer; } } ","permalink":"https://pattysung1.github.io/works/leetcode-26/","tags":["leetcode"],"title":"Leetcode-26. Remove Duplicates from Sorted Array"},{"categories":["Programming"],"contents":"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [\u0026hellip;]; // Input array int val = \u0026hellip;; // Value to remove int[] expectedNums = [\u0026hellip;]; // The expected answer with correct length. // It is sorted with no values equaling val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i \u0026lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1: Input: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores).\n-\u0026gt;對於返回的結果中的五個元素，它們的順序並不重要，可以以任意順序返回這五個元素，並且不需要對返回的 k 之後的元素做任何處理（可以用底線表示）\n\u0026lt;解題\u0026gt; 給一個數組nums和一個值val，需要移除所有數值等於val的元素，返回移除後數組的新長度。 建一個迴圈，開始跑每個數值，當數值和val不同，就存在本來的數列（數值相同的不存入） class Solution { public int removeElement(int[] nums, int val) { int returnValue = 0; if (nums != null \u0026amp;\u0026amp; nums.length \u0026gt; 0) { for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != val) { nums[returnValue] = nums[i]; returnValue++; } } } return returnValue; } } ","permalink":"https://pattysung1.github.io/works/leetcode-27/","tags":["leetcode"],"title":"Leetcode-27. Remove Element"},{"categories":["Programming"],"contents":"Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1: Input: haystack = \u0026#34;sadbutsad\u0026#34;, needle = \u0026#34;sad\u0026#34; Output: 0 Explanation: \u0026#34;sad\u0026#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2: Input: haystack = \u0026#34;leetcode\u0026#34;, needle = \u0026#34;leeto\u0026#34; Output: -1 Explanation: \u0026#34;leeto\u0026#34; did not occur in \u0026#34;leetcode\u0026#34;, so we return -1. \u0026lt;解題\u0026gt; haystack的長度比needle的長度長，故if(haystack.length\u0026lt;needle.length)-\u0026gt;return -1 兩者相等-\u0026gt;return 0 迴圈：從haystack中跑到每個字母的substring和needle一樣，return i 1.直接使用substring public int strStr(String haystack, String needle) { int l1=haystack.length(); int l2=needle.length(); if(l1\u0026lt;l2) { return -1; } else if(l2==0) { return 0; } for(int i=0;i\u0026lt;=l1-l2;i++) { if(haystack.substring(i,i+l2).equals(needle)) { return i; } } return -1; } 2.如果不能使用substring class Solution { public int strStr(String haystack, String needle) { int l1 = haystack.length(); int l2 = needle.length(); if (l1 \u0026lt; l2) { return -1; } else if (l2 == 0) { return 0; } else { for (int i = 0; i \u0026lt;= l1 - l2; i++) { boolean found = true; //先預設為true for (int j = 0; j \u0026lt; l2; j++) { //找接下來字母有無相同 if (haystack.charAt(i+j) != needle.charAt(j)){ found =false; break; } } if (found){ return i; } } } return -1; } } ","permalink":"https://pattysung1.github.io/works/leetcode-28/","tags":["leetcode"],"title":"Leetcode-28. Find the Index of the First Occurrence in a String"},{"categories":["Programming"],"contents":"Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: strs = [\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;,\u0026#34;tan\u0026#34;,\u0026#34;ate\u0026#34;,\u0026#34;nat\u0026#34;,\u0026#34;bat\u0026#34;] Output: [[\u0026#34;bat\u0026#34;],[\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;],[\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;]] Example 2:\nInput: strs = [\u0026#34;\u0026#34;] Output: [[\u0026#34;\u0026#34;]] Example 3:\nInput: strs = [\u0026#34;a\u0026#34;] Output: [[\u0026#34;a\u0026#34;]] 給一字符串數組，將錯位詞(相同字符不同排列的字符串)分組\n\u0026lt;解題\u0026gt; 用HashMap去建Map\u0026lt;String, ArrayList\u0026gt;，用排序後的字串為key 先把String 轉成 Char以排序 -\u0026gt;.toCharArray() 排序以作為key 再轉回String -\u0026gt; String.valueOf(str) class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { Map\u0026lt;String, ArrayList\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String s: strs){ char[] key_str = s.toCharArray(); //string 轉成char Arrays.sort(key_str); String key = String.valueOf(key_str);//轉回string if(map.containsKey(key)){//判斷此key是否在map map.get(key).add(s); //有的話將s加入該key的value中 } else{ map.put(key, new ArrayList\u0026lt;\u0026gt;());//沒有的話將key加入map，並在value建立一個類別 map.get(key).add(s); } } return new ArrayList\u0026lt;\u0026gt;(map.values()); //最後把map.values()的值，在新的ArrayList中回傳 } } ","permalink":"https://pattysung1.github.io/works/leetcode-49/","tags":["leetcode"],"title":"Leetcode-49. Group Anagrams"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; ","permalink":"https://pattysung1.github.io/works/leetcode-55/","tags":["leetcode"],"title":"Leetcode-55. Jump Game"},{"categories":["Programming"],"contents":"You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. 給定兩個有序整數數組 nums1和nums2，將nums2合併到 nums1 中，使得 num1成為一個有序數組。\n\u0026lt;解題\u0026gt; 把nums1和nums2的最後一個不含0字元設指標，接著比大小，比較大的從nums1的最後一位開始放，放完之後指標往前移 p2\u0026lt;0，代表 nums2 數組中的元素已經全部合併到 nums1，所以把num1剩下的元素處理完 p1\u0026gt;= 0，要確認num1的元素都有處理到 class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { if (null != nums1 \u0026amp;\u0026amp; null != nums2 \u0026amp;\u0026amp; nums1.length == m + n) { int p1 = m - 1 int p2 = n - 1; for (int i = m + n - 1; i \u0026gt;= 0; i--) { if (p2 \u0026lt; 0 ||(p1 \u0026gt;= 0 \u0026amp;\u0026amp; nums1[p1] \u0026gt; nums2[p2])) { nums1[i] = nums1[p1]; p1--; } else { nums1[i] = nums2[p2]; p2--; } } } } } ","permalink":"https://pattysung1.github.io/works/leetcode-88/","tags":["leetcode"],"title":"Leetcode-88. Merge Sorted Array"},{"categories":["Programming"],"contents":"以下是幾種方法可以將字元轉換為 ASCII 值： 1. 使用 (int) 類型轉換： char c = \u0026#39;a\u0026#39;; int asciiValue = (int) c; System.out.println(asciiValue); // 輸出: 97 2. 使用 Character.getNumericValue 方法： char c = \u0026#39;A\u0026#39;; int asciiValue = Character.getNumericValue(c); System.out.println(asciiValue); // 輸出: 10 3. 使用數學運算，減去對應的 ASCII 值： Copy code char c = \u0026#39;0\u0026#39;; int asciiValue = c - \u0026#39;0\u0026#39;; System.out.println(asciiValue); // 輸出: 0 ","permalink":"https://pattysung1.github.io/works/leetcode-ascii/","tags":["ASCII"],"title":"將字元轉換成ASCII值"},{"categories":["Programming"],"contents":"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer.\nExample 1: Input: s = \u0026#34;III\u0026#34; Output: 3 Explanation: III = 3. Example 2: Input: s = \u0026#34;LVIII\u0026#34; Output: 58 Explanation: L = 50, V= 5, III = 3. Example 3: Input: s = \u0026#34;MCMXCIV\u0026#34; Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. \u0026lt;解題\u0026gt; 先定義每一個字元對應的Value -\u0026gt; HashMap 值大的字母擺在越前面，故從前面往後找，當下一位字母的值比前位大時，要用減法 減法計算：記得減去前一位的2倍（因為本來被加過一次了，所以要扣回） 1. 對應字元-\u0026gt;直接用字元比較好 class Solution { public int romanToInt(String s) { int result = 0; if(s != \u0026#34;\u0026#34;){ HashMap\u0026lt;Character,Integer\u0026gt; map = new HashMap\u0026lt;Character,Integer\u0026gt;(); map.put(\u0026#39;I\u0026#39;, 1); map.put(\u0026#39;V\u0026#39;, 5); map.put(\u0026#39;X\u0026#39;, 10); map.put(\u0026#39;L\u0026#39;, 50); map.put(\u0026#39;C\u0026#39;, 100); map.put(\u0026#39;D\u0026#39;, 500); map.put(\u0026#39;M\u0026#39;, 1000); for(int i = 0 ; i\u0026lt;s.length() ; i++){ Character temp = s.charAt(i); int value = 0; if(map.containsKey(temp)){ value = map.get(temp); //字元的值 if(i != 0 \u0026amp;\u0026amp; (map.get(s.charAt(i-1)) \u0026lt; value) ){ value = value - (map.get(s.charAt(i-1))*2); //減去前面數本身*2 } result = result + value; } } } return result; } } 2. 對應字串，但之後記得要轉換 class Solution { public int romanToInt(String s) { int result = 0; if(s != \u0026#34;\u0026#34;){ HashMap\u0026lt;String,Integer\u0026gt; map = new HashMap\u0026lt;String,Integer\u0026gt;(); map.put(\u0026#34;I\u0026#34;, 1); map.put(\u0026#34;V\u0026#34;, 5); map.put(\u0026#34;X\u0026#34;, 10); map.put(\u0026#34;L\u0026#34;, 50); map.put(\u0026#34;C\u0026#34;, 100); map.put(\u0026#34;D\u0026#34;, 500); map.put(\u0026#34;M\u0026#34;, 1000); for(int i = 0 ; i\u0026lt;s.length() ; i++){ String temp = s.charAt(i)+\u0026#34;\u0026#34;; //把字元轉成字串 // String temp = Character.toString(s.charAt(i)); //把字元轉成字串 int value = 0; if(map.containsKey(temp)){ value = map.get(temp); if(i != 0 \u0026amp;\u0026amp; (map.get(s.charAt(i-1)+\u0026#34;\u0026#34;) \u0026lt; value) ){ value = value - (map.get(s.charAt(i-1)+\u0026#34;\u0026#34;))*2; } result = result + value; } } } return result; } } \u0026lt;補充\u0026gt;字元轉字串 1. String temp = s.charAt(i)+\u0026#34;\u0026#34;; //把字元轉成字串 2. String temp = Character.toString(s.charAt(i)); //把字元轉成字串 3. Integer.valueOf() 方法用於將字串轉換為整數，而不是將單個\u0026#34;字元\u0026#34;轉換為整數。 \u0026lt;補充\u0026gt;HashMap containsKey() 方法 import java.util.HashMap; class Main { public static void main(String[] args) { HashMap\u0026lt;Integer, String\u0026gt; sites = new HashMap\u0026lt;\u0026gt;(); sites.put(1, \u0026#34;Google\u0026#34;); sites.put(2, \u0026#34;Yahoo\u0026#34;); sites.put(3, \u0026#34;Apple\u0026#34;); System.out.println(\u0026#34;sites HashMap: \u0026#34; + sites); //檢查是否存在 if(sites.containsKey(1)) { System.out.printf(\u0026#34;key %d 存在於 sites 中%n\u0026#34;, 1); //若要使用格式化字符 System.out.println(\u0026#34;key \u0026#34; + 1 + \u0026#34; 存在於 sites 中\u0026#34;); } //若不存在，則新增 if (!sites.containsKey(4)){ sites.put(4, \u0026#34;Tesla\u0026#34;); } System.out.println(\u0026#34;New sites HashMap:\u0026#34; + sites); } } \u0026lt;補充\u0026gt;格式化字符 //檢查是否存在 if(sites.containsKey(1)) { System.out.printf(\u0026#34;key %d 存在於 sites 中%n\u0026#34;, 1); //若要使用格式化字符 System.out.println(\u0026#34;key \u0026#34; + 1 + \u0026#34; 存在於 sites 中\u0026#34;); } ","permalink":"https://pattysung1.github.io/works/leetcode-13/","tags":["leetcode"],"title":"Leetcode-13. Roman to Integer"},{"categories":["Programming"],"contents":"Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.\nExample 1:\nInput: s = \u0026ldquo;Hello World\u0026rdquo; Output: 5 Explanation: The last word is \u0026ldquo;World\u0026rdquo; with length 5.\n\u0026lt;解題1\u0026gt; 想用空格分離後，在找出最後一個單字的長度\nclass Solution { public int lengthOfLastWord(String s) { if( s!= null \u0026amp; s.length()\u0026gt;0){ String[] temp = s.split(\u0026#34; \u0026#34;); if (temp != null \u0026amp;\u0026amp; temp.length\u0026gt;0){ String last = temp[temp.length-1]; return last.length(); } } return 0; } } \u0026lt;解題2\u0026gt; 從最後一個字元開始算，加總字元個數，如果遇到空白就結束，代表已經數完最後一個單字\npublic static int lengthOfLastWord2(String s) { int len = 0; //計算最後一個單字的長度 int tail = s.length() - 1; //整個字串的長度 while (tail \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(tail) == \u0026#39; \u0026#39;) { tail--; //減去後面的空白 } //從後面往前算到該字元為空白為止 while (tail \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(tail) != \u0026#39; \u0026#39;) { len++; tail--; } return len; } 1. s.length() 是字串 s 的方法 length() 的調用，用於獲取字串的長度。它會返回一個整數值，表示字串的長度，所以在調用時需要使用括號。 2. temp.length 是陣列 temp 的屬性 length，用於獲取陣列的長度。在Java中，陣列的長度屬性是一個公開的屬性，不需要使用括號。 \u0026lt;補充-字串符分割\u0026gt;\npublic static void main(String args[]){ String str = \u0026#34;www-hello_world-com\u0026#34;; String[] temp; String delimeter = \u0026#34;-\u0026#34;; // 指定分割字符 temp = str.split(delimeter); // 分割字符串 for(int i =0; i \u0026lt; temp.length ; i++){ System.out.println(temp[i]); System.out.println(\u0026#34;\u0026#34;); } String str1 = \u0026#34;www.hello.world.com\u0026#34;; String[] temp1; String delimeter1 = \u0026#34;\\\\.\u0026#34;; // 指定分割字符(\\\\.) temp1 = str1.split(delimeter1); // 分割字符串 for(String x : temp1){ System.out.println(x); System.out.println(\u0026#34;\u0026#34;); } } \u0026lt;補充-chatAt()\u0026gt;\npublic class Main { public static void main(String args[]) { String s = \u0026#34;www.helloworld.com\u0026#34;; char find = s.charAt(9); System.out.println(find); } } -\u0026gt;w\n*排版快捷鍵： option + command + L\n","permalink":"https://pattysung1.github.io/works/leetcode-58/","tags":["leetcode"],"title":"Leetcode-58. Length of Last Word"},{"categories":["Programming"],"contents":"之前在寫Android Studio的時候，會使用\nLog.d(\u0026#34;Patty\u0026#34;, \u0026#34;xx功能\u0026#34;) 來追蹤程式的執行流程，看有沒有印出的值是否正確或有異常，最近在寫Java Spring Boot，這邊的Log功能，需要先於class中撰寫logger，才可以使用：\nimport org.slf4j.Logger; import org.slf4j.LoggerFactory; public class LoggingExample { private static final Logger logger = Logger.getLogger(LoggingExample.class.getName()); public static void main(String[] args) { logger.info(\u0026#34;This is an informational message.\u0026#34;); logger.warning(\u0026#34;This is a warning message.\u0026#34;); logger.severe(\u0026#34;This is a severe message.\u0026#34;); } } 另外，可以將參數帶入印出：\npublic class MyService { private static final Logger logger = LoggerFactory.getLogger(MyService.class); public void doSomething(String parameter) { logger.info(\u0026#34;Received parameter: {}\u0026#34;, parameter); logger.debug(\u0026#34;Debug message with parameter: \u0026#34; + parameter); } } ","permalink":"https://pattysung1.github.io/works/log/","tags":["Photos","New"],"title":"Log紀錄"},{"categories":["Programming"],"contents":"目前在幫ShinyBear品牌做電商網站，在前後端的傳遞資訊時，時常使用到Json，而使用ObjectMapper，可以將Json字串及Java Object互相作轉換。\n但注意，要記得在pom.xql中加上spring-boot-starter-web\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 說明 ObjectMapper是一個Java庫，用於處理Java對象和JSON之間的相互轉換。它提供了一種簡單而靈活的方法，可將Java對象序列化為JSON格式的字符串，並將JSON字符串反序列化為Java對象。使用ObjectMapper能夠在處理JSON數據時變得更加便捷。\n以下是ObjectMapper的一些常見用法(1.2較常用)： 將Java對象轉換為JSON字符串：(writeValueAsString()) ObjectMapper objectMapper = new ObjectMapper(); YourObject obj = new YourObject(); String jsonString = objectMapper.writeValueAsString(obj); 2.將JSON字符串轉換為Java對象：(readValue())\nObjectMapper objectMapper = new ObjectMapper(); String jsonString = \u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;John\\\u0026#34;,\\\u0026#34;age\\\u0026#34;:30}\u0026#34;; YourObject obj = objectMapper.readValue(jsonString, YourObject.class); 3.格式化JSON輸出：\nObjectMapper objectMapper = new ObjectMapper(); YourObject obj = new YourObject(); String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); 可以使用ObjectMapper生成格式化的JSON字符串，以提高可讀性。\n4.處理特殊情況：\nObjectMapper objectMapper = new ObjectMapper(); objectMapper.setDateFormat(new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;)); YourObject obj = new YourObject(); String jsonString = objectMapper.writeValueAsString(obj); ObjectMapper提供了處理日期格式、處理集合類型、自定義序列化和反序列化等特殊情況的功能。 可以依照要規劃的功能做使用，不過主要還是前兩者使用的多。\n@Jsonproperty: 註解使得Json的key和Java變數可以做轉換 public class Person { @JsonProperty(\u0026#34;first_name\u0026#34;) private String firstName; @JsonProperty(\u0026#34;last_name\u0026#34;) private String lastName; @JsonProperty(\u0026#34;age\u0026#34;) private int age; // getters and setters... } ","permalink":"https://pattysung1.github.io/works/objectmapper/","tags":["Java","ObjectMapper"],"title":"ObjectMapper- Java Object和JSON之間的相互轉換"},{"categories":["Japan日本"],"contents":"自從畢業以及疫情後，已經3年多沒有出國了。看著IG上，朋友們一個個的出國旅遊，心裡好羨慕啊。終於這次趁出國唸書之前，和家人也一起出國囉！\n記得上次去日本大約是快十年前，剛要升高中的時候去的大阪\u0026hellip; 時間真的過得飛快。\n由於看到環球影城有新的瑪利歐世界，因為很喜歡瑪利歐相關的遊戲（瑪利歐、瑪利歐派對、瑪利歐賽車等等）， 於是當然想看看實際去到瑪利歐世界會是怎麼樣子囉！\n▲Mario Parade\n▲Lovely Minion\n如果有興趣看到更多的旅遊照片，可以到Pooh.travel.blog笑咪咪Pooh的旅遊日記觀看！\nps 我最喜歡的角色是耀西和害羞幽靈\n5/14-5/22的行程 由於不想再回到原點，所以搭飛機由大阪進、名古屋出。 因此，我們選擇了5/14桃園機場至大阪的長榮航空， 以及5/22早上從名古屋回桃園機場的華航。 先放上一張總覽圖： 由於主要大阪部分的其他景點以前都去過了，所以只有安排環球影城(主要想去馬力歐樂園)和購物，建議如果第一次來大阪，其實是可以停留4-5天漫遊。\n現在日幣貶值，加上信用卡回饋，買Uniqlo真的就跟台灣價格打75折差不多！ DHC藍莓精華和合力他命的價差也很大，DHC藍莓精華在台灣買大概500-600不等，在那邊的藥妝店比價，平均大概300台幣左右，如果平常會常吃這些保健食品的話，真的很推薦在日本大買特買。\n- 關於交通 這趟旅行的交通部分，主要先訂好票的有關西機場至大阪市區的特快車、大阪至名古屋的JR車票、大阪地鐵巴士一日乘車券。\n另外，有在名古屋車地鐵站，購買一日的地鐵票。\n1.關西機場至大阪市區 由於到大阪已經5點多，出關的時候人滿多的，所以當天晚上就直接到環球影城飯店入住，等待隔天早上直接開始玩。 從大阪關西機場至大阪車站，我們是直接至Klook買。\n訂票方式 關西樂享周遊券（3項設施）+ 關空特快 HARUKA 車票（關西機場→新大阪／天王寺站），除了有從關西機場至市區（可選擇至天王寺、大阪或新大阪車站）外，亦有關西樂享周遊券（3項設施）券可以使用（不過這部分後來因為時間的關係，所以我們也沒有使用到）\nps.購買此票券的時候，klook會有說明如何取票，如果是在關西機場的話，出來之後左轉直直走，接著上二樓到另一棟樓的搭車處的取票機取票，在刷卡進入站前，可以看到班次表。\n2.大阪至名古屋 大阪至名古屋的交通，我們選擇搭乘JR：新大阪到名古屋車站，車程大約50分鐘，售價折合台幣約1500多(匯率1:4左右)。\n訂票方式 官網訂票： 雖然不是中文的，但是按照上面的步驟和翻譯，一步一步的點擊購買，另外，可以選擇適合放置大行李的位子，一個月前就開放可以訂票了。 Klook訂票： Klook真的非常方便，涵蓋旅遊行程、住宿、交通、租車，都可以預訂。當然，JR車票也可以在上面預定囉～！不過，雖然方便，但每張票都要收額外的台幣300元手續費，看到的當下，立馬關掉去訂官網。 3.大阪地鐵票 大阪有one-day和two-day地鐵巴士乘車券，這部分也可以在klook上先訂票。\n訂票方式 大阪地鐵巴士乘車券(1日/2日)\n4.名古屋地鐵票 名古屋地鐵票，是在地鐵站內至詢問處購買的，同時也拿了一張捷運路線圖（也可以拍下來用手機看） ▲One day pass in Nagoya\n▲subway in Nagoya\n▲每週六日及每月8號，購買使用一日乘車券是比較便宜的：大人620日圓、小孩310日圓；剛好我們購買使用那天是星期六XD\n5.名古屋巴士站-愛·地球博紀念公園車站（吉卜力公園) 從名古屋-吉卜力公園，除了搭地鐵外，也可以搭乘巴士，地鐵的價格比巴士便宜一些，但搭乘巴士的話，車程大概35分鐘左右就到了。\n搭乘巴士的位置在名鐵巴士中心的四樓24號，可以上車之後再買付款（一人1000日圓）\n回程在愛·地球博紀念公園車站的3號車牌，就可以搭乘回名鐵巴士中心了。 ▲班次表\n▲地圖相對位置\n","permalink":"https://pattysung1.github.io/travel/post-1/","tags":["Travel","Pooh","大阪","名古屋","JR","吉卜力公園","日本環遊影城"],"title":"2023/5 【大阪-名古屋-黑部立山-吉卜力公園】-交通篇"},{"categories":["Japan日本"],"contents":"關於訂票 吉卜力公園門票 2022年11月1日才開幕的吉卜力公園，目前只開放開個部分：大倉庫、青春之丘、DONDOKO之森。本來想使用官網訂票，但發現好像需要有日本的手機號碼還是相關的認證（有點忘記是什麼），所以後來是在蝦皮代購（可以至上面搜尋吉卜力公園），請人幫忙買票券。價格和官網上的沒有差到很多。但因為只有提前一個多月購買，所以只有買到大倉庫門票。\n官方網站 1.吉卜力大倉庫 2.青春之丘和吉卜力大倉庫門票 3.DONDOKO之森 - 關於黑部立山三日遊 由於四月初準備預定行程時，手邊比較多忙的事情，所以是選擇KKday三天兩夜的白川鄉/高山陣屋、黑部立山、上高地/河童橋遊，包含當中的吃飯及住宿。雖然跟著遊覽車很方便，不過由於習歡自助，所以還是不太習慣跟團\u0026hellip;.，到每個景點都在趕趕趕和集合，後來發現其實去黑部立山的交通，也可以規劃坐巴士等等，而且費用也便宜很多很多，也不用一直在坐遊覽車以及一直等集合。\n購票平台：KKday Photos 合掌村，5/17到訪天氣超熱 維尼們與mini合掌村 黑部立山上山口 維尼們與雪山 變成冰中雪人 雪的大谷 維尼與雪人 維尼與同團的夥伴 旅遊團採草莓行程，日本的草莓真的很好吃！ 河童橋 ","permalink":"https://pattysung1.github.io/travel/post-2/","tags":["Travel","Pooh","大阪","名古屋","黑部立山","吉卜力公園"],"title":"2023/5 【大阪-名古屋-黑部立山-吉卜力公園】-訂票篇"}]