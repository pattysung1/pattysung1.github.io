[{"categories":["Programming"],"contents":"The next greater element of some element x in an array is the first greater element that is to the right of x in the same array.\nYou are given two distinct 0-indexed integer arrays nums1 and nums2, where nums1 is a subset of nums2.\nFor each 0 \u0026lt;= i \u0026lt; nums1.length, find the index j such that nums1[i] == nums2[j] and determine the next greater element of nums2[j] in nums2. If there is no next greater element, then the answer for this query is -1.\nReturn an array ans of length nums1.length such that ans[i] is the next greater element as described above.\nExample 1:\nInput: nums1 = [4,1,2], nums2 = [1,3,4,2] Output: [-1,3,-1] Explanation: The next greater element for each value of nums1 is as follows:\n4 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. 1 is underlined in nums2 = [1,3,4,2]. The next greater element is 3. 2 is underlined in nums2 = [1,3,4,2]. There is no next greater element, so the answer is -1. Example 2: Input: nums1 = [2,4], nums2 = [1,2,3,4] Output: [3,-1] Explanation: The next greater element for each value of nums1 is as follows:\n2 is underlined in nums2 = [1,2,3,4]. The next greater element is 3. 4 is underlined in nums2 = [1,2,3,4]. There is no next greater element, so the answer is -1. \u0026lt;解題\u0026gt; class Solution { public int[] nextGreaterElement(int[] nums1, int[] nums2) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for(int num : nums2){ while(!stack.isEmpty() \u0026amp;\u0026amp; stack.peek() \u0026lt; num){ map.put(stack.pop(), num); } stack.push(num); } for(int i =0; i\u0026lt;nums1.length; i++){ nums1[i] = map.getOrDefault(nums1[i], -1); } return nums1; } } Time: O(n+m) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-496/","tags":["leetcode","stack"],"title":"Leetcode-496. Next Greater Element I"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; class Solution { public int[] dailyTemperatures(int[] temperatures) { Deque\u0026lt;Integer\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); // 創建一個整數陣列用來存儲每一天需要等待的天數 int[] res = new int[temperatures.length]; // 遍歷溫度陣列 for (int i = 0; i \u0026lt; temperatures.length; i++) { // 使用 while 迴圈處理堆疊中的元素，直到堆疊為空或當前溫度不再大於堆疊頂部元素對應的溫度 while (!stack.isEmpty() \u0026amp;\u0026amp; temperatures[stack.peek()] \u0026lt; temperatures[i]) { // 從堆疊中彈出頂部元素的索引，記為 idx int idx = stack.pop(); // 計算當前索引 i 減去 idx，這代表需要等待的天數，將結果存儲在 res 陣列的 idx 位置 res[idx] = i - idx; } // 將當前索引 i 壓入堆疊，以便之後比較 stack.push(i); } // 返回存儲了每一天需要等待的天數的 res 陣列 return res; } } ","permalink":"https://pattysung1.github.io/works/leetcode-739/","tags":["leetcode","stack"],"title":"Leetcode-739. Daily Temperatures"},{"categories":["Programming"],"contents":"You are given an array of strings tokens that represents an arithmetic expression in a Reverse Polish Notation.\nEvaluate the expression. Return an integer that represents the value of the expression.\nNote that:\nThe valid operators are \u0026lsquo;+\u0026rsquo;, \u0026lsquo;-\u0026rsquo;, \u0026lsquo;*\u0026rsquo;, and \u0026lsquo;/\u0026rsquo;. Each operand may be an integer or another expression. The division between two integers always truncates toward zero. There will not be any division by zero. The input represents a valid arithmetic expression in a reverse polish notation. The answer and all the intermediate calculations can be represented in a 32-bit integer.\nExample 1:\nInput: tokens = [\u0026ldquo;2\u0026rdquo;,\u0026ldquo;1\u0026rdquo;,\u0026quot;+\u0026quot;,\u0026ldquo;3\u0026rdquo;,\u0026quot;*\u0026quot;] Output: 9 Explanation: ((2 + 1) * 3) = 9 Example 2:\nInput: tokens = [\u0026ldquo;4\u0026rdquo;,\u0026ldquo;13\u0026rdquo;,\u0026ldquo;5\u0026rdquo;,\u0026quot;/\u0026quot;,\u0026quot;+\u0026quot;] Output: 6 Explanation: (4 + (13 / 5)) = 6 Example 3:\nInput: tokens = [\u0026ldquo;10\u0026rdquo;,\u0026ldquo;6\u0026rdquo;,\u0026ldquo;9\u0026rdquo;,\u0026ldquo;3\u0026rdquo;,\u0026quot;+\u0026quot;,\u0026quot;-11\u0026quot;,\u0026quot;\u0026quot;,\u0026quot;/\u0026quot;,\u0026quot;\u0026quot;,\u0026ldquo;17\u0026rdquo;,\u0026quot;+\u0026quot;,\u0026ldquo;5\u0026rdquo;,\u0026quot;+\u0026quot;] Output: 22 Explanation: ((10 * (6 / ((9 + 3) * -11))) + 17) + 5 = ((10 * (6 / (12 * -11))) + 17) + 5 = ((10 * (6 / -132)) + 17) + 5 = ((10 * 0) + 17) + 5 = (0 + 17) + 5 = 17 + 5 = 22\n\u0026lt;解題\u0026gt; class Solution { public int evalRPN(String[] tokens) { Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (String s : tokens){ if(s.equals(\u0026#34;+\u0026#34;)){ stack.push(stack.pop() + stack.pop()); } else if(s.equals(\u0026#34;-\u0026#34;)){ int b = stack.pop(); int a = stack.pop(); stack.push(a-b); } else if(s.equals(\u0026#34;*\u0026#34;)){ stack.push(stack.pop() * stack.pop()); } else if(s.equals(\u0026#34;/\u0026#34;)){ int b = stack.pop(); int a = stack.pop(); stack.push(a/b); } else{ stack.push(Integer.parseInt(s)); } } return stack.pop(); } } ","permalink":"https://pattysung1.github.io/works/leetcode-150/","tags":["leetcode"],"title":"Leetcode-150. Evaluate Reverse Polish Notation"},{"categories":["Programming"],"contents":"Design a max stack data structure that supports the stack operations and supports finding the stack\u0026rsquo;s maximum element.\nImplement the MaxStack class:\nMaxStack() Initializes the stack object. void push(int x) Pushes element x onto the stack. int pop() Removes the element on top of the stack and returns it. int top() Gets the element on the top of the stack without removing it. int peekMax() Retrieves the maximum element in the stack without removing it. int popMax() Retrieves the maximum element in the stack and removes it. If there is more than one maximum element, only remove the top-most one. You must come up with a solution that supports O(1) for each top call and O(logn) for each other call.\nExample 1:\nInput [\u0026ldquo;MaxStack\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;push\u0026rdquo;, \u0026ldquo;top\u0026rdquo;, \u0026ldquo;popMax\u0026rdquo;, \u0026ldquo;top\u0026rdquo;, \u0026ldquo;peekMax\u0026rdquo;, \u0026ldquo;pop\u0026rdquo;, \u0026ldquo;top\u0026rdquo;] [[], [5], [1], [5], [], [], [], [], [], []] Output [null, null, null, null, 5, 5, 1, 5, 1, 5]\nExplanation MaxStack stk = new MaxStack(); stk.push(5); // [5] the top of the stack and the maximum number is 5. stk.push(1); // [5, 1] the top of the stack is 1, but the maximum is 5. stk.push(5); // [5, 1, 5] the top of the stack is 5, which is also the maximum, because it is the top most one. stk.top(); // return 5, [5, 1, 5] the stack did not change. stk.popMax(); // return 5, [5, 1] the stack is changed now, and the top is different from the max. stk.top(); // return 1, [5, 1] the stack did not change. stk.peekMax(); // return 5, [5, 1] the stack did not change. stk.pop(); // return 1, [5] the top of the stack and the max element is now 5. stk.top(); // return 5, [5] the stack did not change.\n\u0026lt;解題\u0026gt; class MaxStack { Stack\u0026lt;Integer\u0026gt; stack; Stack\u0026lt;Integer\u0026gt; maxStack; public MaxStack() { stack = new Stack\u0026lt;\u0026gt;(); maxStack = new Stack\u0026lt;\u0026gt;(); } public void push(int x) { int max = maxStack.isEmpty() ? x : maxStack.peek(); maxStack.push(max \u0026gt; x ? max : x); stack.push(x); } public int pop() { maxStack.pop(); return stack.pop(); } public int top() { return stack.peek(); } public int peekMax() { return maxStack.peek(); } public int popMax() { int max = peekMax(); Stack\u0026lt;Integer\u0026gt; buffer = new Stack\u0026lt;\u0026gt;(); while(top() != max){ buffer.push(pop()); } pop(); while(!buffer.isEmpty()){ push(buffer.pop()); } return max; } } Time: O(nm) Space: O(nm)\n","permalink":"https://pattysung1.github.io/works/leetcode-716/","tags":["leetcode","string"],"title":"Leetcode-716. Max Stack"},{"categories":["Programming"],"contents":"You are given the head of a singly linked-list. The list can be represented as:\nL0 → L1 → … → Ln - 1 → Ln Reorder the list to be on the following form:\nL0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → … You may not modify the values in the list\u0026rsquo;s nodes. Only nodes themselves may be changed.\nExample 1:\nInput: head = [1,2,3,4] Output: [1,4,2,3] Example 2:\nInput: head = [1,2,3,4,5] Output: [1,5,2,4,3]\n\u0026lt;解題\u0026gt; class Solution { public void reorderList(ListNode head) { if(head == null || head.next == null ) return ; ListNode slow = head; ListNode fast = head; ListNode temp = null; while(fast!= null \u0026amp;\u0026amp; fast.next != null){ temp = slow; slow = slow.next; fast = fast.next.next; } temp.next = null; ListNode l2 = reverse(slow); merge(head, l2); } private ListNode reverse(ListNode head){ ListNode prev = null; while(head != null){ ListNode next = head.next; head.next = prev; prev = head; head = next; } return prev; } private void merge(ListNode l1, ListNode l2){ while(true){ ListNode n1 = l1.next; ListNode n2 = l2.next; l1.next = l2; if(n1 == null) return; l2.next = n1; l1 = n1; l2 = n2; } } } Time Complexity: Space Complexity:\n","permalink":"https://pattysung1.github.io/works/leetcode-143/","tags":["leetcode","linked List"],"title":"Leetcode-143. Reorder List"},{"categories":["Programming"],"contents":"Given an integer array nums of unique elements, return all possible subsets (the power set).\nThe solution set must not contain duplicate subsets. Return the solution in any order.\nExample 1:\nInput: nums = [1,2,3] Output: [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]] Example 2:\nInput: nums = [0] Output: [[],[0]]\n\u0026lt;解題\u0026gt; 方式一 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsets(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res=new ArrayList\u0026lt;\u0026gt;(); helper(res, nums, 0, new ArrayList\u0026lt;\u0026gt;()); return res; } private void helper(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt;res, int[] nums, int index, List\u0026lt;Integer\u0026gt; temp){ res.add(new ArrayList\u0026lt;Integer\u0026gt; (temp)); for(int i=index;i\u0026lt;nums.length;i++){ temp.add(nums[i]); helper(res, nums, i+1, temp); temp.remove(temp.size()-1); } } } ","permalink":"https://pattysung1.github.io/works/leetcode-78/","tags":["leetcode","recurion"],"title":"Leetcode-78. Subsets"},{"categories":["Programming"],"contents":"Find all valid combinations of k numbers that sum up to n such that the following conditions are true:\nOnly numbers 1 through 9 are used. Each number is used at most once. Return a list of all possible valid combinations. The list must not contain the same combination twice, and the combinations may be returned in any order.\nExample 1:\nInput: k = 3, n = 7 Output: [[1,2,4]] Explanation: 1 + 2 + 4 = 7 There are no other valid combinations. Example 2:\nInput: k = 3, n = 9 Output: [[1,2,6],[1,3,5],[2,3,4]] Explanation: 1 + 2 + 6 = 9 1 + 3 + 5 = 9 2 + 3 + 4 = 9 There are no other valid combinations. Example 3:\nInput: k = 4, n = 1 Output: [] Explanation: There are no valid combinations. Using 4 different numbers in the range [1,9], the smallest sum we can get is 1+2+3+4 = 10 and since 10 \u0026gt; 1, there are no valid combination.\n\u0026lt;解題\u0026gt; class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum3(int k, int n) { int[] nums = new int[9]; for(int i =0 ;i\u0026lt; 9; i++){ nums[i] = i+1; } Arrays.sort(nums); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); helper(res, nums, new ArrayList\u0026lt;\u0026gt;(), n, k, 0); return res; } public void helper(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, int[] nums, List\u0026lt;Integer\u0026gt; temp, int target, int count, int start){ if(target \u0026lt; 0) return; if(target == 0 \u0026amp;\u0026amp; count == 0){ res.add(new ArrayList\u0026lt;\u0026gt;(temp)); } for(int i =start; i\u0026lt; nums.length; i++){ if(i != start \u0026amp;\u0026amp; nums[i] == nums[i-1]) continue; temp.add(nums[i]); helper(res, nums, temp, target - nums[i], count -1, i+1); temp.remove(temp.size() - 1); } } } Time complexity: O(2^n) Space complexity: O(2^n + n)\n","permalink":"https://pattysung1.github.io/works/leetcode-216/","tags":["leetcode"],"title":"Leetcode-216. Combination Sum III"},{"categories":["Programming"],"contents":"Given a collection of candidate numbers (candidates) and a target number (target), find all unique combinations in candidates where the candidate numbers sum to target.\nEach number in candidates may only be used once in the combination.\nNote: The solution set must not contain duplicate combinations.\nExample 1:\nInput: candidates = [10,1,2,7,6,1,5], target = 8 Output: [ [1,1,6], [1,2,5], [1,7], [2,6] ] Example 2:\nInput: candidates = [2,5,2,1,2], target = 5 Output: [ [1,2,2], [5] ]\n\u0026lt;解題\u0026gt; 本層不能用同樣的數字 : (1)排序 (2) if(i!=start \u0026amp;\u0026amp; i==start[i]) continue class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum2(int[] candidates, int target) { if(candidates == null ) return new ArrayList\u0026lt;\u0026gt;(); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(candidates); helper(res, candidates, new ArrayList\u0026lt;\u0026gt;(), target, 0); return res; } public void helper(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, int[] nums, List\u0026lt;Integer\u0026gt; temp, int target, int start){ if(target \u0026lt; 0) return; if(target ==0){ res.add(new ArrayList\u0026lt;\u0026gt;(temp)); return; } for(int i = start; i \u0026lt; nums.length; i++){ //和前一個數字ㄧ樣的話就跳掉(從第二個開始看) if(i != start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) continue; temp.add(nums[i]); helper(res, nums, temp, target - nums[i], i + 1); temp.remove(temp.size() - 1); } } } Time: O(2^n) Space: O(2^n + n)\n","permalink":"https://pattysung1.github.io/works/leetcode-40/","tags":["leetcode","array","backtracking"],"title":"Leetcode-40. Combination Sum II"},{"categories":["Programming"],"contents":"Given an array nums of distinct integers, return all the possible permutations. You can return the answer in any order.\nExample 1:\nInput: nums = [1,2,3] Output: [[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]] Example 2:\nInput: nums = [0,1] Output: [[0,1],[1,0]] Example 3:\nInput: nums = [1] Output: [[1]]\n\u0026lt;解題\u0026gt; Time: O(N!) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-46/","tags":["leetcode","Recursion"],"title":"Leetcode-46. Permutations"},{"categories":["Programming"],"contents":"Given two integers n and k, return all possible combinations of k numbers chosen from the range [1, n].\nYou may return the answer in any order.\nExample 1:\nInput: n = 4, k = 2 Output: [[1,2],[1,3],[1,4],[2,3],[2,4],[3,4]] Explanation: There are 4 choose 2 = 6 total combinations. Note that combinations are unordered, i.e., [1,2] and [2,1] are considered to be the same combination. Example 2:\nInput: n = 1, k = 1 Output: [[1]] Explanation: There is 1 choose 1 = 1 total combination.\n\u0026lt;解題\u0026gt; class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combine(int n, int k) { int[] nums = new int[n]; for(int i =0; i\u0026lt;n; i++){ nums[i] = i+1; } List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); helper(res, nums, new ArrayList\u0026lt;\u0026gt;(), 0, k); return res; } public void helper (List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, int[] nums, List\u0026lt;Integer\u0026gt; temp, int index, int count){ if(count == 0){ res.add(new ArrayList\u0026lt;\u0026gt;(temp)); return; } for(int i = index ; i \u0026lt; nums.length; i++){ temp.add(nums[i]); helper(res, nums, temp, i + 1, count - 1); temp.remove(temp.size() -1); } } } Time: O(C(n, k)) = n! / (k! * (n - k)!) Space: O(C(n, k) + k)\n","permalink":"https://pattysung1.github.io/works/leetcode-77/","tags":["leetcode","Backtracking"],"title":"Leetcode-77. Combinations"},{"categories":["Programming"],"contents":"Given the head of a singly linked list, group all the nodes with odd indices together followed by the nodes with even indices, and return the reordered list.\nThe first node is considered odd, and the second node is even, and so on.\nNote that the relative order inside both the even and odd groups should remain as it was in the input.\nYou must solve the problem in O(1) extra space complexity and O(n) time complexity.\nExample 1:\nInput: head = [1,2,3,4,5] Output: [1,3,5,2,4] Example 2:\nInput: head = [2,1,3,5,6,4,7] Output: [2,3,6,7,1,5,4]\n\u0026lt;解題\u0026gt; class Solution { public ListNode oddEvenList(ListNode head) { if(head == null || head.next == null )return head; ListNode odd = head; ListNode even = head.next; ListNode evenHead = even; while (even != null \u0026amp;\u0026amp; even.next != null){ odd.next = odd.next.next; even.next = even.next.next; odd = odd.next; even = even.next; } odd.next = evenHead; return head; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-328/","tags":["leetcode","linked List"],"title":"328. Odd Even Linked List"},{"categories":["Programming"],"contents":"Design a data structure that follows the constraints of a Least Recently Used (LRU) cache.\nImplement the LRUCache class:\nLRUCache(int capacity) Initialize the LRU cache with positive size capacity. int get(int key) Return the value of the key if the key exists, otherwise return -1. void put(int key, int value) Update the value of the key if the key exists. Otherwise, add the key-value pair to the cache. If the number of keys exceeds the capacity from this operation, evict the least recently used key. The functions get and put must each run in O(1) average time complexity.\nExample 1:\nInput [\u0026ldquo;LRUCache\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;get\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;get\u0026rdquo;, \u0026ldquo;put\u0026rdquo;, \u0026ldquo;get\u0026rdquo;, \u0026ldquo;get\u0026rdquo;, \u0026ldquo;get\u0026rdquo;] [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]] Output [null, null, null, 1, null, -1, null, -1, 3, 4]\nExplanation LRUCache lRUCache = new LRUCache(2); lRUCache.put(1, 1); // cache is {1=1} lRUCache.put(2, 2); // cache is {1=1, 2=2} lRUCache.get(1); // return 1 lRUCache.put(3, 3); // LRU key was 2, evicts key 2, cache is {1=1, 3=3} lRUCache.get(2); // returns -1 (not found) lRUCache.put(4, 4); // LRU key was 1, evicts key 1, cache is {4=4, 3=3} lRUCache.get(1); // return -1 (not found) lRUCache.get(3); // return 3 lRUCache.get(4); // return 4\n\u0026lt;解題\u0026gt; class LRUCache { class Node { int key; int value; Node pre; Node next; public Node(int key, int value){ this.key = key; this.value = value; } } private HashMap\u0026lt;Integer, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); private int capacity; //頭部-\u0026gt;最老的元素 private Node head; //尾部-\u0026gt;最新的元素 private Node tail; public LRUCache(int capacity) { this.capacity = capacity; head = null; tail = null; } public int get(int key) { Node node = map.get(key); if(node == null){ return -1; } //如果node是最新元素，直接返回 if(node != tail) { //如果node是head，需要把它移到末尾 if(node == head){ head = head.next; } else { node.pre.next = node.next; node.next.pre = node.pre; } //把取出的node放到最後 tail.next = node; node.pre = tail; node.next = null; tail = node; } return node.value; } public void put(int key, int value) { Node node = map.get(key); //已經存在這個node，只需要更新node的值 if(node != null){ node.value = value; if(node != tail){ if(node == head){ head = head.next; } else { node.pre.next = node.next; node.next.pre = node.pre; } tail.next = node; node.pre = tail; node.next = null; tail = node; } } else { //需要插入新的節點 Node newNode = new Node(key, value); if(capacity == 0){ Node temp = head; //把舊的head刪掉 head = head.next; //如果刪除後鏈表為空，也要更新tail if (head == null) { tail = null; } //map中也要刪除 map.remove(temp.key); capacity++; } //如果是鏈表中的第一個點 if(head == null \u0026amp;\u0026amp; tail == null){ head = newNode; } else { tail.next = newNode; newNode.pre = tail; newNode.next = null; } tail = newNode; map.put(key, newNode); //減少一個容量 capacity--; } } } /** * Your LRUCache object will be instantiated and called as such: * LRUCache obj = new LRUCache(capacity); * int param_1 = obj.get(key); * obj.put(key,value); */ Time: O(1) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-146/","tags":["leetcode","linked List"],"title":"Leetcode-146. LRU Cache"},{"categories":["Programming"],"contents":"Given a linked list, swap every two adjacent nodes and return its head. You must solve the problem without modifying the values in the list\u0026rsquo;s nodes (i.e., only nodes themselves may be changed.)\nExample 1:\nInput: head = [1,2,3,4] Output: [2,1,4,3] Example 2:\nInput: head = [] Output: [] Example 3:\nInput: head = [1] Output: [1]\n\u0026lt;解題\u0026gt; class Solution { public ListNode swapPairs(ListNode head) { if (head == null || head.next == null) return head; ListNode dummy = new ListNode(0); ListNode curr = dummy; dummy.next= head; while (curr.next != null \u0026amp;\u0026amp; curr.next.next != null){ ListNode first = curr.next; ListNode second = curr.next.next; curr.next = second; first.next = second.next; second.next = first; curr = curr.next.next; } return dummy.next; } } ","permalink":"https://pattysung1.github.io/works/leetcode-24/","tags":["leetcode","linked List"],"title":"Leetcode-24. Swap Nodes in Pairs"},{"categories":["Programming"],"contents":"Implement the RandomizedSet class:\nRandomizedSet() Initializes the RandomizedSet object. bool insert(int val) Inserts an item val into the set if not present. Returns true if the item was not present, false otherwise. bool remove(int val) Removes an item val from the set if present. Returns true if the item was present, false otherwise. int getRandom() Returns a random element from the current set of elements (it\u0026rsquo;s guaranteed that at least one element exists when this method is called). Each element must have the same probability of being returned. You must implement the functions of the class such that each function works in average O(1) time complexity.\nExample 1:\nInput [\u0026ldquo;RandomizedSet\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;remove\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;getRandom\u0026rdquo;, \u0026ldquo;remove\u0026rdquo;, \u0026ldquo;insert\u0026rdquo;, \u0026ldquo;getRandom\u0026rdquo;] [[], [1], [2], [2], [], [1], [2], []] Output [null, true, false, true, 2, true, false, 2]\nExplanation RandomizedSet randomizedSet = new RandomizedSet(); randomizedSet.insert(1); // Inserts 1 to the set. Returns true as 1 was inserted successfully. randomizedSet.remove(2); // Returns false as 2 does not exist in the set. randomizedSet.insert(2); // Inserts 2 to the set, returns true. Set now contains [1,2]. randomizedSet.getRandom(); // getRandom() should return either 1 or 2 randomly. randomizedSet.remove(1); // Removes 1 from the set, returns true. Set now contains [2]. randomizedSet.insert(2); // 2 was already in the set, so return false. randomizedSet.getRandom(); // Since 2 is the only number in the set, getRandom() will always return 2.\n\u0026lt;解題\u0026gt; class RandomizedSet { List\u0026lt;Integer\u0026gt; list; HashMap\u0026lt;Integer,Integer\u0026gt; map; Random rand; public RandomizedSet() { list= new ArrayList\u0026lt;\u0026gt;(); map = new HashMap\u0026lt;\u0026gt;(); rand = new Random(); } public boolean insert(int val) { if(map.containsKey(val)){ return false; } map.put(val, list.size()); list.add(val); return true; } public boolean remove(int val) { if(!map.containsKey(val)) return false; int last = list.get(list.size()-1); int idx = map.get(val); list.set(idx, last); map.put(last,idx); list.remove(list.size()-1); map.remove(val); return true; } public int getRandom() { int n = rand.nextInt(list.size()); return list.get(n); } } T: O(1) S: O(n)\n補充 public class NextInt1 { public static void main(String[] args) { // create random object Random ran = new Random(); // generating integer int nxt = ran.nextInt(); // Printing the random Number System.out.println (\u0026#34;The Randomly generated integer is : \u0026#34; + nxt); } } Random.nextInt(int n) : The nextInt(int n) is used to get a random number between 0(inclusive) and the number passed in this argument(n), exclusive.\n","permalink":"https://pattysung1.github.io/works/leetcode-380/","tags":["leetcode","Hash Table"],"title":"Leetcode-380. Insert Delete GetRandom O(1)"},{"categories":["Programming"],"contents":"Given two strings ransomNote and magazine, return true if ransomNote can be constructed by using the letters from magazine and false otherwise.\nEach letter in magazine can only be used once in ransomNote.\nExample 1:\nInput: ransomNote = \u0026ldquo;a\u0026rdquo;, magazine = \u0026ldquo;b\u0026rdquo; Output: false Example 2:\nInput: ransomNote = \u0026ldquo;aa\u0026rdquo;, magazine = \u0026ldquo;ab\u0026rdquo; Output: false Example 3:\nInput: ransomNote = \u0026ldquo;aa\u0026rdquo;, magazine = \u0026ldquo;aab\u0026rdquo; Output: true\n\u0026lt;解題\u0026gt; class Solution { public boolean canConstruct(String ransomNote, String magazine) { int[] cnt = new int[26]; for(int i = 0; i \u0026lt; magazine.length(); i++){ cnt[magazine.charAt(i) - \u0026#39;a\u0026#39;]++; } for(int i = 0; i \u0026lt; ransomNote.length(); i++){ char c = ransomNote.charAt(i); if(cnt[c - \u0026#39;a\u0026#39;] == 0){ // 如果 cnt 中對應的元素值為 0，表示無法構建，返回 false return false; } cnt[c - \u0026#39;a\u0026#39;]--; } return true; } } T: O(m+n) S: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-383/","tags":["leetcode","Hash Table"],"title":"Leetcode-383. Ransom Note"},{"categories":["Programming"],"contents":"Given the head of a singly linked list, return the middle node of the linked list.\nIf there are two middle nodes, return the second middle node.\nExample 1:\nInput: head = [1,2,3,4,5] Output: [3,4,5] Explanation: The middle node of the list is node 3. Example 2:\nInput: head = [1,2,3,4,5,6] Output: [4,5,6] Explanation: Since the list has two middle nodes with values 3 and 4, we return the second one.\n\u0026lt;解題\u0026gt; class Solution { public ListNode middleNode(ListNode head) { ListNode slow = head; ListNode fast = head; while(fast != null \u0026amp;\u0026amp; fast.next != null){ slow = slow.next; fast = fast.next.next; } return slow; } } Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-876/","tags":["leetcode","linked List"],"title":"Leetcode-876. Middle of the Linked List"},{"categories":["Programming"],"contents":"Given the root of a binary tree, return the level order traversal of its nodes\u0026rsquo; values. (i.e., from left to right, level by level).\nExample 1:\nInput: root = [3,9,20,null,null,15,7] Output: [[3],[9,20],[15,7]] Example 2:\nInput: root = [1] Output: [[1]] Example 3:\nInput: root = [] Output: []\n\u0026lt;解題\u0026gt; 使用一個隊列（Queue）來幫助進行層序遍歷，將根節點添加到隊列中 res，用於存儲遍歷的結果 level: 存每層的節點 看是否當前節點有左右節點，有的話加入queue-\u0026gt;繼續遍歷 class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; levelOrder(TreeNode root) { if(root == null) return new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); while(!queue.isEmpty()){ int size = queue.size(); List\u0026lt;Integer\u0026gt; level = new ArrayList\u0026lt;\u0026gt;(); for(int i = 0; i \u0026lt; size; i++){ TreeNode curr = queue.poll(); level.add(curr.val); if(curr.left!= null) queue.offer(curr.left); if(curr.right!= null) queue.offer(curr.right); } res.add(level); } return res; } } Time: O(N) Space: O(H)\n和 199. Binary Tree Right Side View 做比較\n","permalink":"https://pattysung1.github.io/works/leetcode-102/","tags":["leetcode","tree"],"title":"Leetcode-102. Binary Tree Level Order Traversal"},{"categories":["Programming"],"contents":"Given two integer arrays preorder and inorder where preorder is the preorder traversal of a binary tree and inorder is the inorder traversal of the same tree, construct and return the binary tree.\nExample 1:\nInput: preorder = [3,9,20,15,7], inorder = [9,3,15,20,7] Output: [3,9,20,null,null,15,7] Example 2:\nInput: preorder = [-1], inorder = [-1] Output: [-1] \u0026lt;解題\u0026gt; class Solution { public TreeNode buildTree(int[] preorder, int[] inorder) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; inorder.length; i++){ map.put(inorder[i], i); } return helper(preorder, inorder, 0, 0, inorder.length - 1, map); } private TreeNode helper(int[] preorder, int[] inorder, int preStart, int inStart, int inEnd, HashMap\u0026lt;Integer, Integer\u0026gt; map){ if(preStart \u0026gt;= preorder.length || inStart \u0026gt; inEnd) return null; TreeNode root = new TreeNode(preorder[preStart]); int rootIndex = map.get(preorder[preStart]); root.left = helper(preorder, inorder, preStart+1, inStart, rootIndex - 1, map); root.right = helper(preorder, inorder, preStart + rootIndex - inStart + 1, rootIndex + 1, inEnd, map); return root; } } Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-105/","tags":["leetcode","tree"],"title":"Leetcode-105. Construct Binary Tree from Preorder and Inorder Traversal"},{"categories":["Programming"],"contents":"Given two integer arrays inorder and postorder where inorder is the inorder traversal of a binary tree and postorder is the postorder traversal of the same tree, construct and return the binary tree.\nExample 1:\nInput: inorder = [9,3,15,20,7], postorder = [9,15,7,20,3] Output: [3,9,20,null,null,15,7] Example 2:\nInput: inorder = [-1], postorder = [-1] Output: [-1]\n\u0026lt;解題\u0026gt; class Solution { public TreeNode buildTree(int[] inorder, int[] postorder) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; inorder.length; i++){ map.put(inorder[i], i); } return helper(inorder, postorder, 0, inorder.length - 1, 0, postorder.length - 1, map); } private TreeNode helper(int[] inorder, int[] postorder, int inStart, int inEnd, int postStart, int postEnd, HashMap\u0026lt;Integer, Integer\u0026gt; map){ if(inStart \u0026gt; inEnd || postStart \u0026lt; 0) return null; TreeNode root = new TreeNode(postorder[postEnd]); int rootIndex = map.get(postorder[postEnd]); root.left = helper(inorder, postorder, inStart, rootIndex - 1, postStart, postStart + rootIndex - inStart - 1, map); root.right = helper(inorder, postorder, rootIndex + 1, inEnd, postStart + rootIndex - inStart, postEnd - 1, map); return root; } } Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-106/","tags":["leetcode","tree"],"title":"Leetcode-105. Construct Binary Tree from Preorder and Inorder Traversal"},{"categories":["Programming"],"contents":"Given the root of a binary tree, imagine yourself standing on the right side of it, return the values of the nodes you can see ordered from top to bottom.\nExample 1:\nInput: root = [1,2,3,null,5,null,4] Output: [1,3,4] Example 2:\nInput: root = [1,null,3] Output: [1,3] Example 3:\nInput: root = [] Output: []\n\u0026lt;解題\u0026gt; class Solution { public List\u0026lt;Integer\u0026gt; rightSideView(TreeNode root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); if(root == null) return res; queue.offer(root); while(!queue.isEmpty()){ int size = queue.size(); for(int i =0; i\u0026lt;size; i++){ TreeNode curr = queue.poll(); if(i==0) res.add(curr.val); if(curr.right != null) queue.offer(curr.right); if(curr.left != null) queue.offer(curr.left); } } return res; } } Time Complexity: O(N) Space Complexity: O(N)\n和 102. Binary Tree Level Order Traversal 做比較\n","permalink":"https://pattysung1.github.io/works/leetcode-199/","tags":["leetcode"],"title":"Leetcode-199. Binary Tree Right Side View"},{"categories":["Programming"],"contents":"There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return the ordering of courses you should take to finish all courses. If there are many valid answers, return any of them. If it is impossible to finish all courses, return an empty array.\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]] Output: [0,1] Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So the correct course order is [0,1]. Example 2:\nInput: numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]] Output: [0,2,1,3] Explanation: There are a total of 4 courses to take. To take course 3 you should have finished both courses 1 and 2. Both courses 1 and 2 should be taken after you finished course 0. So one correct course order is [0,1,2,3]. Another correct ordering is [0,2,1,3]. Example 3:\nInput: numCourses = 1, prerequisites = [] Output: [0]\n\u0026lt;解題\u0026gt; class Solution { public int[] findOrder(int numCourses, int[][] prerequisites) { int[] indegree = new int[numCourses]; int[] res = new int[numCourses]; int k = 0; for (int[] pair: prerequisites){ indegree[pair[0]]++; //有先修課 } Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; indegree.length; i++){ if(indegree[i] == 0){ //無先修課先存入 queue.offer(i); res[k++] = i; } } while (!queue.isEmpty()){ int curr = queue.poll(); for (int[] pair : prerequisites){ if(pair[1] == curr){ indegree[pair[0]]--; if(indegree[pair[0]] == 0){ queue.offer(pair[0]); res[k++] = pair[0]; } } } } return (k == numCourses) ? res : new int[0]; } } // [0,1,2,3,4] // [2,1,0,1,2] -\u0026gt; indegree T: O(prerequisites.length + numCourses)，在最壞情況下，如果所有課程之間都有先修關係，則為 O(N^2)，其中 N 是課程的總數 S: O(numCourses)\n","permalink":"https://pattysung1.github.io/works/leetcode-210/","tags":["leetcode","graph"],"title":"Leetcode-210. Course Schedule II"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; Dijkstra\u0026rsquo;s algorithm: Dijkstra\u0026rsquo;s algorithm finds the shortest path between a given node (which is called the \u0026ldquo;source node\u0026rdquo;) and all other nodes in a graph. This algorithm uses the weights of the edges to find the path that minimizes the total distance (weight) between the source node and all other nodes.\n檢查是否存在一條路徑從 place 到 i -\u0026gt;g[place][i] \u0026gt; 0\nclass Solution { public int findCheapestPrice(int n, int[][] flights, int src, int dst, int K) { int[][] g = new int[n][n]; for (int[] f : flights) { g[f[0]][f[1]] = f[2]; } // (1) adding the distance array to track min price to each node int[] distance = new int[n]; Arrays.fill(distance, Integer.MAX_VALUE ); // (2) change heap to normal queue Queue\u0026lt;int[]\u0026gt; heap = new LinkedList\u0026lt;\u0026gt;(); heap.offer(new int[]{0, src, K + 1}); distance[src] = 0; while (!heap.isEmpty()) { int[] cur = heap.poll(); int price = cur[0], place = cur[1], remainStops = cur[2]; if (remainStops \u0026gt; 0) { for (int i = 0; i \u0026lt; n; i++) { if (g[place][i] \u0026gt; 0 \u0026amp;\u0026amp; distance[i] \u0026gt;= price + g[place][i]) { heap.offer(new int[]{price + g[place][i], i, remainStops - 1}); distance[i] = Math.min(distance[i], price + g[place][i]); } } } } return distance[dst] == Integer.MAX_VALUE ? -1 : distance[dst]; } } Time: O(E * K)，其中 E 是邊的數量，K 是最大停止數。這是因為在最壞情況下，我們可能需要遍歷每條邊 K 次，以找到最短路徑 Space: O(N + E)，其中 N 是節點數，E 是邊的數量。我們使用了一個 distance 數組來存儲每個節點到起點的最短距離，\n","permalink":"https://pattysung1.github.io/works/leetcode-787/","tags":["leetcode","graph"],"title":"Leetcode-787. Cheapest Flights Within K Stops"},{"categories":["Programming"],"contents":"Given the root of a binary tree, determine if it is a valid binary search tree (BST).\nA valid BST is defined as follows:\nThe left subtree of a node contains only nodes with keys less than the node\u0026rsquo;s key. The right subtree of a node contains only nodes with keys greater than the node\u0026rsquo;s key. Both the left and right subtrees must also be binary search trees.\nExample 1:\nInput: root = [2,1,3] Output: true Example 2:\nInput: root = [5,1,4,null,null,3,6] Output: false Explanation: The root node\u0026rsquo;s value is 5 but its right child\u0026rsquo;s value is 4.\n\u0026lt;解題\u0026gt; public class Solution { public boolean isValidBST(TreeNode root) { return helper(root, Long.MIN_VALUE, Long.MAX_VALUE); } public boolean helper(TreeNode root, long min, long max) { if (root == null) return true; if (root.val \u0026gt;= max || root.val \u0026lt;= min) return false; return helper(root.left, min, root.val) \u0026amp;\u0026amp; helper(root.right, root.val, max); } } Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-98/","tags":["leetcode","string"],"title":"Leetcode-98. Validate Binary Search Tree"},{"categories":["Programming"],"contents":"There are a total of numCourses courses you have to take, labeled from 0 to numCourses - 1. You are given an array prerequisites where prerequisites[i] = [ai, bi] indicates that you must take course bi first if you want to take course ai.\nFor example, the pair [0, 1], indicates that to take course 0 you have to first take course 1. Return true if you can finish all courses. Otherwise, return false.\nExample 1:\nInput: numCourses = 2, prerequisites = [[1,0]] Output: true Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0. So it is possible. Example 2:\nInput: numCourses = 2, prerequisites = [[1,0],[0,1]] Output: false Explanation: There are a total of 2 courses to take. To take course 1 you should have finished course 0, and to take course 0 you should also have finished course 1. So it is impossible.\n\u0026lt;解題\u0026gt; class Solution { public boolean canFinish(int numCourses, int[][] prerequisites) { int[] indegree = new int[numCourses]; for (int[] pair : prerequisites) { // pair[1]是先修課程，pair[0]是後修課程 indegree[pair[0]]++; // 後修課程的入度加1 } Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { // 入度為0的課程，可以直接修 queue.offer(i); } } while (!queue.isEmpty()) { int curr = queue.poll(); // 從隊列中取出當前可以修的課程 for (int[] pair : prerequisites) { if (pair[1] == curr) { // 找到有curr作為先修的課程 indegree[pair[0]]--; // 後修課程的入度減1 if (indegree[pair[0]] == 0) { queue.offer(pair[0]); // 如果後修課程的入度變為0，則可以修 } } } } for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] != 0) { // 如果還有入度不為0的課程，表示無法完成所有課程 return false; } } return true; } } T: O(numCourses + prerequisites.length) S: O(numCourses)\n拓撲排序 拓撲排序（Topological Sorting）是一種用於有向無環圖（DAG）的節點排序算法，其中節點代表一些對象，有向邊代表對象之間的依賴關係。拓撲排序的目標是找到一個節點的線性排序，使得對於每一條有向邊 (u, v)，節點 u 在排序中出現在節點 v 之前。換句話說，它能夠找到一種順序，使得所有的依賴關係都被滿足。\n拓撲排序常用於解決以下問題：\n1.任務調度：例如，課程安排、作業調度等。 2.編譯順序：編譯器需要確保所有的依賴項被按正確的順序編譯。 3.資源分配：在分配資源時需要確保資源之間的依賴性。 4.地圖繪製：在地圖繪製中，城市之間的道路或飛行路線可以表示為有向無環圖，拓撲排序可用於找到最佳路線。\n拓撲排序可以通過不同的演算法來實現，其中最常見的演算法包括：\n1.Kahn\u0026rsquo;s Algorithm：這是一種基於入度的方法，通過選擇入度為0的節點，然後移除相關邊來構建排序序列。 2.Depth-First Search (DFS)：使用深度優先搜索遍歷有向圖，並在遍歷過程中按照反向順序將節點添加到排序序列中。 3.Breadth-First Search (BFS)：使用廣度優先搜索來構建排序序列，類似於Kahn\u0026rsquo;s Algorithm，但是使用隊列而不是堆棧。\n1. Kahn\u0026rsquo;s Algorithm (基於入度的方法) 假設我們有一個有向圖的邊列表 edges，以及節點數量 numCourses，我們可以使用Kahn\u0026rsquo;s Algorithm 來進行拓撲排序。這是一個基於入度的方法。\nCopy code import java.util.*; public class TopologicalSortKahn { public int[] findOrder(int numCourses, int[][] prerequisites) { int[] indegree = new int[numCourses]; List\u0026lt;Integer\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); // Calculate indegree for each course for (int[] edge : prerequisites) { indegree[edge[0]]++; } // Add courses with indegree 0 to the queue for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } while (!queue.isEmpty()) { int course = queue.poll(); result.add(course); for (int[] edge : prerequisites) { if (edge[1] == course) { indegree[edge[0]]--; if (indegree[edge[0]] == 0) { queue.offer(edge[0]); } } } } if (result.size() != numCourses) { return new int[0]; // No valid ordering } int[] order = new int[numCourses]; for (int i = 0; i \u0026lt; numCourses; i++) { order[i] = result.get(i); } return order; } } 2. Depth-First Search (DFS) 方法 使用深度優先搜索 (DFS) 來進行拓撲排序。這個示例假設我們有一個有向圖的鄰接表 adjList 和節點數量 numCourses。\nCopy code import java.util.*; public class TopologicalSortDFS { public int[] findOrder(int numCourses, int[][] prerequisites) { Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; adjList = new HashMap\u0026lt;\u0026gt;(); for (int[] edge : prerequisites) { adjList.putIfAbsent(edge[1], new ArrayList\u0026lt;\u0026gt;()); adjList.get(edge[1]).add(edge[0]); } boolean[] visited = new boolean[numCourses]; boolean[] onStack = new boolean[numCourses]; Stack\u0026lt;Integer\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (!visited[i] \u0026amp;\u0026amp; hasCycle(i, adjList, visited, onStack, stack)) { return new int[0]; // Cycle detected, no valid ordering } } int[] order = new int[numCourses]; for (int i = 0; !stack.isEmpty(); i++) { order[i] = stack.pop(); } return order; } private boolean hasCycle(int course, Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; adjList, boolean[] visited, boolean[] onStack, Stack\u0026lt;Integer\u0026gt; stack) { visited[course] = true; onStack[course] = true; if (adjList.containsKey(course)) { for (int neighbor : adjList.get(course)) { if (!visited[neighbor]) { if (hasCycle(neighbor, adjList, visited, onStack, stack)) { return true; } } else if (onStack[neighbor]) { return true; } } } onStack[course] = false; stack.push(course); return false; } } 3. Breadth-First Search (BFS) 方法 使用廣度優先搜索 (BFS) 來進行拓撲排序。這個示例也假設我們有一個有向圖的鄰接表 adjList 和節點數量 numCourses。\nCopy code import java.util.*; public class TopologicalSortBFS { public int[] findOrder(int numCourses, int[][] prerequisites) { Map\u0026lt;Integer, List\u0026lt;Integer\u0026gt;\u0026gt; adjList = new HashMap\u0026lt;\u0026gt;(); int[] indegree = new int[numCourses]; for (int[] edge : prerequisites) { adjList.putIfAbsent(edge[1], new ArrayList\u0026lt;\u0026gt;()); adjList.get(edge[1]).add(edge[0]); indegree[edge[0]]++; } Queue\u0026lt;Integer\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; numCourses; i++) { if (indegree[i] == 0) { queue.offer(i); } } int[] order = new int[numCourses]; int index = 0; while (!queue.isEmpty()) { int course = queue.poll(); order[index++] = course; if (adjList.containsKey(course)) { for (int neighbor : adjList.get(course)) { indegree[neighbor]--; if (indegree[neighbor] == 0) { queue.offer(neighbor); } } } } return index == numCourses ? order : new int[0]; // No valid ordering if not all courses are included } } ","permalink":"https://pattysung1.github.io/works/leetcode-207/","tags":["leetcode","graph"],"title":"Leetcode-207. Course Schedule"},{"categories":["Programming"],"contents":"Given an m x n binary matrix mat, return the distance of the nearest 0 for each cell.\nThe distance between two adjacent cells is 1.\nExample 1:\nInput: mat = [[0,0,0],[0,1,0],[0,0,0]] Output: [[0,0,0],[0,1,0],[0,0,0]] Example 2:\nInput: mat = [[0,0,0],[0,1,0],[1,1,1]] Output: [[0,0,0],[0,1,0],[1,2,1]]\n\u0026lt;解題\u0026gt; 1.用BFS class Solution { public int[][] updateMatrix(int[][] matrix) { int m = matrix.length; int n = matrix[0].length; Queue\u0026lt;int[]\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); boolean[][] visited = new boolean[m][n]; int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}}; // 表示四個方向 for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (matrix[i][j] == 0) { queue.offer(new int[]{i, j}); visited[i][j] = true; } else { matrix[i][j] = m + n; } } } int step = 1; while (!queue.isEmpty()) { int size = queue.size(); for (int i = 0; i \u0026lt; size; i++) { int[] curr = queue.poll(); for (int[] dir : dirs) { int x = curr[0] + dir[0]; int y = curr[1] + dir[1]; if (x \u0026lt; 0 || x \u0026gt;= m || y \u0026lt; 0 || y \u0026gt;= n || visited[x][y]) continue; matrix[x][y] = step; visited[x][y] = true; queue.offer(new int[]{x, y}); } } step++; } return matrix; } } Time：O(MN) Space：O(MN)\n\u0026lt;解題\u0026gt; 2.用DP class Solution { public int[][] updateMatrix(int[][] matrix) { int m = matrix.length; int n = matrix[0].length; int[][] dp = new int[m][n]; for (int i =0; i\u0026lt; m; i++){ for (int j=0; j\u0026lt;n; j++){ if(matrix[i][j]==0){ dp[i][j] = 0; } else { dp[i][j] = m + n; } } } // 左上至右下 for (int i =0; i\u0026lt; m; i++){ for (int j=0; j\u0026lt;n; j++){ if (i != 0){ dp[i][j] = Math.min(dp[i][j], dp[i-1][j] + 1); } if (j != 0){ dp[i][j] = Math.min(dp[i][j], dp[i][j-1] + 1); } } } // 右下至左上 for (int i = m-1 ; i \u0026gt;=0; i--){ for (int j = n-1 ; j \u0026gt;=0; j--){ if (i != m-1){ dp[i][j] = Math.min(dp[i][j], dp[i+1][j] + 1); } if (j != n-1){ dp[i][j] = Math.min(dp[i][j], dp[i][j+1] + 1); } } } return dp; } } ","permalink":"https://pattysung1.github.io/works/leetcode-542/","tags":["leetcode","tree"],"title":"Leetcode-542. 01 Matrix"},{"categories":["Programming"],"contents":"Write a function to find the longest common prefix string amongst an array of strings.\nIf there is no common prefix, return an empty string \u0026ldquo;\u0026rdquo;.\nExample 1:\nInput: strs = [\u0026ldquo;flower\u0026rdquo;,\u0026ldquo;flow\u0026rdquo;,\u0026ldquo;flight\u0026rdquo;] Output: \u0026ldquo;fl\u0026rdquo; Example 2:\nInput: strs = [\u0026ldquo;dog\u0026rdquo;,\u0026ldquo;racecar\u0026rdquo;,\u0026ldquo;car\u0026rdquo;] Output: \u0026quot;\u0026quot; Explanation: There is no common prefix among the input strings.\n\u0026lt;解題\u0026gt; strs[i].indexOf(prefix) != 0 表示在字符串 strs[i] 中尋找 prefix 字串的索引位置，如果索引位置不等於 0，則表示 prefix 不是 strs[i] 的前綴。\n具體來說：\n如果 indexOf(prefix) 返回 0，這意味著 prefix 是 strs[i] 的前綴，因為字串索引是從 0 開始的，而 0 表示字串的開頭。 如果 indexOf(prefix) 返回的索引位置大於 0，那麼 prefix 出現在 strs[i] 的某個位置，但不是在開頭，因此不是前綴。 如果 indexOf(prefix) 返回 -1，這意味著 prefix 不存在於 strs[i] 中。\nclass Solution { public String longestCommonPrefix(String[] strs) { if (strs.length == 0) return \u0026#34;\u0026#34;; String prefix = strs[0]; for (int i = 1; i \u0026lt; strs.length; i++){ while(strs[i].indexOf(prefix) != 0){ prefix = prefix.substring(0, prefix.length()-1); } } return prefix; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-14/","tags":["leetcode","string"],"title":"Leetcode-14. Longest Common Prefix"},{"categories":["Programming"],"contents":"You are given a string s and an integer k. You can choose any character of the string and change it to any other uppercase English character. You can perform this operation at most k times.\nReturn the length of the longest substring containing the same letter you can get after performing the above operations.\nExample 1:\nInput: s = \u0026ldquo;ABAB\u0026rdquo;, k = 2 Output: 4 Explanation: Replace the two \u0026lsquo;A\u0026rsquo;s with two \u0026lsquo;B\u0026rsquo;s or vice versa. Example 2:\nInput: s = \u0026ldquo;AABABBA\u0026rdquo;, k = 1 Output: 4 Explanation: Replace the one \u0026lsquo;A\u0026rsquo; in the middle with \u0026lsquo;B\u0026rsquo; and form \u0026ldquo;AABBBBA\u0026rdquo;. The substring \u0026ldquo;BBBB\u0026rdquo; has the longest repeating letters, which is 4. There may exists other ways to achieve this answer too.\n\u0026lt;解題\u0026gt; class Solution { public int characterReplacement(String s, int k) { int n = s.length(); int[] char_counts = new int[26]; int start = 0; int maxLength = 0; int max_count = 0; for (int end = 0; end \u0026lt; n; end++){ char_counts[s.charAt(end) - \u0026#39;A\u0026#39;]++; int curr_count = char_counts[s.charAt(end) - \u0026#39;A\u0026#39;]; max_count = Math.max(max_count, curr_count); //如果窗口內的字符中非主要字符的總數（需要替換的字符數）超過了允許的最大替換次數 k，則需要縮小窗口 while (end - start - max_count +1 \u0026gt; k ){ char_counts[s.charAt(start) - \u0026#39;A\u0026#39;]--; start++; } maxLength = Math.max(maxLength, end - start +1); } return maxLength; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-424/","tags":["leetcode","string"],"title":"Leetcode-424. Longest Repeating Character Replacement"},{"categories":["Programming"],"contents":"1. 字符數組轉換為字符串 char[] charArray = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;}; String str = new String(charArray); // 将字符数组转换为字符串 System.out.println(str); // 输出 \u0026#34;Hello\u0026#34; char[] key_str = {\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;}; String key = String.valueOf(key_str); System.out.println(key); 2. StringBuilder 為了節省記憶體就會使用使用StringBuilder\nappend() ：這個方法是將字串接在字串的最後方 insert()：這個方法可以將字串接在你指定的位置 indexOf()：這個方法是尋找某個字串在現在這段字的那個位置，可以拿來搭配insert使用 reverse()：可以將整個字串反轉順序，雖然我幾乎用不到 toString()：就是將串好的字轉成字串輸出 length()：現有的字串長度\npublic class StringBuilderDemo { public static void main(String[] args) { StringBuilder sb = new StringBuilder(); sb.append(\u0026#34;This is \u0026#34;); sb.append(\u0026#34;a star\u0026#34;); System.out.println(sb.toString());//This is a star System.out.println(sb.length());//14 System.out.println(sb.indexOf(\u0026#34;star\u0026#34;));//10 sb.insert(sb.indexOf(\u0026#34;star\u0026#34;), \u0026#34;new \u0026#34;); System.out.println(sb.toString());//This is a new star System.out.println(sb.reverse().toString());//rats wen a si sihT } } 參考資料：https://gn00466269.pixnet.net/blog/post/46545513\n","permalink":"https://pattysung1.github.io/works/string/","tags":["string"],"title":"String"},{"categories":["Programming"],"contents":"Given an integer array nums of length n and an integer target, find three integers in nums such that the sum is closest to target.\nReturn the sum of the three integers.\nYou may assume that each input would have exactly one solution.\nExample 1:\nInput: nums = [-1,2,1,-4], target = 1 Output: 2 Explanation: The sum that is closest to the target is 2. (-1 + 2 + 1 = 2). Example 2:\nInput: nums = [0,0,0], target = 1 Output: 0 Explanation: The sum that is closest to the target is 0. (0 + 0 + 0 = 0).\n\u0026lt;解題\u0026gt; class Solution { public int threeSumClosest(int[] nums, int target) { int result = Integer.MAX_VALUE; Arrays.sort(nums); for (int i = 0; i \u0026lt; nums.length - 2 ; i++){ int aPointer = i+1; int bPointer = nums.length - 1; while ( aPointer \u0026lt; bPointer){ int currentSum = nums[i] + nums[aPointer] + nums[bPointer]; if ( currentSum \u0026gt; target){ bPointer--; } else { aPointer++; } if(Math.abs(currentSum - target) \u0026lt; Math.abs(result - target)){ result = currentSum; } } } return result; } } Time: O(n^2) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-16/","tags":["leetcode","array"],"title":"Leetcode-16. 3Sum Closest"},{"categories":["Programming"],"contents":"Given an array of meeting time intervals intervals where intervals[i] = [starti, endi], return the minimum number of conference rooms required.\nExample 1:\nInput: intervals = [[0,30],[5,10],[15,20]] Output: 2 Example 2:\nInput: intervals = [[7,10],[2,4]] Output: 1\n\u0026lt;解法一\u0026gt; public class Solution { public int minMeetingRooms(Interval[] intervals) { int[] starts = new int[intervals.length]; int[] ends = new int[intervals.length]; for(int i=0; i\u0026lt;intervals.length; i++) { starts[i] = intervals[i].start; ends[i] = intervals[i].end; } Arrays.sort(starts); Arrays.sort(ends); int rooms = 0; int endsItr = 0; for(int i=0; i\u0026lt;starts.length; i++) { if(starts[i]\u0026lt;ends[endsItr]) rooms++; else endsItr++; } return rooms; } } Time: O(nlogn)\n\u0026lt;解法二\u0026gt;int[][] class Solution { public int minMeetingRooms(int[][] intervals) { if (intervals == null || intervals.length == 0){ return 0; } Arrays.sort(intervals, (a, b) -\u0026gt; (a[0] - b[0])); PriorityQueue\u0026lt;Integer\u0026gt; heap = new PriorityQueue\u0026lt;\u0026gt;(); for (int[] interval : intervals){ if (heap.size() \u0026gt; 0 \u0026amp;\u0026amp; heap.peek() \u0026lt;= interval[0]){ heap.poll(); } heap.offer(interval[1]); } return heap.size(); } } ","permalink":"https://pattysung1.github.io/works/leetcode-253/","tags":["leetcode","array"],"title":"253. Meeting Rooms II"},{"categories":["Programming"],"contents":"Given an integer array nums, move all 0\u0026rsquo;s to the end of it while maintaining the relative order of the non-zero elements.\nNote that you must do this in-place without making a copy of the array.\nExample 1:\nInput: nums = [0,1,0,3,12] Output: [1,3,12,0,0] Example 2:\nInput: nums = [0] Output: [0]\n\u0026lt;解題\u0026gt; class Solution { public void moveZeroes(int[] nums) { if (nums.length == 1) { return; } int nonZeroIndex = 0; for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != 0) { nums[nonZeroIndex] = nums[i]; nonZeroIndex++; } } while(nonZeroIndex\u0026lt;nums.length){ nums[nonZeroIndex] = 0; nonZeroIndex++; } } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-283/","tags":["leetcode","array"],"title":"283. Move Zeroes"},{"categories":["Programming"],"contents":"Given an array of distinct integers candidates and a target integer target, return a list of all unique combinations of candidates where the chosen numbers sum to target. You may return the combinations in any order.\nThe same number may be chosen from candidates an unlimited number of times. Two combinations are unique if the frequency of at least one of the chosen numbers is different.\nThe test cases are generated such that the number of unique combinations that sum up to target is less than 150 combinations for the given input.\nExample 1:\nInput: candidates = [2,3,6,7], target = 7 Output: [[2,2,3],[7]] Explanation: 2 and 3 are candidates, and 2 + 2 + 3 = 7. Note that 2 can be used multiple times. 7 is a candidate, and 7 = 7. These are the only two combinations. \u0026lt;解題\u0026gt; 因為可以有重複的number，所以用backtracking class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; combinationSum(int[] candidates, int target) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); helper(res, new ArrayList\u0026lt;\u0026gt;(), candidates, target, 0); return res; } private void helper(List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; res, List\u0026lt;Integer\u0026gt; tmp, int[] candidates, int target, int index){ if(target \u0026lt; 0) return; if(target == 0){ res.add(new ArrayList\u0026lt;\u0026gt;(tmp)); return; } for(int i = index ; i\u0026lt;candidates.length ; i++){ tmp.add(candidates[i]); helper(res, tmp, candidates, target - candidates[i], i); tmp.remove(tmp.size()-1); } } } Time: O(2^n) Space: O(n) for the tmp list and O(2^n) for the res list in the worst case\n","permalink":"https://pattysung1.github.io/works/leetcode-39/","tags":["leetcode","array","backtracking"],"title":"Leetcode-39. Combination Sum"},{"categories":["Programming"],"contents":"Given an array of integers nums and an integer k, return the total number of subarrays whose sum equals to k.\nA subarray is a contiguous non-empty sequence of elements within an array.\nExample 1:\nInput: nums = [1,1,1], k = 2 Output: 2 Example 2:\nInput: nums = [1,2,3], k = 3 Output: 2\n\u0026lt;解題\u0026gt; preSum[0] = 0 preSum[1] = nums[0] preSum[2] = nums[1] + preSum[1]\nso we can get the sum from index 0 to 1 by preSum[2] - preSum[0] 利用哈希表記錄前綴和以及其出現的次數，通過查找哈希表中是否存在 sum - k 來判斷是否有子數組的和等於 k。這意味著我們在遍歷數組時，不僅計算了當前位置的前綴和，還檢查了是否存在一個之前的前綴和，使得當前前綴和減去該前綴和等於 k，這樣就能確定存在一個子數組的和等於 k。\nHashMap\u0026lt;Integer, Integer\u0026gt; arr = new HashMap\u0026lt;\u0026gt;()(前者是累積的總和，後者是出現的頻率) arr.put(0,1) 出現(sum of 0, once) class Solution { public int subarraySum(int[] nums, int k) { HashMap\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); map.put(0,1); int sum = 0; int ans = 0; for (int i =0 ; i \u0026lt; nums.length ; i++){ sum += nums[i]; if (map.containsKey(sum-k)){ ans += map.get(sum-k); } map.put(sum, map.getOrDefault(sum, 0) + 1); } return ans; } } Time：O(n) Space：O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-560/","tags":["leetcode","tree"],"title":"Leetcode-560. Subarray Sum Equals K"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-257/","tags":["leetcode","string"],"title":"Leetcode-257. Binary Tree Paths"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; 使用後序遍歷方式來遍歷二叉樹，從樹的底部開始考慮深度。 首先處理葉子節點，然後逐漸向上計算深度，直到找到具有最深葉子節點的子樹的根節點。\nclass Solution { int maxDepth=-1; TreeNode result=null; public TreeNode subtreeWithAllDeepest(TreeNode root) { postOrder(root,0); return result; } int postOrder(TreeNode node, int depth){ if(node==null) return depth; int left = postOrder(node.left, depth+1); int right = postOrder(node.right, depth+1); if(left==right){ maxDepth=Math.max(maxDepth,left); if(maxDepth ==left){ result = node; } } return Math.max(left,right); } } Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-865/","tags":["leetcode","string"],"title":"Leetcode-865. Smallest Subtree with all the Deepest Nodes"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; class Solution { public int[] twoSum(int[] numbers, int target) { int a_pointer = 0; int b_pointer = numbers.length-1; while(a_pointer\u0026lt;b_pointer){ int sum = numbers[a_pointer] + numbers[b_pointer]; if(sum \u0026lt; target){ a_pointer +=1; } else if(sum \u0026gt; target){ b_pointer -=1; } else{ return new int[] {a_pointer+1, b_pointer+1}; } } return new int[] {a_pointer+1, b_pointer+1}; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-167/","tags":["leetcode","string"],"title":"Leetcode-167. Two Sum II - Input Array Is Sorted"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; class Solution { public List\u0026lt;Integer\u0026gt; findAnagrams(String s, String p) { List\u0026lt;Integer\u0026gt; res = new ArrayList(); if(s.length()==0 ||s==null) return res; int[] char_counts = new int[26]; for(char c : p.toCharArray()){ char_counts[c-\u0026#39;a\u0026#39;]++; } int left=0; int right=0; int count = p.length(); while(right\u0026lt;s.length()){ if(char_counts[s.charAt(right++) - \u0026#39;a\u0026#39;]-- \u0026gt;=1 ) count--; if(count==0) res.add(left); if(right-left==p.length() \u0026amp;\u0026amp; char_counts[s.charAt(left++) - \u0026#39;a\u0026#39;]++ \u0026gt;=0 ) count++; } return res; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-438/","tags":["leetcode","string"],"title":"Leetcode-438. Find All Anagrams in a String"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; public List\u0026lt;Integer\u0026gt; findDuplicates(int[] nums) { List\u0026lt;Integer\u0026gt; res = new ArrayList(); // 用于存储重复元素的结果列表 for (int i = 0; i \u0026lt; nums.length; i++) { int index = Math.abs(nums[i]) - 1; // 计算当前元素在数组中应该出现的位置 if (nums[index] \u0026lt; 0) { res.add(index + 1); // 如果该位置的元素已经是负数，说明之前出现过，将其加入结果列表 } nums[index] = -nums[index]; // 将该位置的元素变为负数，表示已经出现过一次 } return res; // 返回重复元素的列表 } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-442/","tags":["leetcode","string"],"title":"Leetcode-442. Find All Duplicates in an Array"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; class Solution { public List\u0026lt;Integer\u0026gt; spiralOrder(int[][] matrix) { List\u0026lt;Integer\u0026gt; res = new ArrayList(); if(matrix.length==0) return res; int rowBegin = 0; int rowEnd = matrix.length-1; int columnBegin = 0; int columnEnd = matrix[0].length-1; while(rowBegin \u0026lt;= rowEnd \u0026amp;\u0026amp; columnBegin \u0026lt;= columnEnd){ for(int i =columnBegin; i\u0026lt;= columnEnd; i++){ res.add(matrix[rowBegin][i]); } rowBegin++; for(int i =rowBegin; i\u0026lt;=rowEnd; i++){ res.add(matrix[i][columnEnd]); } columnEnd--; if(rowBegin \u0026lt;= rowEnd){ for(int i= columnEnd; i\u0026gt;=columnBegin; i--){ res.add(matrix[rowEnd][i]); } rowEnd--; } if(columnBegin\u0026lt;=columnEnd){ for(int i=rowEnd; i\u0026gt;=rowBegin; i--){ res.add(matrix[i][columnBegin]); } columnBegin++; } } return res; } } Time: O(mn) Space: O(mn)\n","permalink":"https://pattysung1.github.io/works/leetcode-54/","tags":["leetcode","string"],"title":"Leetcode-54. Spiral Matrix"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; class Solution { public int leastInterval(char[] tasks, int n) { int[] char_map = new int[26]; for(char c: tasks){ char_map[c-\u0026#39;A\u0026#39;]++; } Arrays.sort(char_map); int max_val = char_map[25]-1; int idle_slots = max_val * n; for(int i=24; i\u0026gt;=0; i--){ idle_slots -= Math.min(char_map[i], max_val); } return idle_slots\u0026gt;0 ? idle_slots + tasks.length : tasks.length; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-621/","tags":["leetcode","string"],"title":"Leetcode-621. Task Scheduler"},{"categories":["Programming"],"contents":"You are given an integer array height of length n. There are n vertical lines drawn such that the two endpoints of the ith line are (i, 0) and (i, height[i]).\nFind two lines that together with the x-axis form a container, such that the container contains the most water.\nReturn the maximum amount of water a container can store.\nNotice that you may not slant the container.\nExample 1:\nInput: height = [1,8,6,2,5,4,8,3,7] Output: 49 Explanation: The above vertical lines are represented by array [1,8,6,2,5,4,8,3,7]. In this case, the max area of water (blue section) the container can contain is 49. Example 2:\nInput: height = [1,1] Output: 1 \u0026lt;解題\u0026gt; class Solution { public int maxArea(int[] height) { int left = 0; int right = height.length - 1; int maxArea = 0; while (left \u0026lt; right) { int currentArea = Math.min(height[left], height[right]) * (right - left); maxArea = Math.max(maxArea, currentArea); if (height[left] \u0026lt; height[right]) { left++; } else { right--; } } return maxArea; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-11/","tags":["leetcode","string"],"title":"Leetcode-11. Container With Most Water"},{"categories":["Programming"],"contents":"You are a product manager and currently leading a team to develop a new product. Unfortunately, the latest version of your product fails the quality check. Since each version is developed based on the previous version, all the versions after a bad version are also bad.\nSuppose you have n versions [1, 2, \u0026hellip;, n] and you want to find out the first bad one, which causes all the following ones to be bad.\nYou are given an API bool isBadVersion(version) which returns whether version is bad. Implement a function to find the first bad version. You should minimize the number of calls to the API.\nExample 1:\nInput: n = 5, bad = 4 Output: 4 Explanation: call isBadVersion(3) -\u0026gt; false call isBadVersion(5) -\u0026gt; true call isBadVersion(4) -\u0026gt; true Then 4 is the first bad version. Example 2:\nInput: n = 1, bad = 1 Output: 1 \u0026lt;解題\u0026gt; /* The isBadVersion API is defined in the parent class VersionControl. boolean isBadVersion(int version); */ public class Solution extends VersionControl { public int firstBadVersion(int n) { int low = 0; int high = n; while(low\u0026lt;=high){ int mid = low+ (high-low)/2; if(isBadVersion(mid)==true \u0026amp;\u0026amp; isBadVersion(mid-1)==false){ return mid; } else if(isBadVersion(mid)==false){ low = mid+1; } else{ high = mid; } } return -1; } } Time: O(logn) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-278/","tags":["leetcode","string"],"title":"Leetcode-278. First Bad Version"},{"categories":["Programming"],"contents":"Given a string s which consists of lowercase or uppercase letters, return the length of the longest palindrome that can be built with those letters.\nLetters are case sensitive, for example, \u0026ldquo;Aa\u0026rdquo; is not considered a palindrome here.\nExample 1:\nInput: s = \u0026#34;abccccdd\u0026#34; Output: 7 Explanation: One longest palindrome that can be built is \u0026#34;dccaccd\u0026#34;, whose length is 7. Example 2:\nInput: s = \u0026#34;a\u0026#34; Output: 1 Explanation: The longest palindrome that can be built is \u0026#34;a\u0026#34;, whose length is 1. \u0026lt;解題\u0026gt; class Solution { public int longestPalindrome(String s) { int[] count = new int[128]; for (char c: s.toCharArray()) count[c]++; int oddCount = -1; for (int v: count) { if (v % 2 != 0) oddCount++; } return (oddCount \u0026gt; 0) ? s.length() - oddCount: s.length(); } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-409/","tags":["leetcode","string"],"title":"Leetcode-409. Longest Palindrome"},{"categories":["Programming"],"contents":"An image is represented by an m x n integer grid image where image[i][j] represents the pixel value of the image.\nYou are also given three integers sr, sc, and color. You should perform a flood fill on the image starting from the pixel image[sr][sc].\nTo perform a flood fill, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color), and so on. Replace the color of all of the aforementioned pixels with color.\nReturn the modified image after performing the flood fill.\nExample 1:\nInput: image = [[1,1,1],[1,1,0],[1,0,1]], sr = 1, sc = 1, color = 2 Output: [[2,2,2],[2,2,0],[2,0,1]] Explanation: From the center of the image with position (sr, sc) = (1, 1) (i.e., the red pixel), all pixels connected by a path of the same color as the starting pixel (i.e., the blue pixels) are colored with the new color. Note the bottom corner is not colored 2, because it is not 4-directionally connected to the starting pixel. Example 2:\nInput: image = [[0,0,0],[0,0,0]], sr = 0, sc = 0, color = 0 Output: [[0,0,0],[0,0,0]] Explanation: The starting pixel is already colored 0, so no changes are made to the image. \u0026lt;解題\u0026gt; class Solution { public int[][] floodFill(int[][] image, int sr, int sc, int color) { if(image[sr][sc]==color) return image; fill(image, sr, sc, image[sr][sc], color); return image; } public void fill(int[][] image, int sr, int sc, int color, int newColor){ if(sr\u0026lt;0 || sc\u0026lt;0|| sr \u0026gt;= image.length || sc \u0026gt;= image[0].length || image[sr][sc]!=color) return; image[sr][sc] = newColor; fill(image, sr-1, sc, color, newColor); fill(image, sr+1, sc, color, newColor); fill(image, sr, sc-1, color, newColor); fill(image, sr, sc+1, color, newColor); } } Time: O(nm) Space: O(nm)\n","permalink":"https://pattysung1.github.io/works/leetcode-733/","tags":["leetcode","string"],"title":"Leetcode-733. Flood Fill"},{"categories":["Programming"],"contents":"A phrase is a palindrome if, after converting all uppercase letters into lowercase letters and removing all non-alphanumeric characters, it reads the same forward and backward. Alphanumeric characters include letters and numbers.\nGiven a string s, return true if it is a palindrome, or false otherwise.\nExample 1:\nInput: s = \u0026#34;A man, a plan, a canal: Panama\u0026#34; Output: true Explanation: \u0026#34;amanaplanacanalpanama\u0026#34; is a palindrome. Example 2:\nInput: s = \u0026#34;race a car\u0026#34; Output: false Explanation: \u0026#34;raceacar\u0026#34; is not a palindrome. Example 3:\nInput: s = \u0026#34; \u0026#34; Output: true Explanation: s is an empty string \u0026#34;\u0026#34; after removing non-alphanumeric characters. Since an empty string reads the same forward and backward, it is a palindrome. \u0026lt;解題\u0026gt; class Solution { public boolean isPalindrome(String s) { if (s.isEmpty()) { return true; } int start = 0; int last = s.length() - 1; while(start \u0026lt;= last) { char currFirst = s.charAt(start); char currLast = s.charAt(last); if (!Character.isLetterOrDigit(currFirst )) { start++; } else if(!Character.isLetterOrDigit(currLast)) { last--; } else { if (Character.toLowerCase(currFirst) != Character.toLowerCase(currLast)) { return false; } start++; last--; } } return true; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-125/","tags":["leetcode","string"],"title":"Leetcode-125. Valid Palindrome"},{"categories":["Programming"],"contents":"Given an unsorted array of integers nums, return the length of the longest consecutive elements sequence.\nYou must write an algorithm that runs in O(n) time.\nExample 1:\nInput: nums = [100,4,200,1,3,2] Output: 4 Explanation: The longest consecutive elements sequence is [1, 2, 3, 4]. Therefore its length is 4. Example 2:\nInput: nums = [0,3,7,2,5,8,4,6,0,1] Output: 9 \u0026lt;解題\u0026gt; 使用 HashSet 存儲陣列中的所有元素 檢查它是否是一個連續序列的起點(即是否不存在比它小 1 的元素) 如果是起點，則從這個起點開始向後查找(set.contains(currentNum))，計算連續序列的長度。 更新最大長度，保留當前找到的最大連續序列長度 class Solution { public int longestConsecutive(int[] nums) { HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int num : nums){ set.add(num); } int maxCount = 0; for (int num : nums){ int currentNum = num; int currSequence = 1; if (!set.contains(num - 1)){ while (set.contains(currentNum + 1)){ currentNum++; currSequence++; } } maxCount = Math.max(maxCount, currSequence); } return maxCount; } } Time: O(n) Space: O(n)\nclass Solution { public int longestConsecutive(int[] nums) { if(nums.length==0) return 0; Arrays.sort(nums); //[1,2,3,3,4,100,200] int maxCount = 1; int currentCount=1; for(int i =1 ; i\u0026lt; nums.length; i++){ if(nums[i]-nums[i-1]==1){ currentCount++; } else if (nums[i]!= nums[i-1]){ currentCount =1; } if(currentCount \u0026gt; maxCount){ maxCount = currentCount; } } return maxCount; } } Time: O(nlog(n)) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-128/","tags":["leetcode","string"],"title":"Leetcode-128. Longest Consecutive Sequence"},{"categories":["Programming"],"contents":"Given an array nums with n objects colored red, white, or blue, sort them in-place so that objects of the same color are adjacent, with the colors in the order red, white, and blue.\nWe will use the integers 0, 1, and 2 to represent the color red, white, and blue, respectively.\nYou must solve this problem without using the library\u0026rsquo;s sort function.\nExample 1:\nInput: nums = [2,0,2,1,1,0] Output: [0,0,1,1,2,2] Example 2:\nInput: nums = [2,0,1] Output: [0,1,2]\n\u0026lt;解題\u0026gt; class Solution { public void sortColors(int[] nums) { if (nums.length == 0 || nums.length ==1) return; int n = nums.length; int lo = 0, hi = n-1; for (int i = 0; i \u0026lt;= hi ; i++){ if(nums[i] == 2){ swap(nums, i, hi); hi--; i--; } else if(nums[i] == 0){ swap(nums, i, lo); lo++; } } } private void swap(int[] nums, int i, int j){ int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; } } class Solution { public void sortColors(int[] nums) { if(nums.length==0 || nums.length==1) return; int start = 0; int end = nums.length-1; int index = 0; while(index \u0026lt;= end \u0026amp;\u0026amp; start \u0026lt; end){ if(nums[index]==0){ nums[index] = nums[start]; nums[start]=0; start++; index++; } else if(nums[index]==2){ nums[index] = nums[end]; nums[end] = 2; end--; } else{ index++; } } } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-75/","tags":["leetcode","array"],"title":"Leetcode-75. Sort Colors"},{"categories":["Programming"],"contents":"Given an m x n matrix of distinct numbers, return all lucky numbers in the matrix in any order.\nA lucky number is an element of the matrix such that it is the minimum element in its row and maximum in its column.\nExample 1:\nInput: matrix = [[3,7,8],[9,11,13],[15,16,17]] Output: [15] Explanation: 15 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 2:\nInput: matrix = [[1,10,4,2],[9,3,8,7],[15,16,17,12]] Output: [12] Explanation: 12 is the only lucky number since it is the minimum in its row and the maximum in its column. Example 3:\nInput: matrix = [[7,8],[1,2]] Output: [7] Explanation: 7 is the only lucky number since it is the minimum in its row and the maximum in its column.\n\u0026lt;解題\u0026gt; class Solution { public List\u0026lt;Integer\u0026gt; luckyNumbers (int[][] matrix) { int n = matrix.length; int m = matrix[0].length; List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for(int i =0; i\u0026lt;n; i++){ int num = Integer.MAX_VALUE; int index= -1; for(int j=0; j\u0026lt;m; j++){ if(matrix[i][j] \u0026lt; num){ num = matrix[i][j]; index=j; } } boolean flag = true; for(int row=0; row\u0026lt;n; row++){ if(matrix[row][index]\u0026gt;num){ flag = false; } } if(flag){ res.add(num); } } return res; } } Time: O(n*m) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-1380/","tags":["leetcode","string"],"title":"Leetcode-1380. Lucky Numbers in a Matrix"},{"categories":["Programming"],"contents":"Given a string s, return the longest palindromic\nsubstring in s.\nExample 1:\nInput: s = \u0026ldquo;babad\u0026rdquo; Output: \u0026ldquo;bab\u0026rdquo; Explanation: \u0026ldquo;aba\u0026rdquo; is also a valid answer. Example 2:\nInput: s = \u0026ldquo;cbbd\u0026rdquo; Output: \u0026ldquo;bb\u0026rdquo;\n\u0026lt;解題\u0026gt; class Solution { int maxLen = 0; //儲存最長迴文子字串的長度 int lo = 0; //儲存最長迴文子字串的起始索引 public String longestPalindrome(String s) { char[] input = s.toCharArray(); if(s.length() \u0026lt; 2) { return s; } for(int i = 0; i\u0026lt;input.length; i++) { expandPalindrome(input, i, i); expandPalindrome(input, i, i+1); } return s.substring(lo, lo+maxLen); } public void expandPalindrome(char[] s, int j, int k) { while(j \u0026gt;= 0 \u0026amp;\u0026amp; k \u0026lt; s.length \u0026amp;\u0026amp; s[j] == s[k]) { j--; k++; } if(maxLen \u0026lt; k - j - 1) { //迴文子字串的長度是 k - j - 1 maxLen = k - j - 1; lo = j+1; } } } Time: O(n^2) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-5/","tags":["leetcode","string"],"title":"Leetcode-5. Longest Palindromic Substring"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; class Solution { public int triangleNumber(int[] nums) { if (nums.length \u0026lt; 3) { return 0; } Arrays.sort(nums); int count = 0; for (int i = 0; i \u0026lt; nums.length - 2; i++) { int k = i + 2; for (int j = i + 1; j \u0026lt; nums.length - 1 \u0026amp;\u0026amp; nums[i] != 0; j++) { while (k \u0026lt; nums.length \u0026amp;\u0026amp; nums[i] + nums[j] \u0026gt; nums[k]) { k++; } count += k - j - 1; //超出的(k-1)-j } } return count; } } Time: O(n^2) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-611/","tags":["leetcode","string"],"title":"Leetcode-611. Valid Triangle Number"},{"categories":["Programming"],"contents":"Given a string s, return the number of palindromic substrings in it.\nA string is a palindrome when it reads the same backward as forward.\nA substring is a contiguous sequence of characters within the string.\nExample 1:\nInput: s = \u0026ldquo;abc\u0026rdquo; Output: 3 Explanation: Three palindromic strings: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;b\u0026rdquo;, \u0026ldquo;c\u0026rdquo;. Example 2:\nInput: s = \u0026ldquo;aaa\u0026rdquo; Output: 6 Explanation: Six palindromic strings: \u0026ldquo;a\u0026rdquo;, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;a\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aa\u0026rdquo;, \u0026ldquo;aaa\u0026rdquo;.\n\u0026lt;解題\u0026gt; 由中間出發往兩側搜尋是否為回文-\u0026gt;奇數長度(中間為相同) ex: cbc -\u0026gt;偶數長度(中間兩個為相同) ex: cbbc 往兩側拓展至一方over boundary，當中分別計算回文的數量 class Solution { public int countSubstrings(String s) { if(s.length()==0) return 0; int n = s.length(); int res = 0; char[] c = s.toCharArray(); for(int i =0; i\u0026lt;n; i++){ res +=isPalindromic(i,i,c); res +=isPalindromic(i,i+1,c); } return res; } public int isPalindromic(int s, int e, char[]c){ int count =0; while(s\u0026gt;=0 \u0026amp;\u0026amp; e \u0026lt; c.length \u0026amp;\u0026amp; c[s--]==c[e++]){ count++; } return count; } } Time: O() Space: O()\n","permalink":"https://pattysung1.github.io/works/leetcode-647/","tags":["leetcode","string"],"title":"Leetcode-647. Palindromic Substrings"},{"categories":["Programming"],"contents":"A message containing letters from A-Z can be encoded into numbers using the following mapping:\n\u0026lsquo;A\u0026rsquo; -\u0026gt; \u0026ldquo;1\u0026rdquo; \u0026lsquo;B\u0026rsquo; -\u0026gt; \u0026ldquo;2\u0026rdquo; \u0026hellip; \u0026lsquo;Z\u0026rsquo; -\u0026gt; \u0026ldquo;26\u0026rdquo; To decode an encoded message, all the digits must be grouped then mapped back into letters using the reverse of the mapping above (there may be multiple ways). For example, \u0026ldquo;11106\u0026rdquo; can be mapped into:\n\u0026ldquo;AAJF\u0026rdquo; with the grouping (1 1 10 6) \u0026ldquo;KJF\u0026rdquo; with the grouping (11 10 6) Note that the grouping (1 11 06) is invalid because \u0026ldquo;06\u0026rdquo; cannot be mapped into \u0026lsquo;F\u0026rsquo; since \u0026ldquo;6\u0026rdquo; is different from \u0026ldquo;06\u0026rdquo;.\nGiven a string s containing only digits, return the number of ways to decode it.\nThe test cases are generated so that the answer fits in a 32-bit integer.\nExample 1:\nInput: s = \u0026ldquo;12\u0026rdquo; Output: 2 Explanation: \u0026ldquo;12\u0026rdquo; could be decoded as \u0026ldquo;AB\u0026rdquo; (1 2) or \u0026ldquo;L\u0026rdquo; (12). Example 2:\nInput: s = \u0026ldquo;226\u0026rdquo; Output: 3 Explanation: \u0026ldquo;226\u0026rdquo; could be decoded as \u0026ldquo;BZ\u0026rdquo; (2 26), \u0026ldquo;VF\u0026rdquo; (22 6), or \u0026ldquo;BBF\u0026rdquo; (2 2 6). Example 3:\nInput: s = \u0026ldquo;06\u0026rdquo; Output: 0 Explanation: \u0026ldquo;06\u0026rdquo; cannot be mapped to \u0026ldquo;F\u0026rdquo; because of the leading zero (\u0026ldquo;6\u0026rdquo; is different from \u0026ldquo;06\u0026rdquo;).\n\u0026lt;解題\u0026gt; public class Solution { public int numDecodings(String s) { if (s == null || s.length() == 0) { return 0; } int n = s.length(); int[] dp = new int[n + 1]; dp[0] = 1; dp[1] = s.charAt(0) != \u0026#39;0\u0026#39; ? 1 : 0; for (int i = 2; i \u0026lt;= n; i++) { int first = Integer.valueOf(s.substring(i - 1, i)); int second = Integer.valueOf(s.substring(i - 2, i)); if (first \u0026gt;= 1 \u0026amp;\u0026amp; first \u0026lt;= 9) { dp[i] += dp[i-1]; } if (second \u0026gt;= 10 \u0026amp;\u0026amp; second \u0026lt;= 26) { dp[i] += dp[i-2]; } } return dp[n]; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-91/","tags":["leetcode","string"],"title":"Leetcode-91. Decode Ways"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; public class Main { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); String inputStr = scanner.next(); String result = findPalindromeSubstring(inputStr); System.out.println(result); } public static String findPalindromeSubstring(String inputStr) { int maxLength = 0; String longestPalindrome = \u0026#34;\u0026#34;; for (int i = 0; i \u0026lt; inputStr.length(); i++) { // 奇數長度的迴文，以 i 為中心 String palindromeOdd = expandAroundCenter(inputStr, i, i); if (palindromeOdd.length() \u0026gt; maxLength) { maxLength = palindromeOdd.length(); longestPalindrome = palindromeOdd; } // 偶數長度的迴文，以 i 和 i+1 為中心 String palindromeEven = expandAroundCenter(inputStr, i, i + 1); if (palindromeEven.length() \u0026gt; maxLength) { maxLength = palindromeEven.length(); longestPalindrome = palindromeEven; } } return maxLength \u0026gt; 1 ? longestPalindrome : \u0026#34;None\u0026#34;; } public static String expandAroundCenter(String str, int left, int right) { while (left \u0026gt;= 0 \u0026amp;\u0026amp; right \u0026lt; str.length() \u0026amp;\u0026amp; str.charAt(left) == str.charAt(right)) { left--; right++; } return str.substring(left + 1, right); //從 left 的下一個位置開始，到 right 位置之前（不包含 right 位置），所對應的字串，即為最終的迴文子字串 } } Time: O(n^2) Space: O(n^2)\n","permalink":"https://pattysung1.github.io/works/%E6%9C%80%E5%A4%A7%E5%9B%9E%E6%96%87%E5%AD%97%E4%B8%B2/","tags":["leetcode","string"],"title":"Leetcode-最大回文字串"},{"categories":["Programming"],"contents":"Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.\nExample 1:\nInput: intervals = [[1,3],[2,6],[8,10],[15,18]] Output: [[1,6],[8,10],[15,18]] Explanation: Since intervals [1,3] and [2,6] overlap, merge them into [1,6]. Example 2:\nInput: intervals = [[1,4],[4,5]] Output: [[1,5]] Explanation: Intervals [1,4] and [4,5] are considered overlapping.\n\u0026lt;解題\u0026gt; class Solution { public int[][] merge(int[][] intervals) { if(intervals == null || intervals.length\u0026lt;=1){ return intervals; } Arrays.sort(intervals, (arr1,arr2)-\u0026gt;Integer.compare(arr1[0],arr2[0])); List\u0026lt;int[]\u0026gt; output_arr = new ArrayList(); int[] current_interval = intervals[0]; output_arr.add(current_interval); for(int[] interval : intervals){ int current_begin = current_interval[0]; int current_end = current_interval[1]; int next_begin = interval[0]; int next_end = interval[1]; if(current_end \u0026gt;= next_begin){ current_interval[1] = Math.max(current_end, next_end); } else{ current_interval = interval; output_arr.add(current_interval); } } return output_arr.toArray(new int[output_arr.size()][]); } } Time: O(n log n) -\u0026gt; 快速排序的平均時間複雜度為 O(n log n) Space: O(n)\nthe Arrays.sort function is used to sort the intervals array using quicksort. The average time complexity of quicksort is O(n log n), where n is the number of intervals. the code iterates through the sorted array of intervals once to perform the merging operation. The operations performed during this traversal are linear, so the time complexity is O(n). length vs size() 在Java中，.length 和 .size() 是用來獲取集合（陣列、ArrayList等）的大小或元素個數的方式，但它們的使用情境不同，取決於你正在處理的數據結構。\n.length：\n.length 是一個數組的屬性，用於獲取數組的長度，也就是數組中元素的個數。 它通常用於原生數組（例如 int[]、double[]）或多維數組，因為這些數組具有固定的大小，無法改變。 例如，int[] arr = new int[5]; int length = arr.length; 用於獲取數組 arr 的長度，此處 length 將為5。 .size()：\n.size() 是用於獲取集合類（例如ArrayList、List等）的方法，用於獲取集合中元素的個數。 它通常用於集合類，因為這些類可以根據需要動態調整大小，所以 .size() 返回的是當前集合中的元素個數。 例如，ArrayList list = new ArrayList\u0026lt;\u0026gt;(); int size = list.size(); 用於獲取ArrayList list 中元素的個數，此處 size 將一開始為0。\n","permalink":"https://pattysung1.github.io/works/leetcode-56/","tags":["leetcode","string"],"title":"Leetcode-56. Merge Intervals"},{"categories":["Programming"],"contents":"You are given an array of non-overlapping intervals intervals where intervals[i] = [starti, endi] represent the start and the end of the ith interval and intervals is sorted in ascending order by starti. You are also given an interval newInterval = [start, end] that represents the start and end of another interval.\nInsert newInterval into intervals such that intervals is still sorted in ascending order by starti and intervals still does not have any overlapping intervals (merge overlapping intervals if necessary).\nReturn intervals after the insertion.\nExample 1:\nInput: intervals = [[1,3],[6,9]], newInterval = [2,5] Output: [[1,5],[6,9]] Example 2:\nInput: intervals = [[1,2],[3,5],[6,7],[8,10],[12,16]], newInterval = [4,8] Output: [[1,2],[3,10],[12,16]] Explanation: Because the new interval [4,8] overlaps with [3,5],[6,7],[8,10].\n\u0026lt;解題\u0026gt; class Solution { public int[][] insert(int[][] intervals, int[] newInterval) { List\u0026lt;int[]\u0026gt; result = new ArrayList(); int i =0, n = intervals.length; //合併沒重疊前 while(i\u0026lt;n \u0026amp;\u0026amp; intervals[i][1] \u0026lt; newInterval[0]){ result.add(intervals[i]); i++; } //合併重疊 while(i\u0026lt;n \u0026amp;\u0026amp; intervals[i][0] \u0026lt;= newInterval[1]){ newInterval[0] = Math.min(intervals[i][0], newInterval[0]); newInterval[1] = Math.max(intervals[i][1], newInterval[1]); i++; } result.add(newInterval); //合併重疊的後面 while(i\u0026lt;n){ result.add(intervals[i]); i++; } return result.toArray(new int[result.size()][]); } } Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-57/","tags":["leetcode","string"],"title":"Leetcode-57. Insert Interval"},{"categories":["Programming"],"contents":"Given an integer array nums, return all the triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.\nNotice that the solution set must not contain duplicate triplets.\nExample 1:\nInput: nums = [-1,0,1,2,-1,-4] Output: [[-1,-1,2],[-1,0,1]] Explanation: nums[0] + nums[1] + nums[2] = (-1) + 0 + 1 = 0. nums[1] + nums[2] + nums[4] = 0 + 1 + (-1) = 0. nums[0] + nums[3] + nums[4] = (-1) + 2 + (-1) = 0. The distinct triplets are [-1,0,1] and [-1,-1,2]. Notice that the order of the output and the order of the triplets does not matter. Example 2:\nInput: nums = [0,1,1] Output: [] Explanation: The only possible triplet does not sum up to 0. Example 3:\nInput: nums = [0,0,0] Output: [[0,0,0]] Explanation: The only possible triplet sums up to 0.\n\u0026lt;解題\u0026gt; class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; threeSum(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); // nums = [-4,-1,-1,0,1,2] for (int i = 0; i \u0026lt; nums.length - 2; i++) { // Skip duplicate elements for i if (i \u0026gt; 0 \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } int j = i + 1; int k = nums.length - 1; while (j \u0026lt; k) { int sum = nums[i] + nums[j] + nums[k]; if (sum == 0) { // Found a triplet with zero sum ans.add(Arrays.asList(nums[i], nums[j], nums[k])); // Skip duplicate elements for j while (j \u0026lt; k \u0026amp;\u0026amp; nums[j] == nums[j + 1]) { j++; } // Skip duplicate elements for k while (j \u0026lt; k \u0026amp;\u0026amp; nums[k] == nums[k - 1]) { k--; } // Move the pointers j++; k--; } else if (sum \u0026lt; 0) { // Sum is less than zero, increment j to increase the sum j++; } else { // Sum is greater than zero, decrement k to decrease the sum k--; } } } return ans; } } Time: O(n^2)\n數組排序O(n log n) 外層O(n)、內層：雙指針O(n)-\u0026gt;)(n^2) -\u0026gt; 即 O(n log n) + O(n) * O(n) = O(n^2) Space: O(n^2) ","permalink":"https://pattysung1.github.io/works/leetcode-15/","tags":["leetcode","string"],"title":"Leetcode-15. 3Sum"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; public class Main { public static void main(String[] args) { Solution solution = new Solution(); String string = \u0026#34;pineappleTREE\u0026#34;; //預期輸出pineaqpleUREE System.out.println(solution.replaceNextCharacter(string,3)); } } class Solution { public String replaceNextCharacter(String string, Integer n) { if (string == null || string.length() == 0) return null; String result = \u0026#34;\u0026#34;; int nonVowelCount = 0; // 非母音字母數 for (int i = 0; i \u0026lt; string.length(); i++) { char currentChar = string.charAt(i); if (\u0026#34;aeiouAEIOU\u0026#34;.indexOf(currentChar) \u0026gt;= 0) { // 使用indexOf判斷是否為母音 int index = \u0026#34;aeiouAEIOU\u0026#34;.indexOf(currentChar); result += currentChar; } else { nonVowelCount++; if (nonVowelCount % n == 0) { if (currentChar \u0026gt;= \u0026#39;a\u0026#39; \u0026amp;\u0026amp; currentChar \u0026lt;= \u0026#39;z\u0026#39;) { if (currentChar == \u0026#39;z\u0026#39;) { result += \u0026#39;a\u0026#39;; } else { result += (char) (currentChar + 1); } } else if (currentChar \u0026gt;= \u0026#39;A\u0026#39; \u0026amp;\u0026amp; currentChar \u0026lt;= \u0026#39;Z\u0026#39;) { if (currentChar == \u0026#39;Z\u0026#39;) { result += \u0026#39;A\u0026#39;; } else { result += (char) (currentChar + 1); } } else { result += currentChar; //非字母 } } else { result += currentChar; } } } return result; } } ","permalink":"https://pattysung1.github.io/works/nextchar/","tags":["leetcode","string"],"title":"字母替換成下一個字母"},{"categories":["Programming"],"contents":"\n資料來源：https://blog.csdn.net/q5706503/article/details/85122343\n","permalink":"https://pattysung1.github.io/works/hashmap/","tags":["leetcode","string"],"title":"HashMap用法筆記"},{"categories":["Programming"],"contents":"Given an array nums of size n, return the majority element.\nThe majority element is the element that appears more than ⌊n / 2⌋ times. You may assume that the majority element always exists in the array.\nExample 1:\nInput: nums = [3,2,3] Output: 3 Example 2:\nInput: nums = [2,2,1,1,1,2,2] Output: 2\n\u0026lt;解題\u0026gt;1. sorting class Solution { public int majorityElement(int[] nums) { Arrays.sort(nums); int n = nums.length; return nums[n/2]; } } T: O(n log n)\n\u0026lt;解題\u0026gt;2. HashMap class Solution { public int majorityElement(int[] nums) { int n = nums.length; Map\u0026lt;Integer, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; n; i++) { map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); } n = n / 2; for (Map.Entry\u0026lt;Integer, Integer\u0026gt; entry : map.entrySet()) { if (entry.getValue() \u0026gt; n) { return entry.getKey(); } } return 0; } } Time: O(n) Space: O(n)\n\u0026lt;解題\u0026gt;3. Boyer–Moore majority vote algorithm(摩爾投票算法) 取出第一個數放到一個暫存的變數(res)，將計數器(cnt)設定為1，代表這個數出現1次。 取出下一個數nums[i]，如果和res相等，則將計數器+1； 如果和res不同，且計數器\u0026gt;0時，將計數器-1；(代表取這兩個數成對移除) 如果和res不同但是計數器=0時，將res更改為nums[i]並將計數器+1 (代表res已經用完了，現在還沒被移除的是nums[i]) 反覆進行步驟2直到陣列結尾，剩下的res即為答案。 (因為兩兩移除到最後一定是非majority element的先被移光) class Solution { public int majorityElement(int[] nums) { int ele = 0, vote =0; for(int num : nums){ if(num == ele \u0026amp;\u0026amp; vote \u0026gt; 0){ vote +=1; } else if(vote ==0){ ele = num; vote = 1; } else { vote -=1; } } return ele; } } class Solution { public int majorityElement(int[] nums) { int count = 0; int res = 0; for (int num : nums) { if (count == 0) { res = num; } if (num == res) { count++; } else { count--; } } return res; } } Time: O(nlogn) Space: O(n)\n兩種寫法： for(int i=0; i\u0026lt;nums.length ; i++){ if(map.containsKey(nums[i])){ map.put(nums[i], map.get(nums[i]) + 1); else{ map.put(nums[i], 1); } } 相同\nfor (int i = 0; i \u0026lt; n; i++) { map.put(nums[i], map.getOrDefault(nums[i], 0) + 1); } ","permalink":"https://pattysung1.github.io/works/leetcode-169/","tags":["leetcode","string"],"title":"Leetcode-169. Majority Element"},{"categories":["Programming"],"contents":"Given an integer array nums, find the subarray with the largest sum, and return its sum.\nExample 1:\nInput: nums = [-2,1,-3,4,-1,2,1,-5,4] Output: 6 Explanation: The subarray [4,-1,2,1] has the largest sum 6. Example 2:\nInput: nums = [1] Output: 1 Explanation: The subarray [1] has the largest sum 1. Example 3:\nInput: nums = [5,4,-1,7,8] Output: 23 Explanation: The subarray [5,4,-1,7,8] has the largest sum 23.\n\u0026lt;解題\u0026gt; 將 currentSum 設置為 nums[i] 和 currentSum + nums[i] 中的較大值。這樣做的原因是，我們要判斷是要將當前元素納入子數組，還是重新開始一個新的子數組。 同時，將 maxSum 設置為 maxSum 和 currentSum 中的較大值。這是為了確保我們總是在整個過程中保留最大的子數組和。 class Solution { public int maxSubArray(int[] nums) { int maxSum = nums[0]; int currentSum = nums[0]; for (int i = 1; i \u0026lt; nums.length; i++) { currentSum = Math.max(nums[i], currentSum + nums[i]); maxSum = Math.max(maxSum, currentSum); } return maxSum; } } Time: O() Space: O()\n","permalink":"https://pattysung1.github.io/works/leetcode-53/","tags":["leetcode","string"],"title":"Leetcode-53. Maximum Subarray"},{"categories":["Programming"],"contents":"Given two integer arrays nums1 and nums2, return an array of their intersection. Each element in the result must be unique and you may return the result in any order.\nExample 1:\nInput: nums1 = [1,2,2,1], nums2 = [2,2] Output: [2] Example 2:\nInput: nums1 = [4,9,5], nums2 = [9,4,9,8,4] Output: [9,4] Explanation: [4,9] is also accepted.\n\u0026lt;解題\u0026gt; class Solution { public int[] intersection(int[] nums1, int[] nums2) { HashSet\u0026lt;Integer\u0026gt; s1=new HashSet\u0026lt;\u0026gt;(); HashSet\u0026lt;Integer\u0026gt; s2=new HashSet\u0026lt;\u0026gt;(); for(int i=0;i\u0026lt;nums1.length;i++){ s1.add(nums1[i]); } for(int i=0;i\u0026lt;nums2.length;i++){ s2.add(nums2[i]); } ArrayList\u0026lt;Integer\u0026gt; l=new ArrayList\u0026lt;\u0026gt;(); for(int i:s1){ if(s2.contains(i)){ l.add(i); } } int r=l.size(); int[] arr=new int[r]; for(int i=0;i\u0026lt;r;i++){ arr[i]=l.get(i); } return arr; } } Time: O(n1 + n2 + r) Space: O(n1 + n2 + r)\n","permalink":"https://pattysung1.github.io/works/leetcode-349/","tags":["leetcode","string"],"title":"Leetcode-349. Intersection of Two Arrays"},{"categories":["Programming"],"contents":"Given an integer array nums and an integer k, return the k most frequent elements. You may return the answer in any order.\nExample 1:\nInput: nums = [1,1,1,2,2,3], k = 2 Output: [1,2] Example 2:\nInput: nums = [1], k = 1 Output: [1] \u0026lt;解題\u0026gt; class Solution { public int[] topKFrequent(int[] nums, int k) { Map\u0026lt;Integer, Integer\u0026gt; count = new HashMap\u0026lt;\u0026gt;(); List\u0026lt;Integer\u0026gt; bucket[] = new ArrayList[nums.length + 1]; //建立頻率 for (int num : nums) count.merge(num, 1, Integer::sum); //代表著我們希望將兩個值相加，用於更新元素出現的次數。當 merge 方法遇到已經存在的鍵值對時，它會將現有的值和提供的值進行操作 count= {1=3,2=2,3=1} //元素按照出現頻率放入 bucket 中 for (int key : count.keySet()){ int freq = count.get(key); //freq = 3 if (bucket[freq] == null){ bucket[freq] = new ArrayList\u0026lt;\u0026gt;(); } bucket[freq].add(key); //bucket = [0,[3],[2],[1],0,0,0] } int index = 0; int[] res = new int[k]; //res = [0,0] for (int i = nums.length; i \u0026gt;= 0; i--) if (bucket[i] != null) //bucket[3] for (int val : bucket[i]){ // res[index++] = val; //index+1 表示已經填入了一個元素 [1,2] if(index == k) return res; } return res; } } Time: O(n) Space: O(n)\nmerge用法 前面merge的寫法，可改寫成如下：\ncount.getOrDefault(num, 0) + 1: 使用 getOrDefault 方法來取得 num 鍵對應的值，如果鍵不存在，則使用預設值 0。然後將這個值加 1，以計算元素的出現次數\ncount.put(num, \u0026hellip; ): 使用 put 方法將新的計數值放入 count Map 中，這樣就更新了元素的出現次數。\nMap\u0026lt;Integer, Integer\u0026gt; count = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { count.put(num, count.getOrDefault(num, 0) + 1); } ","permalink":"https://pattysung1.github.io/works/leetcode-347/","tags":["leetcode","string"],"title":"Leetcode-347. Top K Frequent Elements"},{"categories":["Programming"],"contents":"Given an encoded string, return its decoded string.\nThe encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times. Note that k is guaranteed to be a positive integer.\nYou may assume that the input string is always valid; there are no extra white spaces, square brackets are well-formed, etc. Furthermore, you may assume that the original data does not contain any digits and that digits are only for those repeat numbers, k. For example, there will not be input like 3a or 2[4].\nThe test cases are generated so that the length of the output will never exceed 105.\nExample 1:\nInput: s = \u0026#34;3[a]2[bc]\u0026#34; Output: \u0026#34;aaabcbc\u0026#34; Example 2:\nInput: s = \u0026#34;3[a2[c]]\u0026#34; Output: \u0026#34;accaccacc\u0026#34; Example 3:\nInput: s = \u0026#34;2[abc]3[cd]ef\u0026#34; Output: \u0026#34;abcabccdcdcdef\u0026#34; \u0026lt;解題\u0026gt; 用stack來儲存counts(數字)及result(處理重複字串)，最後回傳res(字串) class Solution { public String decodeString(String s) { Stack\u0026lt;Integer\u0026gt; counts = new Stack(); Stack\u0026lt;String\u0026gt; result = new Stack(); String res = \u0026#34;\u0026#34;; int index = 0; while(index \u0026lt; s.length()){ if(Character.isDigit(s.charAt(index))){ int count = 0; while(Character.isDigit(s.charAt(index))){ count = 10 * count + (s.charAt(index) - \u0026#39;0\u0026#39;); index += 1; } counts.push(count); } else if(s.charAt(index) == \u0026#39;[\u0026#39;){ result.push(res); res = \u0026#34;\u0026#34;; index += 1; } else if(s.charAt(index) == \u0026#39;]\u0026#39;){ StringBuilder temp = new StringBuilder(result.pop()); int count = counts.pop(); for(int i = 0; i\u0026lt;count ; i++){ temp.append(res); } res = temp.toString(); index += 1; } else{ //字串 res += s.charAt(index); index += 1; } } return res; } } Time: O(n) Space: O(n)\nclass Solution { public String decodeString(String s) { int index = 0; StringBuilder result = new StringBuilder(); while (index \u0026lt; s.length()) { if (Character.isDigit(s.charAt(index))) { int count = 0; while (Character.isDigit(s.charAt(index))) { count = 10 * count + (s.charAt(index) - \u0026#39;0\u0026#39;); index++; } index++; // 跳過 \u0026#39;[\u0026#39; int startIndex = index; int endIndex = findClosingBracket(s, startIndex); String subString = decodeString(s.substring(startIndex, endIndex)); //包含前不包含後 for (int i = 0; i \u0026lt; count; i++) { result.append(subString); } index = endIndex + 1; // 跳過 subString 和 \u0026#39;]\u0026#39; } else { result.append(s.charAt(index)); index++; } } return result.toString(); } private int findClosingBracket(String s, int startIndex) { int count = 1; // 跳過第一個 \u0026#39;[\u0026#39;，所以初始化為 1 int index = startIndex; while (count \u0026gt; 0) { char c = s.charAt(index); if (c == \u0026#39;[\u0026#39;) { count++; } else if (c == \u0026#39;]\u0026#39;) { count--; } index++; } return index - 1; } } ","permalink":"https://pattysung1.github.io/works/leetcode-394/","tags":["leetcode","string"],"title":"Leetcode-394. Decode String"},{"categories":["Programming"],"contents":"Given two strings s1 and s2, return true if s2 contains a permutation of s1, or false otherwise.\nIn other words, return true if one of s1\u0026rsquo;s permutations is the substring of s2.\nExample 1:\nInput: s1 = \u0026#34;ab\u0026#34;, s2 = \u0026#34;eidbaooo\u0026#34; Output: true Explanation: s2 contains one permutation of s1 (\u0026#34;ba\u0026#34;). Example 2:\nInput: s1 = \u0026#34;ab\u0026#34;, s2 = \u0026#34;eidboaoo\u0026#34; Output: false \u0026lt;解題\u0026gt; class Solution { public boolean checkInclusion(String s1, String s2) { if(s1.length() \u0026gt; s2.length()) return false; int[] arr1 = new int[26]; int[] arr2 = new int[26]; for(int i = 0; i \u0026lt; s1.length(); i++){ arr1[s1.charAt(i) - \u0026#39;a\u0026#39;]++; arr2[s2.charAt(i) - \u0026#39;a\u0026#39;]++; } if(Arrays.equals(arr1, arr2)) return true; int front = 0; int back = s1.length(); while(back \u0026lt; s2.length()){ arr2[s2.charAt(front) - \u0026#39;a\u0026#39;]--; //每次將窗口的前一個字符排除 arr2[s2.charAt(back) - \u0026#39;a\u0026#39;]++; //每次將窗口後一個字符加入 if(Arrays.equals(arr1, arr2)) return true; front++; back++; } return false; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-567/","tags":["leetcode","string"],"title":"Leetcode-567. Permutation in String"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; class Solution { public int climbStairs(int n) { if(n==1) return 1; if(n==2) return 2; //表示有兩個台階，有兩種爬法：一次爬一個台階，或者一次爬兩個台階，直接返回 2 int[] a = new int[n]; a[0]=1; //代表爬 1 階樓梯的方法數為 1 a[1]=2; //代表爬 2 階樓梯的方法數為 2 for(int i=2;i\u0026lt;n;i++){ a[i]=a[i-1]+a[i-2]; } return a[n-1]; // 由於陣列索引是從 0 開始的，所以第 n 階樓梯的方法數對應到 a[n-1] 這個位置 } } Time: O(n) Space: O(n)\n\u0026lt;解題\u0026gt; 題目的想法，其實就是費波那契數列，只是這樣時間複雜度是O(2^n)太慢了\nclass Solution { public int climbStairs(int n) { if (n == 0 || n == 1) { return 1; } return climbStairs(n-1) + climbStairs(n-2); } } ","permalink":"https://pattysung1.github.io/works/leetcode-70/","tags":["leetcode","array"],"title":"Leetcode-70. Climbing Stairs"},{"categories":["Programming"],"contents":"\u0026lt;解題\u0026gt; 遞迴版本 計算爬到第 n 階的最小花費，即 cost[n] 加上爬到前一階和前兩階中花費較小的那個的最小花費。這是因為我們可以選擇爬到前一階或前兩階，然後再加上爬到當前階所需的花費： 遞迴關係：cost[i] += Math.min(cost[i-1], cost[i-2]); 最後return Math.min(cost[cost.length-1], cost[cost.length-2]); class Solution { public int minCostClimbingStairs(int[] cost) { for(int i = 2 ; i \u0026lt; cost.length ; i++){ cost[i] += Math.min(cost[i-1], cost[i-2]); } return Math.min(cost[cost.length-1], cost[cost.length-2]); } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-746/","tags":["leetcode","array","Dynamic Programming"],"title":"Leetcode-746. Min Cost Climbing Stairs"},{"categories":["Programming"],"contents":"Suppose an array of length n sorted in ascending order is rotated between 1 and n times. For example, the array nums = [0,1,2,4,5,6,7] might become:\n[4,5,6,7,0,1,2] if it was rotated 4 times. [0,1,2,4,5,6,7] if it was rotated 7 times. Notice that rotating an array [a[0], a[1], a[2], \u0026hellip;, a[n-1]] 1 time results in the array [a[n-1], a[0], a[1], a[2], \u0026hellip;, a[n-2]].\nGiven the sorted rotated array nums of unique elements, return the minimum element of this array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [3,4,5,1,2] Output: 1 Explanation: The original array was [1,2,3,4,5] rotated 3 times. Example 2:\nInput: nums = [4,5,6,7,0,1,2] Output: 0 Explanation: The original array was [0,1,2,4,5,6,7] and it was rotated 4 times. Example 3:\nInput: nums = [11,13,15,17] Output: 11 Explanation: The original array was [11,13,15,17] and it was rotated 4 times. \u0026lt;解題\u0026gt; 看到sorted array，可以想到用Binary search解題 if( midpoint \u0026gt; 0 \u0026amp;\u0026amp; nums[midpoint] \u0026lt; nums[midpoint-1] )，因為當前那個點的值\u0026lt;前面index的點的值，代表找到那個點，因此return nums[midpoint] 3.如果： 左側都是sorted\u0026amp;\u0026amp;右側沒有sorted：找右側 else：找左側 class Solution { public int findMin(int[] nums) { if(nums.length ==0) return -1; if(nums.length ==1) return nums[0]; int left = 0; int right = nums.length -1; while(left\u0026lt;right){ int midpoint = left + (right - left)/2; if( midpoint \u0026gt; 0 \u0026amp;\u0026amp; nums[midpoint] \u0026lt; nums[midpoint-1] ){ return nums[midpoint]; } else if (nums[left]\u0026lt;= nums[midpoint] \u0026amp;\u0026amp; nums[midpoint] \u0026gt; nums[right] ){ //sorted on the left side \u0026amp;\u0026amp; !=sorted on the right side left = midpoint +1 ; } else { right = midpoint -1; } } return nums[left]; } } Time: O(log n)\nSpace: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-153/","tags":["leetcode","array","binary search"],"title":"Leetcode-153. Find Minimum in Rotated Sorted Array"},{"categories":["Programming"],"contents":"Given a string s, find the length of the longest substring without repeating characters.\nExample 1:\nInput: s = \u0026#34;abcabcbb\u0026#34; Output: 3 Explanation: The answer is \u0026#34;abc\u0026#34;, with the length of 3. Example 2:\nInput: s = \u0026#34;bbbbb\u0026#34; Output: 1 Explanation: The answer is \u0026#34;b\u0026#34;, with the length of 1. Example 3:\nInput: s = \u0026#34;pwwkew\u0026#34; Output: 3 Explanation: The answer is \u0026#34;wke\u0026#34;, with the length of 3. Notice that the answer must be a substring, \u0026#34;pwke\u0026#34; is a subsequence and not a substring. \u0026lt;解題\u0026gt; 要找到不重複字詞的長度，類似sliding window，我們可以用兩個pointer去找，先移動b_pointer，如果沒有出現過的，先存在hashset中，每次指標++向後遍歷，同時更新最大的不重複字詞（max) 如果hashset重複了，那我們就把window整個向後移動，先把hashset中原先a_pointer的值移除，再把a_pointer往後移一位，以便之後繼續處理 class Solution { public int lengthOfLongestSubstring(String s) { int a_pointer = 0; int b_pointer = 0; int max = 0; HashSet\u0026lt;Character\u0026gt; hash_set = new HashSet(); while(b_pointer \u0026lt; s.length()){ if(!hash_set.contains(s.charAt(b_pointer))){ hash_set.add(s.charAt(b_pointer)); b_pointer++; max = Math.max(max, hash_set.size()); } else{ hash_set.remove(s.charAt(a_pointer)); a_pointer++; } } return max; } } Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-3/","tags":["leetcode","string"],"title":"Leetcode-3. Longest Substring Without Repeating Characters"},{"categories":["Programming"],"contents":"There is an integer array nums sorted in ascending order (with distinct values).\nPrior to being passed to your function, nums is possibly rotated at an unknown pivot index k (1 \u0026lt;= k \u0026lt; nums.length) such that the resulting array is [nums[k], nums[k+1], \u0026hellip;, nums[n-1], nums[0], nums[1], \u0026hellip;, nums[k-1]] (0-indexed). For example, [0,1,2,4,5,6,7] might be rotated at pivot index 3 and become [4,5,6,7,0,1,2].\nGiven the array nums after the possible rotation and an integer target, return the index of target if it is in nums, or -1 if it is not in nums.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [4,5,6,7,0,1,2], target = 0 Output: 4 Example 2:\nInput: nums = [4,5,6,7,0,1,2], target = 3 Output: -1 Example 3:\nInput: nums = [1], target = 0 Output: -1 \u0026lt;解題\u0026gt; 要在sorted array裡面找target，但數列有被旋轉過，所以我們必須知道哪邊是最小值，才可以去找到target： a. 先確認嘴小值指標left b. 把最小值left設為start，來找到他的區間，如[4,5,6,7,0,1,2]中，0的左側或右側 c. 找target class Solution { public int search(int[] nums, int target) { if(nums.length == 0) return -1; int left = 0; int right = nums.length-1; //先確認最小值的指標left while(left\u0026lt;right){ int midpoint = left + (right - left)/2; if(nums[midpoint] \u0026gt; nums[right]){ left = midpoint + 1; } else { right = midpoint; } } //把最小值left設為start，來找到他的區間，如[4,5,6,7,0,1,2]中，0的左側或右側 int start = left; //start變成最小值 left = 0; right = nums.length-1; if(target \u0026gt;= nums[start] \u0026amp;\u0026amp; target \u0026lt;= nums[right]){ //target在start和right之間（也就是0的右側） left = start; } else{ right = start; } //找target while (left\u0026lt;=right){ int midpoint = left + (right - left)/2; if(nums[midpoint] == target){ return midpoint; } else if(nums[midpoint] \u0026gt; target){ right = midpoint -1; } else { left = midpoint +1; } } return -1; } } Time: O(logN)\nSpace: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-33/","tags":["leetcode","array","binary search"],"title":"Leetcode-33. Search in Rotated Sorted Array"},{"categories":["Programming"],"contents":"Given an integer array nums where the elements are sorted in ascending order, convert it to a height-balanced binary search tree.\nExample 1:\nInput: nums = [-10,-3,0,5,9] Output: [0,-3,9,-10,null,5] Explanation: [0,-10,5,null,-3,null,9] is also accepted: Example 2:\nInput: nums = [1,3] Output: [3,1] Explanation: [1,null,3] and [3,1] are both height-balanced BSTs. \u0026lt;解題\u0026gt; 把sorted array變成BST，我們可以用找中間點midpoint方式，先找到中間點 使用constructBST方法，把(int[]nums, int left, int right)帶入，直到if(left\u0026gt;right) return null; 在找到中間點後，把中間點存到node裡，接著把left, rigit更新： -node.left = constructBST(nums, left, midpoint-1); -node.right = constructBST(nums, midpoint+1, right); 左子樹中的所有節點的值都小於根節點的值。 右子樹中的所有節點的值都大於根節點的值。 左子樹和右子樹都必須是BST。 class Solution { public TreeNode sortedArrayToBST(int[] nums) { if(nums.length ==0) return null; return constructBST(nums, 0, nums.length-1); } public TreeNode constructBST(int[]nums, int left, int right){ if(left\u0026gt;right) return null; int midpoint = left + (right -left)/2; //找中間點index TreeNode node = new TreeNode(nums[midpoint]); node.left = constructBST(nums, left, midpoint-1); node.right = constructBST(nums, midpoint+1, right); return node; } } Time: O(log n)\nSpace: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-108/","tags":["leetcode","array"],"title":"Leetcode-108. Convert Sorted Array to Binary Search Tree"},{"categories":["Programming"],"contents":"Given the head of a linked list, return the list after sorting it in ascending order.\nExample 1:\nInput: head = [4,2,1,3] Output: [1,2,3,4] Example 2:\nInput: head = [-1,5,3,4,0] Output: [-1,0,3,4,5] Example 3:\nInput: head = [] Output: [] \u0026lt;解題\u0026gt; 用merge sort 的方式，所以要先找出中間點，把一個array一分為二，故先建立temp, slow, fast 三個指標 while迴圈中，slow 指針每次移動一步，fast 指針每次移動兩步，當 fast 指針達到連結串列的尾端時，slow 指針剛好指向中間節點 將連結串列拆分為兩部分，left_side 是原始連結串列的前半部分(left_side: head-\u0026gt;\u0026hellip;-\u0026gt;temp)，right_side 是原始連結串列的後半部分(right_side: slow-\u0026gt;\u0026hellip;fast) 對 left_side（head) 和 right_side(slow) 分別遞迴調用 sortList 函式 最後，將排好序的merge(left_side, right_side)返回 merge 方法：用於合併兩個已排序的連結串列。使用兩個指針 l1 和 l2 分別指向兩個已排序連結串列的頭節點 class Solution { public ListNode sortList(ListNode head) { if(head ==null || head.next ==null) return head; ListNode temp = head; ListNode slow = head; ListNode fast = head; while (fast != null \u0026amp;\u0026amp; fast.next != null){ temp = slow; slow = slow.next; fast = fast.next.next; } temp.next = null; ListNode left_side = sortList(head); //left_side: head-\u0026gt;...-\u0026gt;temp ListNode right_side = sortList(slow); //right_side: slow-\u0026gt;...fast return merge(left_side, right_side); } public ListNode merge(ListNode l1, ListNode l2){ ListNode sorted_temp = new ListNode(0); ListNode current_node = sorted_temp; while(l1!= null \u0026amp;\u0026amp; l2 != null){ if(l1.val \u0026lt; l2.val){ current_node.next = l1; l1 = l1.next; } else{ current_node.next = l2; l2 = l2.next; } current_node = current_node.next; } //當另外一個list為null，直接接完 if(l1!= null){ current_node.next = l1; l1 = l1.next; } if(l2!= null){ current_node.next = l2; l2 = l2.next; } return sorted_temp.next; } } Time: O(n log n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-148/","tags":["leetcode","linked List"],"title":"Leetcode-148. Sort List"},{"categories":["Programming"],"contents":"A peak element is an element that is strictly greater than its neighbors.\nGiven a 0-indexed integer array nums, find a peak element, and return its index. If the array contains multiple peaks, return the index to any of the peaks.\nYou may imagine that nums[-1] = nums[n] = -∞. In other words, an element is always considered to be strictly greater than a neighbor that is outside the array.\nYou must write an algorithm that runs in O(log n) time.\nExample 1:\nInput: nums = [1,2,3,1] Output: 2 Explanation: 3 is a peak element and your function should return the index number 2. Example 2:\nInput: nums = [1,2,1,3,5,6,4] Output: 5 Explanation: Your function can return either index number 1 where the peak element is 2, or index number 5 where the peak element is 6. \u0026lt;解題\u0026gt; Time: O() Space: O()\n","permalink":"https://pattysung1.github.io/works/leetcode-162/","tags":["leetcode","array"],"title":"Leetcode-162. Find Peak Element"},{"categories":["Programming"],"contents":"Given the root of a complete binary tree, return the number of the nodes in the tree. According to Wikipedia, every level, except possibly the last, is completely filled in a complete binary tree, and all nodes in the last level are as far left as possible. It can have between 1 and 2h nodes inclusive at the last level h. Design an algorithm that runs in less than O(n) time complexity.\nExample 1:\nInput: root = [1,2,3,4,5,6] Output: 6 Example 2:\nInput: root = [] Output: 0 Example 3:\nInput: root = [1] Output: 1 -\u0026gt; 計算完整的樹節點\n\u0026lt;解題\u0026gt; class Solution { public int countNodes(TreeNode root) { if(root ==null) return 0; int ans = countAllNodes(root); return ans; } public int countAllNodes(TreeNode root){ if(root ==null) return 0; int lh = countAllNodes(root.left); int rh = countAllNodes(root.right); return lh+rh+1; } } Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-222/","tags":["leetcode","array","string"],"title":"Leetcode-222. Count Complete Tree Nodes"},{"categories":["Programming"],"contents":"Given an array of integers nums sorted in non-decreasing order, find the starting and ending position of a given target value.\nIf target is not found in the array, return [-1, -1].\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [5,7,7,8,8,10], target = 8 Output: [3,4] Example 2:\nInput: nums = [5,7,7,8,8,10], target = 6 Output: [-1,-1] Example 3:\nInput: nums = [], target = 0 Output: [-1,-1] \u0026lt;解題\u0026gt; 由於要回傳[0,1]一組陣列，使其出現target數字的起始和最後index，所以需要先建立result[0]=findStartingIndex(nums, target)和result[1]==findEndingIndex(nums, target); 兩者的方法很像過往找BTS target的題目，但不同的是，由於是要找重複的數字，所以在while(start\u0026lt;=end)中： findStartingIndex，兩者數字相同時，需要再往前看一位 findEndingIndex，兩者數字相同時，需要再往後看一位 最後if(nums[mid]==target) index = mid; \u0026lt;舉例說明\u0026gt; 假設有一個已排序的整數數組 nums 為：[1, 2, 2, 3, 4, 4, 4, 5, 6]，我們要找到目標元素 target 為 4 的起始索引和結束索引。\na.當尋找目標元素 4 的起始索引時：\nstart = 0, end = 8, mid = (0 + 8) / 2 = 4，nums[mid] = 4，由於目標元素為 4，將 end 更新為 mid - 1 = 3。 start = 0, end = 3, mid = (0 + 3) / 2 = 1，nums[mid] = 2，由於目標元素 4 大於 2，將 start 更新為 mid + 1 = 2。 start = 2, end = 3, mid = (2 + 3) / 2 = 2，nums[mid] = 2，由於目標元素 4 大於 2，將 start 更新為 mid + 1 = 3。 start = 3, end = 3, mid = (3 + 3) / 2 = 3，nums[mid] = 3，由於目標元素 4 大於 3，將 start 更新為 mid + 1 = 4。 start = 4, end = 3，start \u0026gt; end，迴圈結束，返回 index = 4。 b. 當尋找目標元素 4 的結束索引時：\nstart = 0, end = 8, mid = (0 + 8) / 2 = 4，nums[mid] = 4，由於目標元素為 4，將 start 更新為 mid + 1 = 5。 start = 5, end = 8, mid = (5 + 8) / 2 = 6，nums[mid] = 4，由於目標元素 4 等於 4，將 start 更新為 mid + 1 = 7。 start = 7, end = 8, mid = (7 + 8) / 2 = 7，nums[mid] = 5，由於目標元素 4 小於 5，將 end 更新為 mid - 1 = 6。 start = 7, end = 6，start \u0026gt; end，迴圈結束，返回 index = 6。 最終，返回結果數組 [4, 6]，表示目標元素 4 在已排序數組中的起始索引和結束索引分別為 4 和 6。\n要找到陣列中，target數字的起始和終點index， class Solution { public int[] searchRange(int[] nums, int target) { int[] result = new int[2]; result[0] = findStartingIndex(nums, target); result[1] = findEndingIndex(nums, target); return result; } public int findStartingIndex(int[] nums, int target){ int index = -1; int start = 0; int end = nums.length-1; while(start\u0026lt;=end){ int mid = start + (end-start)/2; if(nums[mid] \u0026gt;= target){ //對於startingIndex而言，雖然找到了element，但仍希望往左移動尋找，找到前一個target數字 end = mid-1; } else{ start = mid+1; } if(nums[mid]==target) index = mid; } return index; } public int findEndingIndex(int[] nums, int target){ int index = -1; int start = 0; int end = nums.length-1; while(start\u0026lt;=end){ int mid = start + (end-start)/2; if(nums[mid] \u0026lt;= target){ //對於endingIndex而言，雖然找到了element，但仍希望往右移動尋找，找到下一個target數字 start = mid +1; } else{ end = mid-1; } if(nums[mid]==target) index = mid; } return index; } } Time: O(log n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-34/","tags":["leetcode","array"],"title":"Leetcode-34. Find First and Last Position of Element in Sorted Array"},{"categories":["Programming"],"contents":"Given a sorted array of distinct integers and a target value, return the index if the target is found. If not, return the index where it would be if it were inserted in order.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [1,3,5,6], target = 5 Output: 2 Example 2:\nInput: nums = [1,3,5,6], target = 2 Output: 1 Example 3:\nInput: nums = [1,3,5,6], target = 7 Output: 4 \u0026lt;解題\u0026gt; 用前後兩指標去縮減範圍，一次從砍半中間開始找，不過這題如果沒有找到的話，要把他插入，所以最後可以直接返回start值 class Solution { public int searchInsert(int[] A, int target) { int start = 0, end = A.length-1, mid = (start+end)/2; while(start\u0026lt;=end){ if(A[mid]==target) return mid; if(A[mid]\u0026gt;target){ end = mid-1; } else { start = mid+1; } mid = (start+end)/2; } return start; } } Time: O(log n) Space: O(1)\n可以和704. Binary Search做比較 ","permalink":"https://pattysung1.github.io/works/leetcode-35/","tags":["leetcode","array"],"title":"Leetcode-35. Search Insert Position"},{"categories":["Programming"],"contents":"Example 1:\nInput: root = [4,2,7,1,3], val = 5 Output: [4,2,7,1,3,5] Explanation: Another accepted tree is: Example 2:\nInput: root = [40,20,60,10,30,50,70], val = 25 Output: [40,20,60,10,30,50,70,null,null,25] Example 3:\nInput: root = [4,2,7,1,3,null,null,null,null,null,null], val = 5 Output: [4,2,7,1,3,5] \u0026lt;解題\u0026gt; 如果本身為空：if(root == null) return new TreeNode(val); 建立一個新的TreeNode current_node = root; 作為操作 判斷current_node與val的大小，是否為空，做調整與加入 return root class Solution { public TreeNode insertIntoBST(TreeNode root, int val) { if(root == null) return new TreeNode(val); TreeNode current_node = root; while(true){ if(current_node.val \u0026lt;= val){ if(current_node.right != null ){ current_node = current_node.right; } else{ current_node.right = new TreeNode(val); break; } }else{ if(current_node.left != null ){ current_node = current_node.left; } else{ current_node.left = new TreeNode(val); break; } } } return root; } } Time: O(log n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-701/","tags":["leetcode","tree","BST"],"title":"Leetcode-701. Insert into a Binary Search Tree"},{"categories":["Programming"],"contents":"You are given an m x n integer matrix matrix with the following two properties:\nEach row is sorted in non-decreasing order. The first integer of each row is greater than the last integer of the previous row. Given an integer target, return true if target is in matrix or false otherwise.\nYou must write a solution in O(log(m * n)) time complexity.\nExample 1:\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 3 Output: true Example 2:\nInput: matrix = [[1,3,5,7],[10,11,16,20],[23,30,34,60]], target = 13 Output: false \u0026lt;解題\u0026gt; 這題和過往的BST類似，差別在於其為2D matrix，所以在index上需要作轉換 用midpoint 去找是否和target相同，而每次的midpoint更新，需要同時將index轉成matrix[][]的形式： int midpoint_element = matrix[midpoint/columns][midpoint%columns]; class Solution { public boolean searchMatrix(int[][] matrix, int target) { if(matrix == null) return false; int rows = matrix.length; int columns = matrix[0].length; int left = 0; int right = rows * columns -1; while (left \u0026lt;= right){ int midpoint = left + (right -left)/2; //一般BST作法 int midpoint_element = matrix[midpoint/columns][midpoint%columns]; //轉換成matrix裡面的index -\u0026gt;index==5，要換成[1,1] if(midpoint_element == target){ return true; } else if(target \u0026lt; midpoint_element){ right = midpoint-1; } else if(target \u0026gt; midpoint_element){ left = midpoint+1; } } return false; } } Time: O(log(mn)) -\u0026gt;mn為矩陣的行列數\nSpace: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-74/","tags":["leetcode","array","binary search"],"title":"Leetcode-74. Search a 2D Matrix"},{"categories":["Programming"],"contents":"Reverse bits of a given 32 bits unsigned integer.\nNote:\nNote that in some languages, such as Java, there is no unsigned integer type. In this case, both input and output will be given as a signed integer type. They should not affect your implementation, as the integer\u0026rsquo;s internal binary representation is the same, whether it is signed or unsigned. In Java, the compiler represents the signed integers using 2\u0026rsquo;s complement notation. Therefore, in Example 2 above, the input represents the signed integer -3 and the output represents the signed integer -1073741825.\nExample 1:\nInput: n = 00000010100101000001111010011100 Output: 964176192 (00111001011110000010100101000000) Explanation: The input binary string 00000010100101000001111010011100 represents the unsigned integer 43261596, so return 964176192 which its binary representation is 00111001011110000010100101000000. Example 2:\nInput: n = 11111111111111111111111111111101 Output: 3221225471 (10111111111111111111111111111111) Explanation: The input binary string 11111111111111111111111111111101 represents the unsigned integer 4294967293, so return 3221225471 which its binary representation is 10111111111111111111111111111111. \u0026lt;解題\u0026gt; 利用n\u0026amp;1，將 n 的最後一位（最低位）取出，可以使用 n \u0026amp; 1 進行位元運算，即取 n 的最後一位的數值（0 或 1） 使用位元 OR 運算將取得的最後一位數值加到 result 上（result | (n \u0026amp; 1)），這相當於將 n 的最後一位數值放入 result 的最低位 將 n 向右移位（n = n \u0026raquo; 1），相當於將 n 的二進制表示向右移動一位，並忽略最低位的數值。這樣在下一次迴圈中，就可以繼續取得 n 的下一位。 public class Solution { public int reverseBits(int n) { int ans=0; for(int i=0;i\u0026lt;32;i++){ ans= ( ans \u0026lt;\u0026lt; 1 ) | ( n \u0026amp; 1 ); n = n \u0026gt;\u0026gt; 1; } return ans; } } Time: O(1)\nSpace: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-190/","tags":["leetcode","Bit Manipulation"],"title":"Leetcode-190. Reverse Bits"},{"categories":["Programming"],"contents":"Given an integer array nums, return an array answer such that answer[i] is equal to the product of all the elements of nums except nums[i].\nThe product of any prefix or suffix of nums is guaranteed to fit in a 32-bit integer.\nYou must write an algorithm that runs in O(n) time and without using the division operation.\nExample 1:\nInput: nums = [1,2,3,4] Output: [24,12,8,6] Example 2:\nInput: nums = [-1,1,0,-3,3] Output: [0,0,9,0,0] \u0026lt;解題\u0026gt;分別計算每個元素左邊元素的乘積和右邊元素的乘積，然後將左邊乘積和右邊乘積相乘，得到最終結果 分別建立兩個pre（把[0]設為1), post陣列(把最後一位設為1) 第一個 for 迴圈計算每個元素的前綴乘積。從第二個元素開始遍歷，每個元素的前綴乘積等於前一個元素的前綴乘積乘以前一個元素的值。 第二個 for 迴圈計算每個元素的後綴乘積。從倒數第二個元素開始遍歷，每個元素的後綴乘積等於後一個元素的後綴乘積乘以後一個元素的值。 建立一個陣列 ans 用於保存最終的結果。 第三個 for 迴圈計算最終的結果。對於每個元素，將其對應的前綴乘積和後綴乘積相乘，即為答案。 class Solution { public int[] productExceptSelf(int nums[]) { int n = nums.length; int[] pre = new int[n]; int[] post = new int[n]; pre[0] = 1; post[n - 1] = 1; for (int i = 1; i \u0026lt; n; i++) { pre[i] = pre[i - 1] * nums[i - 1]; } for (int i = n - 2; i \u0026gt;= 0; i--) { post[i] = post[i + 1] * nums[i + 1]; } int[] ans = new int[n]; for (int i = 0; i \u0026lt; n; i++) { ans[i] = pre[i] * post[i]; } return ans; } } Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-238/","tags":["leetcode","array"],"title":"Leetcode-238. Product of Array Except Self"},{"categories":["Programming"],"contents":"Given a string s and a character c that occurs in s, return an array of integers answer where answer.length == s.length and answer[i] is the distance from index i to the closest occurrence of character c in s.\nThe distance between two indices i and j is abs(i - j), where abs is the absolute value function.\nExample 1:\nInput: s = \u0026#34;loveleetcode\u0026#34;, c = \u0026#34;e\u0026#34; Output: [3,2,1,0,1,0,0,1,2,2,1,0] Explanation: The character \u0026#39;e\u0026#39; appears at indices 3, 5, 6, and 11 (0-indexed). The closest occurrence of \u0026#39;e\u0026#39; for index 0 is at index 3, so the distance is abs(0 - 3) = 3. The closest occurrence of \u0026#39;e\u0026#39; for index 1 is at index 3, so the distance is abs(1 - 3) = 2. For index 4, there is a tie between the \u0026#39;e\u0026#39; at index 3 and the \u0026#39;e\u0026#39; at index 5, but the distance is still the same: abs(4 - 3) == abs(4 - 5) = 1. The closest occurrence of \u0026#39;e\u0026#39; for index 8 is at index 6, so the distance is abs(8 - 6) = 2. Example 2:\nInput: s = \u0026#34;aaab\u0026#34;, c = \u0026#34;b\u0026#34; Output: [3,2,1,0] \u0026lt;解題\u0026gt; class Solution { public int[] shortestToChar(String s, char c) { int n = s.length(); int[] output_arr = new int[n]; int c_position = -n; for(int i = 0 ; i\u0026lt; n ; i++){ if(s.charAt(i) == c){ c_position = i; } output_arr[i] = i - c_position; } for(int i = n-1 ; i\u0026gt;=0 ; i--){ if(s.charAt(i) == c){ c_position = i; } output_arr[i] = Math.min(output_arr[i] , Math.abs(i-c_position)); } return output_arr; } } Time: O(n) Space: O(n)\n圖片資料來源：Youtube-Nick White\n","permalink":"https://pattysung1.github.io/works/leetcode-821/","tags":["leetcode","array","string"],"title":"Leetcode-821. Shortest Distance to a Character"},{"categories":["Programming"],"contents":"You are given two string arrays words1 and words2.\nA string b is a subset of string a if every letter in b occurs in a including multiplicity.\nFor example, \u0026ldquo;wrr\u0026rdquo; is a subset of \u0026ldquo;warrior\u0026rdquo; but is not a subset of \u0026ldquo;world\u0026rdquo;. A string a from words1 is universal if for every string b in words2, b is a subset of a.\nReturn an array of all the universal strings in words1. You may return the answer in any order.\nExample 1:\nInput: words1 = [\u0026#34;amazon\u0026#34;,\u0026#34;apple\u0026#34;,\u0026#34;facebook\u0026#34;,\u0026#34;google\u0026#34;,\u0026#34;leetcode\u0026#34;], words2 = [\u0026#34;e\u0026#34;,\u0026#34;o\u0026#34;] Output: [\u0026#34;facebook\u0026#34;,\u0026#34;google\u0026#34;,\u0026#34;leetcode\u0026#34;] Example 2:\nInput: words1 = [\u0026#34;amazon\u0026#34;,\u0026#34;apple\u0026#34;,\u0026#34;facebook\u0026#34;,\u0026#34;google\u0026#34;,\u0026#34;leetcode\u0026#34;], words2 = [\u0026#34;l\u0026#34;,\u0026#34;e\u0026#34;] Output: [\u0026#34;apple\u0026#34;,\u0026#34;google\u0026#34;,\u0026#34;leetcode\u0026#34;] \u0026lt;解題\u0026gt;優化後的解法 用get_char_frequency方法，去計算words各字母出現的頻率。 用char的方式去計算words2各字母出現的最大頻率，同時遍歷words1的頻率去比對，沒有不符合的，就加入result這個arraylist裏面 class Solution { public List\u0026lt;String\u0026gt; wordSubsets(String[] words1, String[] words2) { //計算words2各字母的頻率 int[] max_b_frequencies = new int[26]; for (String word : words2) { int[] char_frequency = get_char_frequency(word); for (int j = 0; j \u0026lt; 26; j++) { max_b_frequencies[j] = Math.max(max_b_frequencies[j], char_frequency[j]); } } //遍歷words1的頻率去比對 List\u0026lt;String\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); for (String word : words1) { int[] char_count = get_char_frequency(word); boolean valid = true; for (int j = 0; j \u0026lt; 26; j++) { if (char_count[j] \u0026lt; max_b_frequencies[j]) { valid = false; break; } } if (valid) { result.add(word); } } return result; } public int[] get_char_frequency(String s) { int[] result = new int[26]; for (char c : s.toCharArray()) { result[c - \u0026#39;a\u0026#39;]++; } return result; } } class Solution { public List\u0026lt;String\u0026gt; wordSubsets(String[] words1, String[] words2) { List\u0026lt;String\u0026gt; result = new ArrayList(); int[] max_b_frequencies = new int[26]; //計算words2部分 for(int i =0 ;i\u0026lt;words2.length;i++){ String current_word = words2[i]; int[] char_frequency = get_char_frequency(current_word); //words2中每個String的字母頻率 for(int j = 0 ; j\u0026lt;26; j++){ //每次更新每個字母最多的最高頻率 max_b_frequencies[j] = Math.max(max_b_frequencies[j], char_frequency[j]); } } //計算words1部分 for(int i =0; i\u0026lt;words1.length; i++){ String current_word = words1[i]; int[] char_count = get_char_frequency(current_word);//words1中每個String的字母頻率 boolean valid= true; for(int j = 0 ; j\u0026lt;26; j++){ if(max_b_frequencies[j] \u0026gt; char_count[j]){ valid = false; break; } } if(valid) { result.add(current_word); } } return result; } public int[] get_char_frequency(String s){ int[] result = new int[26]; for(char c : s.toCharArray()){ result[c-\u0026#39;a\u0026#39;]++; } return result; } } Time: O((M+N)*K) Space: O(N)\n","permalink":"https://pattysung1.github.io/works/leetcode-916/","tags":["leetcode","array","string"],"title":"Leetcode-916. Word Subsets"},{"categories":["Programming"],"contents":"Given an integer array nums sorted in non-decreasing order, return an array of the squares of each number sorted in non-decreasing order.\nExample 1:\nInput: nums = [-4,-1,0,3,10] Output: [0,1,9,16,100] Explanation: After squaring, the array becomes [16,1,0,9,100]. After sorting, it becomes [0,1,9,16,100]. Example 2:\nInput: nums = [-7,-3,2,3,11] Output: [4,9,9,49,121]\n\u0026lt;解題\u0026gt; class Solution { public int[] sortedSquares(int[] nums) { int n = nums.length; int positivePointer = 0; while (positivePointer \u0026lt; n \u0026amp;\u0026amp; nums[positivePointer] \u0026lt; 0){ positivePointer++; } int negativePointer = positivePointer - 1; int[] outputArray = new int[n]; int count = 0; while (negativePointer \u0026gt;= 0 \u0026amp;\u0026amp; positivePointer \u0026lt; n){ if (nums[negativePointer] * nums[negativePointer] \u0026lt; nums[positivePointer] * nums[positivePointer]){ outputArray[count++] = nums[negativePointer] * nums[negativePointer]; negativePointer--; } else { outputArray[count++] = nums[positivePointer] * nums[positivePointer]; positivePointer++; } } while (negativePointer \u0026gt;= 0){ outputArray[count++] = nums[negativePointer] * nums[negativePointer]; negativePointer--; } while (positivePointer \u0026lt; n){ outputArray[count++] = nums[positivePointer] * nums[positivePointer]; positivePointer++; } return outputArray; } } Time: O(N) Space: O(N)\n","permalink":"https://pattysung1.github.io/works/leetcode-977/","tags":["leetcode","array","string"],"title":"Leetcode-977. Squares of a Sorted Array"},{"categories":["Programming"],"contents":"Implement pow(x, n), which calculates x raised to the power n (i.e., xn).\nExample 1:\nInput: x = 2.00000, n = 10 Output: 1024.00000 Example 2:\nInput: x = 2.10000, n = 3 Output: 9.26100 Example 3:\nInput: x = 2.00000, n = -2 Output: 0.25000 Explanation: 2-2 = 1/22 = 1/4 = 0.25 \u0026lt;解題\u0026gt; 看到leetcode網站有分享不同的解法\nclass Solution { public double myPow(double x, int n) { if(n==0) return 1; else if(n%2==0) return myPow(x*x, n/2); else if(n%2==1) return x*myPow(x,n-1); else{ return 1/ myPow(x, -n); } } } Time: O(log n)\nSpace: O(log n)\n","permalink":"https://pattysung1.github.io/works/leetcode-50/","tags":["leetcode","Bit Manipulation"],"title":"Leetcode-50. Pow(x, n)"},{"categories":["Programming"],"contents":"\n\u0026lt;解題\u0026gt; class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; subsetsWithDup(int[] nums) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans = new ArrayList\u0026lt;\u0026gt;(); Arrays.sort(nums); //排序 getAns(nums, 0, new ArrayList\u0026lt;\u0026gt;(), ans); return ans; } private void getAns(int[] nums, int start, ArrayList\u0026lt;Integer\u0026gt; temp, List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; ans) { ans.add(new ArrayList\u0026lt;\u0026gt;(temp)); for (int i = start; i \u0026lt; nums.length; i++) { //和上个数字相等就跳过 if (i \u0026gt; start \u0026amp;\u0026amp; nums[i] == nums[i - 1]) { continue; } temp.add(nums[i]); getAns(nums, i + 1, temp, ans); temp.remove(temp.size() - 1); } } } Time: O(2^n * n) Space: O(2^n * n)\n","permalink":"https://pattysung1.github.io/works/leetcode-90/","tags":["leetcode","Bit Manipulation"],"title":"Leetcode-90. Subsets II"},{"categories":["Programming"],"contents":"Given two integers a and b, return the sum of the two integers without using the operators + and -.\nExample 1:\nInput: a = 1, b = 2 Output: 3 Example 2:\nInput: a = 2, b = 3 Output: 5 \u0026lt;解題\u0026gt; 這題要做兩個數字的加法，但不可以運用+-符號，所以需要運用其他符合來完成 運用carry = a \u0026amp; b 可以得到 a 和 b 的需進位結果 運用a ^ b 可以得到 a 和 b 的不進位加法結果 最後向左進一位 更新 a 的值為不進位加法的結果，b 的值為進位 carry 的值。當b變為0時，即進位為0，while 循環結束 class Solution { public int getSum(int a, int b) { if (a == 0) return b; if (b == 0) return a; // a = 010 ; b = 011 while (b != 0) { int carry = a \u0026amp; b; //carry = 010 // carry =000 //a \u0026amp; b 可以得到 a 和 b 的需進位結果 a = a ^ b; //a = 001 // a = 101 //a ^ b 可以得到 a 和 b 的不進位加法結果 b = carry \u0026lt;\u0026lt; 1; //b = 100 / /b = 000 //進位進一位 } return a; //101 } } Time: O(k) (k為二進制的位數)\nSpace: O(1)\n**可以和 67. Add Binary做比較 ","permalink":"https://pattysung1.github.io/works/leetcode-371/","tags":["leetcode","Bit Manipulation"],"title":"Leetcode-371. Sum of Two Integers"},{"categories":["Programming"],"contents":"You are given an n x n 2D matrix representing an image, rotate the image by 90 degrees (clockwise).\nYou have to rotate the image in-place, which means you have to modify the input 2D matrix directly. DO NOT allocate another 2D matrix and do the rotation.\nExample 1:\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]] Output: [[7,4,1],[8,5,2],[9,6,3]] Example 2:\nInput: matrix = [[5,1,9,11],[2,4,8,10],[13,3,6,7],[15,14,12,16]] Output: [[15,13,2,5],[14,3,4,1],[12,6,8,9],[16,7,10,11]] \u0026lt;解題\u0026gt; 先垂直翻轉（交換第一行和第四行、交換第二行和第三行），再對角線翻轉（交換(1,2) 和 (2,1)，交換 (1,3) 和 (3,1)，交換 (1,4) 和 (4,1)） 或也可以先對角線翻轉，再垂直翻轉 class Solution { public void rotate(int[][] matrix) { int n = matrix.length; // 先對矩陣進行垂直翻轉 for (int i = 0; i \u0026lt; n / 2; i++) { int[] temp = matrix[i]; matrix[i] = matrix[n - 1 - i]; matrix[n - 1 - i] = temp; } // 再對矩陣進行主對角線翻轉 for (int i = 0; i \u0026lt; n; i++) { for (int j = i + 1; j \u0026lt; n; j++) { int temp = matrix[i][j]; matrix[i][j] = matrix[j][i]; matrix[j][i] = temp; } } // (0,1)(0,2)(0,3) // (1,2)(1,3) // (2,3) } } Time: O(N^2) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-48/","tags":["leetcode","array"],"title":"Leetcode-48. Rotate Image"},{"categories":["Programming"],"contents":"Given a signed 32-bit integer x, return x with its digits reversed. If reversing x causes the value to go outside the signed 32-bit integer range [-231, 231 - 1], then return 0.\nAssume the environment does not allow you to store 64-bit integers (signed or unsigned).\nExample 1:\nInput: x = 123 Output: 321 Example 2:\nInput: x = -123 Output: -321 Example 3:\nInput: x = 120 Output: 21 \u0026lt;解題\u0026gt; 創建一個變數 result 用來保存反轉後的結果，初始化為 0 當x不為0進入迴圈，先取得原先的最後一個數字，把result * 10 + tail，如果發生溢位，也就是(newResult - tail) / 10 != result，表示發生了溢出，返回 0 每次把result = newResult; 然後將 x 右移一位（除以 10），進入下一輪迴圈處理 class Solution { public int reverse(int x){ int result = 0; while (x != 0){ int tail = x % 10; //取得原先的最後一個數字 int newResult = result * 10 + tail; if ((newResult - tail) / 10 != result){ //如果發生溢位，直接return 0 return 0; } result = newResult; x = x / 10; } return result; } } Time: O(log|x|) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-7/","tags":["leetcode"],"title":"Leetcode-7. Reverse Integer"},{"categories":["Programming"],"contents":"Given a non-empty array of integers nums, every element appears twice except for one. Find that single one.\nYou must implement a solution with a linear runtime complexity and use only constant extra space.\nExample 1:\nInput: nums = [2,2,1] Output: 1 Example 2:\nInput: nums = [4,1,2,1,2] Output: 4 Example 3:\nInput: nums = [1] Output: 1 \u0026lt;解題\u0026gt; 利用了 XOR 運算的幾個性質： XOR 運算具有交換律：a^b = b^a XOR 運算具有結合律：(a^b)^c = a^(b^c) 對於任何數字 a，a^a = 0，即同一數字連續進行 XOR 運算會得到 0 對於任何數字 a，a^0 = a，即任何數字與 0 進行 XOR 運算結果等於它本身\n先把數字想成二進位：//nums = [4,1,2,1,2] 2 → 010 4 → 100 1 → 001\n相同的會是0，不同的會是1 0 xor 0 = 0 0 xor 1 = 1 1 xor 0 = 1 1 xor 1 = 0\n將所有重複出現的元素兩兩抵消，留下的只有只出現一次的元素，按照XOR的邏輯：//nums = [4,1,2,1,2]\n100 = 000 ^ 100 (0^4) 101 = 100 ^ 001 (4^1) 111 = 101 ^ 010 (5^2) 110 = 111 ^ 001 (7^1) 100 = 110 ^ 010 (6^2) -\u0026gt;最後result回傳4 class Solution { public int singleNumber(int[] nums) { int result=0; for(int i=0; i\u0026lt;nums.length; i++) { result = result^nums[i]; } return result; } } Time: O(N) Space: O(1)\n\u0026lt;解題\u0026gt;方法二 map.put(num, map.getOrDefault(num, 0) + 1)-\u0026gt;map.getOrDefault(num, 0) 會取得鍵 num 對應的值，如果鍵不存在，則返回默認值 0。接著再將值加 1，表示該元素出現次數加 1。 class Solution { public int singleNumber(int[] nums) { HashMap\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums){ if( !map.containsKey(num)){ map.put(num , 1); } else { map.put(num , 2); } } for (int num : nums){ if ( map.get(num)==1) return num; } return -1; } } Time: O(N) Space: O(N)\nclass Solution { public int singleNumber(int[] nums) { HashMap\u0026lt;Integer,Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (int num : nums) { map.put(num, map.getOrDefault(num, 0) + 1); //map.getOrDefault(num, 0) 會取得鍵 num 對應的值，如果鍵不存在，則返回默認值 0。接著再將值加 1，表示該元素出現次數加 1。 } for (int num : nums){ if ( map.get(num)==1) return num; } return -1; } } ","permalink":"https://pattysung1.github.io/works/leetcode-136/","tags":["leetcode","array"],"title":"Leetcode-136. Single Number"},{"categories":["Programming"],"contents":"Write an algorithm to determine if a number n is happy.\nA happy number is a number defined by the following process:\nStarting with any positive integer, replace the number by the sum of the squares of its digits. Repeat the process until the number equals 1 (where it will stay), or it loops endlessly in a cycle which does not include 1. Those numbers for which this process ends in 1 are happy. Return true if n is a happy number, and false if not.\nExample 1:\nInput: n = 19 Output: true Explanation: 12 + 92 = 82 82 + 22 = 68 62 + 82 = 100 12 + 02 + 02 = 1 Example 2:\nInput: n = 2 Output: false \u0026lt;解題\u0026gt; 先建立一個HashSet，來檢測是否有出現過的數字 如果不為1(1是快樂數)且還沒有重複時，就進入迴圈，同時加到seen裏面，以便之後繼續檢測 由於每次需要計算各位數字的平方和，故進入while迴圈裡處理：先取出最後一位數字，再平方，後來再把最後一位數字去掉\u0026hellip; 更新n=sum，進入下一個迴圈，直到重複循環或找到n==1（快樂數）為止 class Solution { public boolean isHappy(int n) { Set\u0026lt;Integer\u0026gt; seen = new HashSet\u0026lt;\u0026gt;(); //存儲已經出現過的數字，以檢測是否陷入了循環 while (n != 1 \u0026amp;\u0026amp; !seen.contains(n)) { seen.add(n); int sum = 0; while (n != 0) { // n=0的話，代表每一位數都處理完了 int digit = n % 10; //最後一位數字取出 sum += digit * digit; //最後一位數字取出後平方 n /= 10; //將 n 除以 10 得到去掉最後一位數字後的結果 } n = sum; } // If n is 1, it is a happy number; otherwise, it is not return n == 1; } } Time: O() Space: O()\n","permalink":"https://pattysung1.github.io/works/leetcode-202/","tags":["leetcode"],"title":"Leetcode-202. Happy Number"},{"categories":["Programming"],"contents":"Given an array nums containing n distinct numbers in the range [0, n], return the only number in the range that is missing from the array.\nExample 1:\nInput: nums = [3,0,1] Output: 2 Explanation: n = 3 since there are 3 numbers, so all numbers are in the range [0,3]. 2 is the missing number in the range since it does not appear in nums. Example 2:\nInput: nums = [0,1] Output: 2 Explanation: n = 2 since there are 2 numbers, so all numbers are in the range [0,2]. 2 is the missing number in the range since it does not appear in nums. Example 3:\nInput: nums = [9,6,4,2,3,5,7,0,1] Output: 8 Explanation: n = 9 since there are 9 numbers, so all numbers are in the range [0,9]. 8 is the missing number in the range since it does not appear in nums. \u0026lt;解題\u0026gt;SUM class Solution { public int missingNumber(int[] nums) { int sum1 = 0; int sum2= 0; for(int num : nums){ sum1 += num ; } for (int i = 0; i\u0026lt;= nums.length; i++){ sum2 += i; } return sum2-sum1; } } Time: O(n) Space: O(1)\n\u0026lt;解題\u0026gt;XOR 這題也可以用XOR，利用i和nums[i]找到一樣的數字就抵銷，剩下的就是missing number\npublic int missingNumber(int[] nums) { int res = nums.length; for(int i=0; i\u0026lt;nums.length; i++){ res ^= i; res ^= nums[i]; } return res; } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-268/","tags":["leetcode","array"],"title":"Leetcode-268. Missing Number"},{"categories":["Programming"],"contents":"You are given a large integer represented as an integer array digits, where each digits[i] is the ith digit of the integer. The digits are ordered from most significant to least significant in left-to-right order. The large integer does not contain any leading 0\u0026rsquo;s.\nIncrement the large integer by one and return the resulting array of digits.\nExample 1:\nInput: digits = [1,2,3] Output: [1,2,4] Explanation: The array represents the integer 123. Incrementing by one gives 123 + 1 = 124. Thus, the result should be [1,2,4]. Example 2:\nInput: digits = [4,3,2,1] Output: [4,3,2,2] Explanation: The array represents the integer 4321. Incrementing by one gives 4321 + 1 = 4322. Thus, the result should be [4,3,2,2]. Example 3:\nInput: digits = [9] Output: [1,0] Explanation: The array represents the integer 9. Incrementing by one gives 9 + 1 = 10. Thus, the result should be [1,0]. \u0026lt;解題\u0026gt; class Solution { public int[] plusOne(int[] digits) { for (int i = digits.length - 1; i \u0026gt;= 0; i--) { if (digits[i] \u0026lt; 9) { digits[i]++; return digits; } digits[i] = 0; } digits = new int[digits.length + 1]; digits[0] = 1; return digits; } } Time: O(N) Space: O(N)\n","permalink":"https://pattysung1.github.io/works/leetcode-66/","tags":["leetcode","array"],"title":"Leetcode-66. Plus One"},{"categories":["Programming"],"contents":"Given two binary strings a and b, return their sum as a binary string.\nExample 1:\nInput: a = \u0026#34;11\u0026#34;, b = \u0026#34;1\u0026#34; Output: \u0026#34;100\u0026#34; Example 2:\nInput: a = \u0026#34;1010\u0026#34;, b = \u0026#34;1011\u0026#34; Output: \u0026#34;10101\u0026#34; \u0026lt;解題\u0026gt; 用carry保存進位的值，由後面往前算，數字的值相加進carry中 while (i \u0026gt;= 0 || j \u0026gt;= 0|| carry==1)，代表還有i,j數字要處理或者還有進位要處理 sb.append(carry % 2); //當前位子的結果0或1 carry /= 2做進位的處理 最後把這個sb反轉字串返回 public class Solution { public String addBinary(String a, String b) { StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() -1, carry = 0; //保存進位的值 while (i \u0026gt;= 0 || j \u0026gt;= 0|| carry==1) { if (j \u0026gt;= 0) { carry += b.charAt(j--) - \u0026#39;0\u0026#39;; } if (i \u0026gt;= 0) { carry += a.charAt(i--) - \u0026#39;0\u0026#39;; } sb.append(carry % 2); //當前位子的結果0,1 carry /= 2; //carry/2 以進行進位處理 } return sb.reverse().toString(); } } Time: O(max(m, n))-\u0026gt;兩字串長度\nSpace: O(max(m, n)\n另外一種寫法 public class Solution { public String addBinary(String a, String b) { StringBuilder sb = new StringBuilder(); int i = a.length() - 1, j = b.length() -1, carry = 0; // a = \u0026#34;1010\u0026#34;, b = \u0026#34;1011\u0026#34; while (i \u0026gt;= 0 || j \u0026gt;= 0|| carry==1) { if (i \u0026gt;= 0) { carry += a.charAt(i) - \u0026#39;0\u0026#39;; } if (j \u0026gt;= 0) { carry += b.charAt(j) - \u0026#39;0\u0026#39;; } sb.append(carry % 2); //當前位子的結果0,1 carry /= 2; //carry/2 以進行進位處理 i--; j--; } return sb.reverse().toString(); } } **可以和 371. Sum of Two Integers做比較 ","permalink":"https://pattysung1.github.io/works/leetcode-67/","tags":["leetcode","string"],"title":"Leetcode-67. Add Binary"},{"categories":["Programming"],"contents":"Given an integer x, return true if x is a palindrome , and false otherwise.\nExample 1:\nInput: x = 121 Output: true Explanation: 121 reads as 121 from left to right and from right to left. Example 2:\nInput: x = -121 Output: false Explanation: From left to right, it reads -121. From right to left, it becomes 121-. Therefore it is not a palindrome. Example 3:\nInput: x = 10 Output: false Explanation: Reads 01 from right to left. Therefore it is not a palindrome. \u0026lt;解題\u0026gt;String s = String.valueOf(x); // 將整數 x 轉換為對應的字串 class Solution { public boolean isPalindrome(int x) { String s = String.valueOf(x); // 將整數 x 轉換為對應的字串 int n = s.length(); for (int i=0; i\u0026lt;n/2; i++) { if (s.charAt(i) != s.charAt(n-i-1)) return false; //從前面往後和後面往前算 } return true; } } Time: O(N) Space: O(1)\n\u0026lt;解題\u0026gt;String s = String.valueOf(x); // 將整數 x 轉換為對應的字串 只要 x 的數字還有一半以上未處理，就繼續迴圈。在迴圈中，我們將 x 的最後一位數字取出（x % 10），然後加到 rev 的末尾，即將 rev 左移一位（rev = rev * 10 + x % 10），同時將 x 的最後一位數字去掉（x = x / 10） *x 等於 rev 右移一位後的值，實際上是在處理奇數位數的回文數的情況，確保中間的數字不會影響判斷結果。 例如，考慮回文數 12321： 當 x 變成 12，rev 變成 123，我們比較 x 和 rev 會發現它們不相等，但我們實際上應該將 x 的最後一位數（1）忽略，因為它位於回文數的中間。\nclass Solution { public boolean isPalindrome(int x) { if (x\u0026lt;0 || (x!=0 \u0026amp;\u0026amp; x%10==0)) return false; int rev = 0; while (x\u0026gt;rev){ rev = rev*10 + x%10; x = x/10; } return (x==rev || x==rev/10); } } Time: O(log(x)) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-9/","tags":["leetcode"],"title":"Leetcode-9. Palindrome Number"},{"categories":["Programming"],"contents":"Given the root of an n-ary tree, return the postorder traversal of its nodes\u0026rsquo; values.\nNary-Tree input serialization is represented in their level order traversal. Each group of children is separated by the null value (See examples)\nExample 1:\nInput: root = [1,null,3,2,4,null,5,6] Output: [5,6,3,2,4,1] Example 2:\nInput: root = [1,null,2,3,4,5,null,null,6,7,null,8,null,9,10,null,null,11,null,12,null,13,null,null,14] Output: [2,6,14,11,7,3,12,8,4,13,9,10,5,1] \u0026lt;解題\u0026gt; class Solution { public List\u0026lt;Integer\u0026gt; postorder(Node root) { List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (root == null) return res; postorder(root, res); return res; } private void postorder(Node node, List\u0026lt;Integer\u0026gt; res) { for (Node c : node.children) { postorder(c, res); } res.add(node.val); } } Time: O(n)\nSpace: O(h)\n","permalink":"https://pattysung1.github.io/works/leetcode-590/","tags":["leetcode","tree"],"title":"Leetcode-590. N-ary Tree Postorder Traversal"},{"categories":["Programming"],"contents":"You are given the root of a binary search tree (BST) and an integer val.\nFind the node in the BST that the node\u0026rsquo;s value equals val and return the subtree rooted with that node. If such a node does not exist, return null.\nExample 1:\nInput: root = [4,2,7,1,3], val = 2 Output: [2,1,3] Example 2:\nInput: root = [4,2,7,1,3], val = 5 Output: [] \u0026lt;解題\u0026gt; class Solution { public TreeNode searchBST(TreeNode root, int val) { if ( root==null) return root; if(root.val == val) return root; if(val \u0026lt; root.val){ return searchBST(root.left, val); }else{ return searchBST(root.right, val); } } } Time: O(log n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-700/","tags":["leetcode","tree"],"title":"Leetcode-700. Search in a Binary Search Tree"},{"categories":["Programming"],"contents":"Given a binary tree\nstruct Node { int val; Node *left; Node *right; Node *next; } Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.\nInitially, all next pointers are set to NULL.\nExample 1:\nInput: root = [1,2,3,4,5,null,7] Output: [1,#,2,3,#,4,5,7,#] Explanation: Given the above binary tree (Figure A), your function should populate each next pointer to point to its next right node, just like in Figure B. The serialized output is in level order as connected by the next pointers, with \u0026#39;#\u0026#39; signifying the end of each level. Example 2:\nInput: root = [] Output: [] \u0026lt;解題\u0026gt; /* // Definition for a Node. class Node { public int val; public Node left; public Node right; public Node next; public Node() {} public Node(int _val) { val = _val; } public Node(int _val, Node _left, Node _right, Node _next) { val = _val; left = _left; right = _right; next = _next; } }; */ class Solution { public Node connect(Node root) { if(root==null) return null; Node head = null; Node prev = null; Node curr = root; while(curr!=null){ while(curr!=null){ if(curr.left!=null){ if(head==null){ head = curr.left; prev = curr.left; }else{ prev.next = curr.left; prev = prev.next; } } if(curr.right!=null){ if(head==null){ head = curr.right; prev = curr.right; }else{ prev.next = curr.right; prev = prev.next; } } curr = curr.next; } curr = head; prev = null; head = null; } return root; } } Time: O(n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-117/","tags":["leetcode","tree"],"title":"Leetcode-117. Populating Next Right Pointers in Each Node II"},{"categories":["Programming"],"contents":"Given an m x n integer matrix matrix, if an element is 0, set its entire row and column to 0\u0026rsquo;s.\nYou must do it in place.\nExample 1:\nInput: matrix = [[1,1,1],[1,0,1],[1,1,1]] Output: [[1,0,1],[0,0,0],[1,0,1]] Example 2:\nInput: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]] Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]] \u0026lt;解題\u0026gt; 先建立一個mxn Array，跑迴圈，如果matrix[i][j]==0，則設置rowsArray[i]=0、colsArray[j]=0; 再跑一次迴圈，如果rowsArray[i]=0、colsArray[j]=0，則其matrix[i][j]==0 class Solution { public void setZeroes(int[][] matrix){ int m=matrix.length, n=matrix[0].length; int rowsArray[]= new int[m]; int colsArray[]= new int[n]; Arrays.fill(rowsArray,1); //rows填滿1 Arrays.fill(colsArray,1); //columns填滿1 for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;n;j++){ if(matrix[i][j]==0){ rowsArray[i]=0; colsArray[j]=0; } } } for(int i=0;i\u0026lt;m;i++){ for(int j=0;j\u0026lt;n;j++){ if(rowsArray[i]==0 || colsArray[j]==0) matrix[i][j]=0; } } } } Time: O(mn) Space: O(m+n)\n\u0026lt;解題\u0026gt; class Solution { public void setZeroes(int[][] matrix){ int m=matrix.length, n=matrix[0].length; boolean isRow0=false, isCol0=false; for(int j=0;j\u0026lt;n;j++){ if(matrix[0][j]==0) isRow0=true; } for(int i=0;i\u0026lt;m;i++){ if(matrix[i][0]==0) isCol0=true; } for(int i=1;i\u0026lt;m;i++){ for(int j=1;j\u0026lt;n;j++){ if(matrix[i][j]==0){ matrix[i][0]=0; matrix[0][j]=0; } } } for(int i=1;i\u0026lt;m;i++){ for(int j=1;j\u0026lt;n;j++){ if(matrix[0][j]==0 || matrix[i][0]==0) matrix[i][j]=0; } } if(isRow0){ for(int j=0;j\u0026lt;n;j++) matrix[0][j]=0; } if(isCol0){ for(int i=0;i\u0026lt;m;i++) matrix[i][0]=0; } } } Time: O(m*n) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-73/","tags":["leetcode","matrix"],"title":"Leetcode-73. Set Matrix Zeroes"},{"categories":["Programming"],"contents":"Given an integer numRows, return the first numRows of Pascal\u0026rsquo;s triangle.\nIn Pascal\u0026rsquo;s triangle, each number is the sum of the two numbers directly above it as shown:\nExample 1:\nInput: numRows = 5 Output: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]] Example 2:\nInput: numRows = 1 Output: [[1]] \u0026lt;解題\u0026gt; class Solution { public List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; generate(int numRows) { List\u0026lt;List\u0026lt;Integer\u0026gt;\u0026gt; triangle = new ArrayList\u0026lt;\u0026gt;(); if(numRows==0) return triangle; List\u0026lt;Integer\u0026gt; first_row = new ArrayList\u0026lt;\u0026gt;(); first_row.add(1); //第一列的1 triangle.add(first_row); for ( int i =1 ; i \u0026lt; numRows ; i++){ List\u0026lt;Integer\u0026gt; pre_row = triangle.get(i-1); List\u0026lt;Integer\u0026gt; row = new ArrayList\u0026lt;\u0026gt;(); row.add(1); //每一列先加上最前面的1 for (int j = 1 ; j \u0026lt; i ; j++ ){ row.add(pre_row.get(j-1) + pre_row.get(j)); } row.add(1); triangle.add(row); } return triangle; } } Time: O(n2) Space: O(n2)\n","permalink":"https://pattysung1.github.io/works/leetcode-118/","tags":["leetcode","ArrayList"],"title":"Leetcode-118. Pascal's Triangle"},{"categories":["Programming"],"contents":"Given a reference of a node in a connected undirected graph.\nReturn a deep copy (clone) of the graph.\nEach node in the graph contains a value (int) and a list (List[Node]) of its neighbors.\nclass Node { public int val; public List neighbors; } Test case format:\nFor simplicity, each node’s value is the same as the node’s index (1-indexed). For example, the first node with val == 1, the second node with val == 2, and so on. The graph is represented in the test case using an adjacency list.\nAn adjacency list is a collection of unordered lists used to represent a finite graph. Each list describes the set of neighbors of a node in the graph.\nThe given node will always be the first node with val = 1. You must return the copy of the given node as a reference to the cloned graph.\n-\u0026gt; 複製一個給定的 graph。可以分別用 BFS 跟 DFS 走訪每個 node 並複製，然後也將其連接的 nodes 複製並接上。 \u0026lt;解題\u0026gt; 深度優先搜索（DFS） class Solution { private Map\u0026lt;Node, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); public Node cloneGraph(Node node) { if (node == null) return null; if (map.containsKey(node)) return map.get(node); Node clone = new Node(node.val); map.put(node, clone); for (Node neighbor : node.neighbors) { clone.neighbors.add(cloneGraph(neighbor)); } return clone; } } Time: O(n) Space: O(n)\n\u0026lt;解題\u0026gt; 廣度優先搜索（BFS） class Solution { public Node cloneGraph(Node node) { if (node == null) return null; Queue\u0026lt;Node\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); Map\u0026lt;Node, Node\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); Node clone = new Node(node.val); queue.offer(node); map.put(node, clone); while (!queue.isEmpty()) { Node curr = queue.poll(); Node currClone = map.get(curr); for (Node neighbor : curr.neighbors) { if (!map.containsKey(neighbor)) { Node neighborClone = new Node(neighbor.val); map.put(neighbor, neighborClone); queue.offer(neighbor); } currClone.neighbors.add(map.get(neighbor)); } } return clone; } } Time: O(N + E)，其中N是節點數量，E是邊的數量 Space: O(N)\n","permalink":"https://pattysung1.github.io/works/leetcode-133/","tags":["leetcode","graph"],"title":"Leetcode-133. Clone Graph"},{"categories":["Programming"],"contents":"Given an m x n 2D binary grid grid which represents a map of \u0026lsquo;1\u0026rsquo;s (land) and \u0026lsquo;0\u0026rsquo;s (water), return the number of islands.\nAn island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.\nExample 1:\nInput: grid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;] ] Output: 1 Example 2:\nInput: grid = [ [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;], [\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;0\u0026#34;,\u0026#34;1\u0026#34;,\u0026#34;1\u0026#34;] ] Output: 3 \u0026lt;解題\u0026gt; 用i,j表示行列，用迴圈去找如果[i][j]==1，就用conut+1，代表找到一個島，並callBFS看看是否周圍也有地(1)連接 callBFS中，把當前的1翻成0，並找他前後左右：if(i \u0026lt;0 || i\u0026gt;=grid.length || j\u0026lt;0 || j\u0026gt;=grid[i].length || grid[i][j] ==\u0026lsquo;0\u0026rsquo;) return，代表已經沒有連續的1了 class Solution { public int numIslands(char[][] grid) { int count = 0; for(int i =0 ; i\u0026lt;grid.length; i++){ for(int j = 0 ; j\u0026lt;grid[i].length ; j++){ if(grid[i][j]==\u0026#39;1\u0026#39;){ count +=1 ; callBFS(grid, i,j); } } } return count; } public void callBFS(char[][]grid, int i, int j){ if(i \u0026lt;0 || i\u0026gt;=grid.length || j\u0026lt;0 || j\u0026gt;=grid[i].length || grid[i][j] ==\u0026#39;0\u0026#39;) return; grid[i][j] = \u0026#39;0\u0026#39;; callBFS(grid, i+1 , j);//up callBFS(grid, i-1 , j);//down callBFS(grid, i , j+1);//right callBFS(grid, i , j-1);//left } } Time: O() Space: O()\n","permalink":"https://pattysung1.github.io/works/leetcode-200/","tags":["leetcode","graph"],"title":"Leetcode-200. Number of Islands"},{"categories":["Programming"],"contents":"Given an m x n grid of characters board and a string word, return true if word exists in the grid.\nThe word can be constructed from letters of sequentially adjacent cells, where adjacent cells are horizontally or vertically neighboring. The same letter cell may not be used more than once.\nExample 1:\nInput: board = [[\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;E\u0026#34;],[\u0026#34;S\u0026#34;,\u0026#34;F\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;S\u0026#34;],[\u0026#34;A\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;E\u0026#34;]], word = \u0026#34;ABCCED\u0026#34; Output: true Example 2:\nInput: board = [[\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;E\u0026#34;],[\u0026#34;S\u0026#34;,\u0026#34;F\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;S\u0026#34;],[\u0026#34;A\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;E\u0026#34;]], word = \u0026#34;SEE\u0026#34; Output: true Example 3:\nInput: board = [[\u0026#34;A\u0026#34;,\u0026#34;B\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;E\u0026#34;],[\u0026#34;S\u0026#34;,\u0026#34;F\u0026#34;,\u0026#34;C\u0026#34;,\u0026#34;S\u0026#34;],[\u0026#34;A\u0026#34;,\u0026#34;D\u0026#34;,\u0026#34;E\u0026#34;,\u0026#34;E\u0026#34;]], word = \u0026#34;ABCB\u0026#34; Output: false -\u0026gt;題目會給一個word單字，我們要找在這個board中，是否可以找到這個字詞。有點類似Leetcode-200. Number of Islands的題目\n\u0026lt;解題\u0026gt; 方式一 可以先用迴圈來跑，看第一個char是否有在這個board當中，如果有的話，我們來搜尋這個char的前後左右有沒有符合接下來的字詞，所以我們建立一個search方法 由於被訪問過的字在同一次搜尋中，不能被再度訪問，所以我們在前面要設置一個boolean visited方法，如果被訪問到時，要設置為true。 搜尋其上下左右（index+1)，如果都符合接下來的字詞，return true，都沒有的話return false if(index == word.length())，代表已經成功找到完整的單詞匹配，所以return true public class Solution { static boolean[][] visited; public boolean exist(char[][] board, String word) { visited = new boolean[board.length][board[0].length]; for(int i = 0; i \u0026lt; board.length; i++){ for(int j = 0; j \u0026lt; board[i].length; j++){ if((word.charAt(0) == board[i][j]) \u0026amp;\u0026amp; search(board, word, i, j, 0)){ return true; } } } return false; } private boolean search(char[][]board, String word, int i, int j, int index){ if(index == word.length()){ return true; } if(i \u0026gt;= board.length || i \u0026lt; 0 || j \u0026gt;= board[i].length || j \u0026lt; 0 || board[i][j] != word.charAt(index) || visited[i][j]){ return false; } visited[i][j] = true; if(search(board, word, i-1, j, index+1) || search(board, word, i+1, j, index+1) || search(board, word, i, j-1, index+1) || search(board, word, i, j+1, index+1)){ return true; } visited[i][j] = false; return false; } } Time: O((rows * columns)^2) Space: O((rows * columns))\nDFS public class Solution { public boolean exist(char[][] board, String word) { int m = board.length; int n = board[0].length; boolean[][] visited = new boolean[m][n]; for (int i = 0; i \u0026lt; m; i++) { for (int j = 0; j \u0026lt; n; j++) { if (dfs(board, word, i, j, 0, visited)) { return true; } } } return false; } private boolean dfs(char[][] board, String word, int i, int j, int index, boolean[][] visited) { if (index == word.length()) { return true; } if (i \u0026lt; 0 || i \u0026gt;= board.length || j \u0026lt; 0 || j \u0026gt;= board[0].length || visited[i][j] || board[i][j] != word.charAt(index)) { return false; } visited[i][j] = true; if (dfs(board, word, i - 1, j, index + 1, visited) || dfs(board, word, i + 1, j, index + 1, visited) || dfs(board, word, i, j - 1, index + 1, visited) || dfs(board, word, i, j + 1, index + 1, visited)) { return true; } visited[i][j] = false; return false; } } ","permalink":"https://pattysung1.github.io/works/leetcode-79/","tags":["leetcode","graph"],"title":"Leetcode-79. Word Search"},{"categories":["Programming"],"contents":"There is an undirected star graph consisting of n nodes labeled from 1 to n. A star graph is a graph where there is one center node and exactly n - 1 edges that connect the center node with every other node.\nYou are given a 2D integer array edges where each edges[i] = [ui, vi] indicates that there is an edge between the nodes ui and vi. Return the center of the given star graph.\nExample 1:\nInput: edges = [[1,2],[2,3],[4,2]] Output: 2 Explanation: As shown in the figure above, node 2 is connected to every other node, so 2 is the center. Example 2:\nInput: edges = [[1,2],[5,1],[1,3],[1,4]] Output: 1 \u0026lt;解題\u0026gt; 和997. Find the Town Judge這個想法有點像，如果是中間的節點，代表他重複的次數等於edges.length 一開始建立陣列大小為edges.length+2，因為從1開始算，且節點數為edges長度+1 計算到的次數+1，if(count[i] == edges.length ) return i class Solution { public int findCenter(int[][] edges) { int [] count = new int [edges.length+2]; for(int[] e : edges){ count[e[0]]++; count[e[1]]++; } for(int i =1 ; i\u0026lt;edges.length+2 ; i++){ if(count[i] == edges.length ) return i; } return -1; } } Time: O(N) Space: O(N)\n","permalink":"https://pattysung1.github.io/works/leetcode-1791/","tags":["leetcode","graph"],"title":"Leetcode-1791. Find Center of Star Graph"},{"categories":["Programming"],"contents":"There is a bi-directional graph with n vertices, where each vertex is labeled from 0 to n - 1 (inclusive). The edges in the graph are represented as a 2D integer array edges, where each edges[i] = [ui, vi] denotes a bi-directional edge between vertex ui and vertex vi. Every vertex pair is connected by at most one edge, and no vertex has an edge to itself.\nYou want to determine if there is a valid path that exists from vertex source to vertex destination.\nGiven edges and the integers n, source, and destination, return true if there is a valid path from source to destination, or false otherwise.\nExample 1:\nInput: n = 3, edges = [[0,1],[1,2],[2,0]], source = 0, destination = 2 Output: true Explanation: There are two paths from vertex 0 to vertex 2: - 0 → 1 → 2 - 0 → 2 Example 2:\nInput: n = 6, edges = [[0,1],[0,2],[3,5],[5,4],[4,3]], source = 0, destination = 5 Output: false Explanation: There is no path from vertex 0 to vertex 5. \u0026lt;解題\u0026gt; 建立一個used的boolean陣列，來記錄哪些節點已被使用。 一開始，起點 start 被標記為已使用，並將 newUsedFound 設置為 true，並使用一個迴圈來尋找從起點到終點的路徑。 在每次迴圈中，程式遍歷 edges 數組中的每個邊，檢查邊的兩個節點是否有其中一個已被使用。 如果其中一個節點已被使用，則將另一個節點標記為已使用，並將 newUsedFound 設置為 true。 class Solution { public boolean validPath(int n, int[][] edges, int start, int end) { boolean[] used = new boolean[n]; used[start] = true; boolean newUsedFound = true; while (!used[end] \u0026amp;\u0026amp; newUsedFound) { newUsedFound = false; for (int i = edges.length - 1; i \u0026gt;= 0; i--) { if (used[edges[i][0]]) { if (!used[edges[i][1]]) newUsedFound = used[edges[i][1]] = true; } else if (used[edges[i][1]]) { newUsedFound = used[edges[i][0]] = true; } } } return used[end]; } } Time: O(E)-\u0026gt;邊的數量 Space: O(n)-\u0026gt;boolean[] used = new boolean[n];\n","permalink":"https://pattysung1.github.io/works/leetcode-1971/","tags":["leetcode","graph"],"title":"Leetcode-1971. Find if Path Exists in Graph"},{"categories":["Programming"],"contents":"Given a 2D integer array nums where nums[i] is a non-empty array of distinct positive integers, return the list of integers that are present in each array of nums sorted in ascending order.\nExample 1:\nInput: nums = [[3,1,2,4,5],[1,2,3,4],[3,4,5,6]] Output: [3,4] Explanation: The only integers present in each of nums[0] = [3,1,2,4,5], nums[1] = [1,2,3,4], and nums[2] = [3,4,5,6] are 3 and 4, so we return [3,4]. Example 2:\nInput: nums = [[1,2,3],[4,5,6]] Output: [] Explanation: There does not exist any integer present both in nums[0] and nums[1], so we return an empty list [].\n\u0026lt;解題\u0026gt; class Solution { public List\u0026lt;Integer\u0026gt; intersection(int[][] nums) { int[] cnt = new int[1001]; for (int[] num : nums){ for (int n: num){ cnt[n]++; } } List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); for(int i = 0 ; i \u0026lt; cnt.length; i++){ if(cnt[i] == nums.length){ res.add(i); } } return res; } } Time: O(N*M) Space: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-2248/","tags":["leetcode","array"],"title":"Leetcode-1971. Find if Path Exists in Graph"},{"categories":["Programming"],"contents":"In a town, there are n people labeled from 1 to n. There is a rumor that one of these people is secretly the town judge.\nIf the town judge exists, then:\nThe town judge trusts nobody. Everybody (except for the town judge) trusts the town judge. There is exactly one person that satisfies properties 1 and 2. You are given an array trust where trust[i] = [ai, bi] representing that the person labeled ai trusts the person labeled bi. If a trust relationship does not exist in trust array, then such a trust relationship does not exist.\nReturn the label of the town judge if the town judge exists and can be identified, or return -1 otherwise. -\u0026gt;有n個人，可能有一個法官存在，所有的人都會信任他，但法官不會信任任何人；也可能沒有法官存在。\nExample 1:\nInput: n = 2, trust = [[1,2]] Output: 2 Example 2:\nInput: n = 3, trust = [[1,3],[2,3]] Output: 3 Example 3:\nInput: n = 3, trust = [[1,3],[2,3],[3,1]] Output: -1 \u0026lt;解題\u0026gt; 建立陣列，把1~n的index放進去，所以要建立new int [n+1] 由於[a,b]，前者信任後者，所以我們可以計算t[1]後者出現的次數，每計算到一次++；而再前者t[0]出現的話，就\u0026ndash; 迴圈：如果count[i]==n-1，代表每個人都信任他，所以他是法官 class Solution { public int findJudge(int n, int[][] trust) { int [] count = new int [n+1]; for(int[] t : trust){ count[t[0]]--; //trust別人的人-- count[t[1]]++; //被trust的人++ } for(int i=1 ; i\u0026lt;=n ; i++){ if(count[i]== n-1) return i; } return -1; } } Time: O(N) Space: O(N)\n","permalink":"https://pattysung1.github.io/works/leetcode-997/","tags":["leetcode","graph"],"title":"Leetcode-997. Find the Town Judge"},{"categories":["Programming"],"contents":"Given the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\nExample 1: Input: root = [3,1,4,null,2], k = 1 Output: 1 Example 2: Input: root = [5,3,6,2,4,null,null,1], k = 3 Output: 3 \u0026lt;解題\u0026gt; 用count 用於計數遍歷到的節點數量，變數 result 用於儲存第 k 小的節點的值 在每次遞迴中，先遞迴處理左子樹，然後對當前節點進行計數 count++。如果 count 等於 k，表示已經遍歷到第 k 個節點，將當前節點的值給 result。最後，遞迴處理右子樹。 當遍歷結束後，變數 result 將保存第 k 小的元素的值，並在 kthSmallest 方法中返回。 Recursive:\nclass Solution { int count = 0; int result = Integer.MIN_VALUE; public int kthSmallest(TreeNode root, int k) { traverse(root, k); return result; } public void traverse(TreeNode root, int k) { if(root == null) return; traverse(root.left, k); count ++; if(count == k) result = root.val; traverse(root.right, k); } } Time: O(n) Space: O(n)\nIterative:\nclass Solution { public int kthSmallest(TreeNode root, int k) { Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;TreeNode\u0026gt;(); int count = 0; while(!stack.isEmpty() || root != null) { if(root != null) { stack.push(root); // Just like recursion root = root.left; } else { TreeNode node = stack.pop(); if(++count == k) return node.val; root = node.right; } } return Integer.MIN_VALUE; } } class Solution { public int kthSmallest(TreeNode root, int k) { Stack\u0026lt;TreeNode\u0026gt; stack = new Stack\u0026lt;TreeNode\u0026gt;(); while (true){ while (root != null){ stack.push(root); root = root.left; } root = stack.pop(); if (--k == 0) return root.val; root = root.right; } } } ","permalink":"https://pattysung1.github.io/works/leetcode-230/","tags":["leetcode","tree"],"title":"Leetcode-230. Kth Smallest Element in a BST"},{"categories":["Programming"],"contents":"Given the root of a binary tree, check whether it is a mirror of itself (i.e., symmetric around its center).\nExample 1:\nInput: root = [1,2,2,3,4,4,3] Output: true Example 2:\nInput: root = [1,2,2,null,3,null,3] Output: false \u0026lt;解題\u0026gt; 如果root==null，直接為ture，沒有的話用isSymmetricHelp一一檢查其左右子節點 isSymmetricHelp： a. 左子樹 left 和右子樹 right 都為空，表示當前的節點的左右子樹均為空，即對稱性保持，返回 true。 b. 如果左子樹 left 和右子樹 right 中只有其中一個為空，而另一個不為空，表示左右子樹的結構不對稱，返回 false。 c. return isSymmetricHelp(left.left, right.right) \u0026amp;\u0026amp; isSymmetricHelp(left.right, right.left); public boolean isSymmetric(TreeNode root) { return root==null || isSymmetricHelp(root.left, root.right); } private boolean isSymmetricHelp(TreeNode left, TreeNode right){ if(left==null || right==null) return left==right; if(left.val!=right.val) return false; return isSymmetricHelp(left.left, right.right) \u0026amp;\u0026amp; isSymmetricHelp(left.right, right.left); } Time: O(N) Space: O(H)\n","permalink":"https://pattysung1.github.io/works/leetcode-101/","tags":["leetcode","tree"],"title":"Leetcode-101. Symmetric Tree"},{"categories":["Programming"],"contents":"Given the root of a binary tree and an integer targetSum, return true if the tree has a root-to-leaf path such that adding up all the values along the path equals targetSum.\nA leaf is a node with no children.\nExample 1:\nInput: root = [5,4,8,11,null,13,4,7,2,null,null,null,1], targetSum = 22 Output: true Explanation: The root-to-leaf path with the target sum is shown. Example 2:\nInput: root = [1,2,3], targetSum = 5 Output: false Explanation: There two root-to-leaf paths in the tree: (1 --\u0026gt; 2): The sum is 3. (1 --\u0026gt; 3): The sum is 4. There is no root-to-leaf path with sum = 5. Example 3:\nInput: root = [], targetSum = 0 Output: false Explanation: Since the tree is empty, there are no root-to-leaf paths. \u0026lt;解題\u0026gt; 如果root==null，return false if(root.left == null \u0026amp;\u0026amp; root.right == null \u0026amp;\u0026amp; sum - root.val == 0) return true; 如果以上兩個條件都不滿足，則遞迴地檢查左子樹和右子樹。將目標和減去當前節點的值，並遞迴調用 hasPathSum 方法。如果左子樹或右子樹中存在滿足條件的路徑，即存在從根節點到葉子節點的路徑使得總和等於目標和，則返回 true。 public class Solution { public boolean hasPathSum(TreeNode root, int sum) { if(root == null) return false; if(root.left == null \u0026amp;\u0026amp; root.right == null \u0026amp;\u0026amp; sum - root.val == 0) return true; return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val); } } Time: O(n) Space: O(H)\npublic class Solution { public boolean hasPathSum(TreeNode root, int sum) { // iteration method if (root == null) {return false;} Stack\u0026lt;TreeNode\u0026gt; node_stack = new Stack\u0026lt;\u0026gt;(); Stack\u0026lt;Integer\u0026gt; sum_stack = new Stack\u0026lt;\u0026gt;(); node_stack.push(root); sum_stack.push(sum-root.val); while(!node_stack.isEmpty()){ TreeNode current_node = node_stack.pop(); int current_sum = sum_stack.pop(); if(current_node.left==null \u0026amp;\u0026amp; current_node.right==null \u0026amp;\u0026amp; current_sum ==0){ return true; } if(current_node.left!=null){ node_stack.push(current_node.left); sum_stack.push(current_sum-current_node.left.val); } if(current_node.right!=null){ node_stack.push(current_node.right); sum_stack.push(current_sum-current_node.right.val); } } return false; } } ","permalink":"https://pattysung1.github.io/works/leetcode-112/","tags":["leetcode","tree"],"title":"Leetcode-112. Path Sum"},{"categories":["Programming"],"contents":"Given a binary search tree (BST), find the lowest common ancestor (LCA) node of two given nodes in the BST.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nExample 1:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 8 Output: 6 Explanation: The LCA of nodes 2 and 8 is 6. Example 2:\nInput: root = [6,2,8,0,4,7,9,null,null,3,5], p = 2, q = 4 Output: 2 Explanation: The LCA of nodes 2 and 4 is 2, since a node can be a descendant of itself according to the LCA definition. Example 3:\nInput: root = [2,1], p = 2, q = 1 Output: 2 \u0026lt;解題\u0026gt;方法一 因為是Binary Search Tree，所以可以用val的方式做思考（左小右大），如果： a. if(p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) ：從root.left找 b. if(p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) ：從root.right找 c. p,q分別在左、右，直接返回root public class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(p.val \u0026lt; root.val \u0026amp;\u0026amp; q.val \u0026lt; root.val) { return lowestCommonAncestor(root.left , p ,q); } if(p.val \u0026gt; root.val \u0026amp;\u0026amp; q.val \u0026gt; root.val) { return lowestCommonAncestor(root.right , p ,q); } return root; } } Time: O(N) Space: O(H)\n\u0026lt;解題\u0026gt;方法二 和236二元樹一樣的思考方式： public class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left != null \u0026amp;\u0026amp; right != null) return root; return left != null ? left : right; } } Time: O(H) -\u0026gt; log(n) Space: O(H)\n此題可和Leetcode-236. Lowest Common Ancestor of a Binary Tree做比較\n","permalink":"https://pattysung1.github.io/works/leetcode-235/","tags":["leetcode","tree"],"title":"Leetcode-235. Lowest Common Ancestor of a Binary Search Tree"},{"categories":["Programming"],"contents":"Given a binary tree, find the lowest common ancestor (LCA) of two given nodes in the tree.\nAccording to the definition of LCA on Wikipedia: “The lowest common ancestor is defined between two nodes p and q as the lowest node in T that has both p and q as descendants (where we allow a node to be a descendant of itself).”\nExample 1:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 1 Output: 3 Explanation: The LCA of nodes 5 and 1 is 3. Example 2:\nInput: root = [3,5,1,6,2,0,8,null,null,7,4], p = 5, q = 4 Output: 5 Explanation: The LCA of nodes 5 and 4 is 5, since a node can be a descendant of itself according to the LCA definition. Example 3:\nInput: root = [1,2], p = 1, q = 2 Output: 1 \u0026lt;解題\u0026gt; 如果(root == null || root == p || root == q) return root，直接是他自己本身 建立左、右邊的尋找方式 public class Solution { public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) { if(root == null || root == p || root == q) return root; TreeNode left = lowestCommonAncestor(root.left, p, q); TreeNode right = lowestCommonAncestor(root.right, p, q); if(left != null \u0026amp;\u0026amp; right != null) return root; //表示 p 和 q 分別在左子樹和右子樹中 return left != null ? left : right; //表示 p 和 q 同時存在於左子樹或右子樹中，或者其中一個節點是另一個節點的祖先。 } } Time: O(N) Space: O(H)\n此題可和Leetcode-235. Lowest Common Ancestor of a Binary Search Tree做比較\n","permalink":"https://pattysung1.github.io/works/leetcode-236/","tags":["leetcode","tree"],"title":"Leetcode-236. Lowest Common Ancestor of a Binary Tree"},{"categories":["Programming"],"contents":"Given the root of a Binary Search Tree (BST), return the minimum absolute difference between the values of any two different nodes in the tree.\nExample 1:\nInput: root = [4,2,6,1,3] Output: 1 Example 2:\nInput: root = [1,0,48,null,null,12,49] Output: 1 \u0026lt;解題\u0026gt; 由於是InOrder，所以已經sorted了，故從左邊開始至右邊 去計算兩兩相減的值並更新至min，且更新prev的值 public class Solution { int min = Integer.MAX_VALUE; Integer prev = null; public int getMinimumDifference(TreeNode root) { if (root == null) return min; getMinimumDifference(root.left); if (prev != null) { min = Math.min(min, root.val - prev); } prev = root.val; getMinimumDifference(root.right); return min; } } In-Order traverse Time complexity: O(N) Space complexity: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-530/","tags":["leetcode","tree"],"title":"Leetcode-530. Minimum Absolute Difference in BST"},{"categories":["Programming"],"contents":"Given the root of a binary tree, return the average value of the nodes on each level in the form of an array. Answers within 10-5 of the actual answer will be accepted.\nExample 1:\nInput: root = [3,9,20,null,null,15,7] Output: [3.00000,14.50000,11.00000] Explanation: The average value of nodes on level 0 is 3, on level 1 is 14.5, and on level 2 is 11. Hence return [3, 14.5, 11]. Example 2:\nInput: root = [3,9,20,15,7] Output: [3.00000,14.50000,11.00000] \u0026lt;解題\u0026gt; .offer(root) 是將元素添加到隊列的操作，用於初始化遍歷二叉樹的起始節點。 先用Queue把root加入，以及一個ArrayList存之後要回傳的陣列 當queue.size()\u0026gt;0，跑迴圈去計算每列的sum，若當前節點的左右節點非為空，則將它們加入queue中 計算每列平均 class Solution { public List\u0026lt;Double\u0026gt; averageOfLevels(TreeNode root) { List\u0026lt;Double\u0026gt; result = new ArrayList\u0026lt;\u0026gt;(); Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(List.of(root)); //queue.offer(root); while(queue.size()\u0026gt;0){ double size = queue.size(),level_sum = 0; for(int i =0 ; i\u0026lt;size;i++){ TreeNode current = queue.poll(); level_sum += current.val; if(current.left != null) queue.offer(current.left); if(current.right != null) queue.offer(current.right); } double level_avg = level_sum/ size; result.add(level_avg); } return result; } } Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); q.offer(root); 可以寫成： Queue\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(List.of(root)); ","permalink":"https://pattysung1.github.io/works/leetcode-637/","tags":["leetcode","tree","queue"],"title":"Leetcode-637. Average of Levels in Binary Tree"},{"categories":["Programming"],"contents":"Given the roots of two binary trees p and q, write a function to check if they are the same or not.\nTwo binary trees are considered the same if they are structurally identical, and the nodes have the same value.\nExample 1:\nInput: p = [1,2,3], q = [1,2,3] Output: true Example 2:\nInput: p = [1,2], q = [1,null,2] Output: false Example 3:\nInput: p = [1,2,1], q = [1,1,2] Output: false \u0026lt;解題\u0026gt; 如果兩者皆null，則相同true 只有任一null，則false p.val != q.val，則false return 判斷兩者左子樹與右子樹是否相同 class Solution { public boolean isSameTree(TreeNode p, TreeNode q) { // If both p and q are null, then they are the same tree if (p == null \u0026amp;\u0026amp; q == null) return true; // If only one of p and q is null, then they are not the same tree if (p == null || q == null) return false; // If the values of p and q are different, then they are not the same tree if (p.val != q.val) return false; // Recursively check the left and right subtrees of p and q // If both the left and right subtrees are the same, then p and q are the same tree return isSameTree(p.left, q.left) \u0026amp;\u0026amp; isSameTree(p.right, q.right); } } ","permalink":"https://pattysung1.github.io/works/leetcode-100/","tags":["leetcode","tree"],"title":"Leetcode-100. Same Tree"},{"categories":["Programming"],"contents":"Given a binary tree, determine if it is height-balanced.\nExample 1:\nInput: root = [3,9,20,null,null,15,7] Output: true Example 2: Input: root = [1,2,2,3,3,null,null,4,4] Output: false Example 3:\nInput: root = [] Output: true \u0026lt;解題\u0026gt; Height Function如果return -1，代表是不平衡樹 用遞迴方式，去計算左子樹和右子數的分別高度 class Solution { public boolean isBalanced(TreeNode root) { if (root == null) return true; // Height Function will return -1, when it’s an unbalanced tree... if (Height(root) == -1) return false; return true; } public int Height(TreeNode root) { if (root == null) return 0; int leftHeight = Height(root.left); int rightHight = Height(root.right); // In case of left subtree or right subtree unbalanced, return -1... if (leftHeight == -1 || rightHight == -1) return -1; // If their heights differ by more than ‘1’, return -1... if (Math.abs(leftHeight - rightHight) \u0026gt; 1) return -1; // Otherwise, return the height of this subtree as max(leftHeight, rightHight) + 1... return Math.max(leftHeight, rightHight) + 1; } } Time：O(N) Space：O(H)\n單純計算節點的高度 public int height(TreeNode node) { // 如果節點為空，返回高度 0 if (node == null) { return 0; } // 遞歸計算左子樹的高度 int leftHeight = height(node.left); // 遞歸計算右子樹的高度 int rightHeight = height(node.right); // 返回左子樹和右子樹中較大的高度加 1 return Math.max(leftHeight, rightHeight) + 1; } ","permalink":"https://pattysung1.github.io/works/leetcode-110/","tags":["leetcode","tree"],"title":"Leetcode-110. Balanced Binary Tree"},{"categories":["Programming"],"contents":"Given the roots of two binary trees root and subRoot, return true if there is a subtree of root with the same structure and node values of subRoot and false otherwise.\nA subtree of a binary tree tree is a tree that consists of a node in tree and all of this node\u0026rsquo;s descendants. The tree tree could also be considered as a subtree of itself.\nExample 1:\nInput: root = [3,4,5,1,2], subRoot = [4,1,2] Output: true Example 2:\nInput: root = [3,4,5,1,2,null,null,null,null,0], subRoot = [4,1,2] Output: false \u0026lt;解題\u0026gt; 首先檢查 s 是否為空，如果是，則檢查 t 是否也為空，如果是，則返回 true，表示 t 是空樹也是 s 的子樹。 用isSame(s, t)，判斷兩者是否相同，相同的話t就是s的子樹；若不相同，再來用遞迴方式看左子樹或右子樹是否有包含t class Solution { public boolean isSubtree(TreeNode s, TreeNode t) { if (s == null) { return t == null; } return isSame(s, t) || isSubtree(s.left, t) || isSubtree(s.right, t); } private boolean isSame(TreeNode t1, TreeNode t2) { if (t1 == null \u0026amp;\u0026amp; t2 == null) return true; if (t1 == null || t2 == null) return false; if (t1.val != t2.val) return false; return isSame(t1.left, t2.left) \u0026amp;\u0026amp; isSame(t1.right, t2.right); } } Time: O(mxn) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-572/","tags":["leetcode","tree"],"title":"Leetcode-572. Subtree of Another Tree"},{"categories":["Programming"],"contents":"在使用 Java 的 Queue 接口時，可以使用以下方法進行操作： offer(element): 將元素插入到佇列的尾部，如果成功插入，返回 true；如果無法插入（例如因為佇列已滿），返回 false。\nadd(element): 將元素插入到佇列的尾部，如果成功插入，返回 true；如果無法插入（例如因為佇列已滿），則拋出一個 unchecked 異常（IllegalStateException）。\npoll(): 移除並返回佇列的頭部元素，如果佇列為空，則返回 null。\nremove(): 移除並返回佇列的頭部元素，如果佇列為空，則拋出一個異常（NoSuchElementException）。\npeek(): 返回佇列的頭部元素，但不移除該元素，如果佇列為空，則返回 null。\nelement(): 返回佇列的頭部元素，但不移除該元素，如果佇列為空，則拋出一個異常（NoSuchElementException）。\npublic class Main { public static void main(String[] args) { //add()和remove()方法在失败的时候会抛出异常(不推荐) Queue\u0026lt;String\u0026gt; queue = new LinkedList\u0026lt;String\u0026gt;(); //添加元素 queue.offer(\u0026#34;a\u0026#34;); queue.offer(\u0026#34;b\u0026#34;); queue.offer(\u0026#34;c\u0026#34;); queue.offer(\u0026#34;d\u0026#34;); queue.offer(\u0026#34;e\u0026#34;); for(String q : queue){ System.out.println(q); } System.out.println(\u0026#34;===\u0026#34;); System.out.println(\u0026#34;poll=\u0026#34;+queue.poll()); //返回第一个元素，并在队列中删除 for(String q : queue){ System.out.println(q); } System.out.println(\u0026#34;===\u0026#34;); System.out.println(\u0026#34;element=\u0026#34;+queue.element()); //返回第一个元素 for(String q : queue){ System.out.println(q); } System.out.println(\u0026#34;===\u0026#34;); System.out.println(\u0026#34;peek=\u0026#34;+queue.peek()); //返回第一个元素 for(String q : queue){ System.out.println(q); } } } 輸出結果： a b c d e === poll=a b c d e === element=b b c d e === peek=b b c d e 資料來源：https://www.runoob.com/java/data-queue.html\nPriority Queue public class Main{ public static void main(String args[]) { //Priority Queue = A FIFO data structure that serves elements // with the highest priorities first //\tbefore elements with lower priority //Strings in default order Queue\u0026lt;String\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;(); //Strings in reverse order Queue\u0026lt;String\u0026gt; queue = new PriorityQueue\u0026lt;\u0026gt;(Collections.reverseOrder()); queue.offer(\u0026#34;B\u0026#34;); queue.offer(\u0026#34;C\u0026#34;); queue.offer(\u0026#34;A\u0026#34;); queue.offer(\u0026#34;F\u0026#34;); queue.offer(\u0026#34;D\u0026#34;); while(!queue.isEmpty()) { System.out.println(queue.poll()); } } } ","permalink":"https://pattysung1.github.io/works/queue/","tags":["leetcode","tree"],"title":"Queue"},{"categories":["Programming"],"contents":"Given the root of a binary tree, return its maximum depth.\nA binary tree\u0026rsquo;s maximum depth is the number of nodes along the longest path from the root node down to the farthest leaf node. -\u0026gt;給定一個二元樹並找到它的最大深度，最大深度是指從最上層節點至最下層節點之間所經過的節點數。\nExample 1:\nInput: root = [3,9,20,null,null,15,7] Output: 3 Example 2:\nInput: root = [1,null,2] Output: 2 \u0026lt;解題\u0026gt; 找左子樹的深度和右子樹的深度較大的 class Solution { public int maxDepth(TreeNode root) { if(root==null){ return 0; } return 1+Math.max(maxDepth(root.left),maxDepth(root.right)); } } Time complexity: O(n) Space complexity: O(n)\nclass Solution { public int maxDepth(TreeNode root) { if(root == null) { return 0; } Queue\u0026lt;TreeNode\u0026gt; queue = new LinkedList\u0026lt;\u0026gt;(); queue.offer(root); int count = 0; while(!queue.isEmpty()) { int size = queue.size(); while(size-- \u0026gt; 0) { TreeNode node = queue.poll(); if(node.left != null) { queue.offer(node.left); } if(node.right != null) { queue.offer(node.right); } } count++; } return count; } } ","permalink":"https://pattysung1.github.io/works/leetcode-104/","tags":["leetcode","tree"],"title":"Leetcode-104. Maximum Depth of Binary Tree"},{"categories":["Programming"],"contents":"Given the root of a binary tree, invert the tree, and return its root.\nExample 1: Input: root = [4,2,7,1,3,6,9] Output: [4,7,2,9,6,3,1] Example 2: Input: root = [2,1,3] Output: [2,3,1] Example 3:\nInput: root = [] Output: [] \u0026lt;解題\u0026gt; 把root都存在LinkedList裏，用poll方法去從root開始去取出 *poll方法，用於從列表的頭部（也就是第一個元素）移除並返回該元素 如果該節點的左子樹不為空，將左子樹加入隊列中。 如果該節點的右子樹不為空，將右子樹加入隊列中。 交換該節點的左右子樹。 class Solution { public TreeNode invertTree(TreeNode root) { LinkedList\u0026lt;TreeNode\u0026gt; q = new LinkedList\u0026lt;TreeNode\u0026gt;(); if(root != null){ q.add(root); } while(!q.isEmpty()){ // Dequeue front node TreeNode temp = q.poll(); // Enqueue left child of the popped node if(temp.left != null) q.add(temp.left); // Enqueue right child of the popped node if(temp.right != null) q.add(temp.right); // 左右互換 TreeNode curr = temp.left; temp.left = temp.right; temp.right = curr; } return root; } } Time Complexity : O(n) Space Complexity : O(n)\n補充 class Solution { public TreeNode invertTree(TreeNode root) { if (root == null) return null; TreeNode left = invertTree(root.left); TreeNode right = invertTree(root.right); root.left = right; root.right = left; return root; } } ","permalink":"https://pattysung1.github.io/works/leetcode-226/","tags":["leetcode","tree"],"title":"Leetcode-226. Invert Binary Tree"},{"categories":["Programming"],"contents":"Given an integer array of size n, find all elements that appear more than ⌊ n/3 ⌋ times.\nExample 1:\nInput: nums = [3,2,3] Output: [3]\nExample 2:\nInput: nums = [1] Output: [1] Example 3:\nInput: nums = [1,2] Output: [1,2]\n\u0026lt;解題\u0026gt; class Solution { public List\u0026lt;Integer\u0026gt; majorityElement(int[] nums) { int ele1 = 0, ele2 = 0, vote1 = 0, vote2 = 0; for (int num: nums){ if (ele1 == num \u0026amp;\u0026amp; vote1 \u0026gt; 0){ vote1 += 1; } else if (ele2 == num \u0026amp;\u0026amp; vote2 \u0026gt;0){ vote2 += 1; } else if (vote1 == 0){ ele1 = num; vote1 = 1; } else if (vote2 ==0){ ele2 = num; vote2 = 1; } else { vote1 -= 1; vote2 -= 1; } } int cnt1 = 0, cnt2 =0; for (int num : nums){ if(num == ele1){ cnt1 += 1; } else if (num == ele2){ cnt2 += 1; } } List\u0026lt;Integer\u0026gt; res = new ArrayList\u0026lt;\u0026gt;(); if (cnt1 \u0026gt; nums.length / 3){ res.add(ele1); } if (cnt2 \u0026gt; nums.length / 3){ res.add(ele2); } return res; } } Time Complexity : O(n) Space Complexity : O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-229/","tags":["leetcode","array"],"title":"Leetcode-229. Majority Element II"},{"categories":["Programming"],"contents":"Given a string s, find the first non-repeating character in it and return its index. If it does not exist, return -1.\nExample 1:\nInput: s = \u0026#34;leetcode\u0026#34; Output: 0 Example 2:\nInput: s = \u0026#34;loveleetcode\u0026#34; Output: 2 Example 3:\nInput: s = \u0026#34;aabb\u0026#34; Output: -1 \u0026lt;解題\u0026gt; 像是之前做過和String算頻率的題目類似，所以可以先計算各個字母出現的頻率 在一個迴圈從頭開始算頻率為1的字母 public class Solution { public int firstUniqChar(String s) { int freq [] = new int[26]; for(int i = 0; i \u0026lt; s.length(); i ++) freq [s.charAt(i) - \u0026#39;a\u0026#39;] ++; for(int i = 0; i \u0026lt; s.length(); i ++) if(freq [s.charAt(i) - \u0026#39;a\u0026#39;] == 1) return i; return -1; } } ","permalink":"https://pattysung1.github.io/works/leetcode-387/","tags":["leetcode"],"title":"Leetcode-387. First Unique Character in a String"},{"categories":["Programming"],"contents":"Given the root of a binary tree, return the length of the diameter of the tree.\nThe diameter of a binary tree is the length of the longest path between any two nodes in a tree. This path may or may not pass through the root.\nThe length of a path between two nodes is represented by the number of edges between them. -\u0026gt;找diameter：為兩個節點中的最長路徑\nExample 1:\nInput: root = [1,2,3,4,5] Output: 3 Explanation: 3 is the length of the path [4,2,1,3] or [5,2,1,3]. Example 2:\nInput: root = [1,2] Output: 1 \u0026lt;解題\u0026gt; 用calculateHeight來計算root的高度及最大直徑值。 在calculateHeight中，先分別用遞迴計算左節點高度、右節點高度 接著，更新最大直徑：Math.max(目前最大直徑,左右高度相加) 接著，返回節點的高度 最後，將答案最大直徑maxDiameter返回 class Solution { private int maxDiameter = 0; public int diameterOfBinaryTree(TreeNode root) { calculateHeight(root); return maxDiameter; } private int calculateHeight(TreeNode node) { if (node == null) { return 0; } int leftHeight = calculateHeight(node.left); int rightHeight = calculateHeight(node.right); // 更新最大直徑 maxDiameter = Math.max(maxDiameter, leftHeight + rightHeight); // 返回節點的高度 return Math.max(leftHeight, rightHeight) + 1; } } Time：O(N) Space：O(H)(樹的高度)\n","permalink":"https://pattysung1.github.io/works/leetcode-543/","tags":["leetcode","tree"],"title":"Leetcode-543. Diameter of Binary Tree"},{"categories":["Programming"],"contents":"Given an array of integers nums which is sorted in ascending order, and an integer target, write a function to search target in nums. If target exists, then return its index. Otherwise, return -1.\nYou must write an algorithm with O(log n) runtime complexity.\nExample 1:\nInput: nums = [-1,0,3,5,9,12], target = 9 Output: 4 Explanation: 9 exists in nums and its index is 4 Example 2:\nInput: nums = [-1,0,3,5,9,12], target = 2 Output: -1 Explanation: 2 does not exist in nums so return -1 \u0026lt;解題\u0026gt;用二元搜尋法找到目標值 1.先比較數列中間值與目標值，若相等則回傳中間值的索引。 2.若中間值大於目標值，搜尋從左半部分(前半)。 3.若中間值小於目標值，搜尋從右半部分(後半)。\nclass Solution { public int search(int[] nums, int target) { int index = -1; int begin = 0, end = nums.length - 1, middle = (end + begin) / 2; while (begin \u0026lt;= end) { if (nums[middle] == target) { return middle; } else if (nums[middle] \u0026gt; target) { end = middle - 1; } else if (nums[middle] \u0026lt; target) { begin = middle + 1; } middle = (end + begin) / 2; } return index; } } 可以和35. Search Insert Position做比較 ","permalink":"https://pattysung1.github.io/works/leetcode-704/","tags":["leetcode","tree","BST"],"title":"Leetcode-704. Binary Search"},{"categories":["Programming"],"contents":"Given the head of a singly linked list, return true if it is a palindrome or false otherwise.\nExample 1: Input: head = [1,2,2,1] Output: true\nExample 2:\nInput: head = [1,2] Output: false \u0026lt;解題\u0026gt; 1.把LinkedList分成一半來判斷 \u0026lt;說明\u0026gt;\n把LinkedList分成一半 反轉其中一半 從頭開始比較每個節點的值，如果不同就return false；如果全部都相同就return true class Solution { public boolean isPalindrome(ListNode head) { if (head == null || head.next == null) { return true; } ListNode fast = head; ListNode slow = head; while (fast.next != null \u0026amp;\u0026amp; fast.next.next != null) { fast = fast.next.next; slow = slow.next; } ListNode secondHalf = reverse(slow.next); while (secondHalf != null) { if (head.val != secondHalf.val) { return false; } head = head.next; secondHalf = secondHalf.next; } return true; } public ListNode reverse(ListNode head) { ListNode prev = null; while (head != null) { ListNode next = head.next; head.next = prev; prev = head; head = next; } return prev; } } Time: O(n) Space: O(1)\n2. 用兩指標分別從頭尾往內跑，檢驗是否相等 class Solution { public boolean isPalindrome(ListNode head) { if(head == null | head.next ==null) return true; List\u0026lt;Integer\u0026gt; l = new ArrayList\u0026lt;\u0026gt;(); while(head!=null){ l.add(head.val); head = head.next; } int start =0 , end = l.size()-1; while(start\u0026lt;end){ if(l.get(start)!= l.get(end)) return false; start++; end--; } return true; } } Time: O(n) Space: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-234/","tags":["leetcode"],"title":"Leetcode-234. Palindrome Linked List"},{"categories":["Programming"],"contents":"Given a string path, which is an absolute path (starting with a slash \u0026lsquo;/\u0026rsquo;) to a file or directory in a Unix-style file system, convert it to the simplified canonical path.\nIn a Unix-style file system, a period \u0026lsquo;.\u0026rsquo; refers to the current directory, a double period \u0026lsquo;..\u0026rsquo; refers to the directory up a level, and any multiple consecutive slashes (i.e. \u0026lsquo;//\u0026rsquo;) are treated as a single slash \u0026lsquo;/\u0026rsquo;. For this problem, any other format of periods such as \u0026lsquo;\u0026hellip;\u0026rsquo; are treated as file/directory names.\nThe canonical path should have the following format:\nThe path starts with a single slash \u0026lsquo;/\u0026rsquo;. Any two directories are separated by a single slash \u0026lsquo;/\u0026rsquo;. The path does not end with a trailing \u0026lsquo;/\u0026rsquo;. The path only contains the directories on the path from the root directory to the target file or directory (i.e., no period \u0026lsquo;.\u0026rsquo; or double period \u0026lsquo;..\u0026rsquo;) Return the simplified canonical path.\nExample 1:\nInput: path = \u0026#34;/home/\u0026#34; Output: \u0026#34;/home\u0026#34; Explanation: Note that there is no trailing slash after the last directory name. Example 2:\nInput: path = \u0026#34;/../\u0026#34; Output: \u0026#34;/\u0026#34; Explanation: Going one level up from the root directory is a no-op, as the root level is the highest level you can go. Example 3:\nInput: path = \u0026#34;/home//foo/\u0026#34; Output: \u0026#34;/home/foo\u0026#34; Explanation: In the canonical path, multiple consecutive slashes are replaced by a single one. \u0026lt;解題\u0026gt; 1. 用Stack class Solution { public String simplifyPath(String path) { Deque\u0026lt;String\u0026gt; stack = new LinkedList\u0026lt;\u0026gt;(); Set\u0026lt;String\u0026gt; skip = new HashSet\u0026lt;\u0026gt;(Arrays.asList(\u0026#34;..\u0026#34;, \u0026#34;.\u0026#34;, \u0026#34;\u0026#34;)); StringBuilder sb = new StringBuilder(); String[] dirs = path.split(\u0026#34;/\u0026#34;); for (String dir : dirs) { if (dir.equals(\u0026#34;..\u0026#34;) \u0026amp;\u0026amp; !stack.isEmpty()) { stack.pop(); } else if (!skip.contains(dir)) { stack.push(dir); } } while (!stack.isEmpty()) { sb.insert(0, \u0026#34;/\u0026#34; + stack.pop()); } return sb.length() == 0 ? \u0026#34;/\u0026#34; : sb.toString(); } } 2. 用使用兩個指針i和prevSlash來遍歷路徑的每個字符 class Solution { public String simplifyPath(String path) { StringBuilder sb = new StringBuilder(); int n = path.length(); int i = 0; while (i \u0026lt; n) { // 跳過多餘的斜線 while (i \u0026lt; n \u0026amp;\u0026amp; path.charAt(i) == \u0026#39;/\u0026#39;) { i++; } // 構建當前目錄名稱 StringBuilder curr = new StringBuilder(); while (i \u0026lt; n \u0026amp;\u0026amp; path.charAt(i) != \u0026#39;/\u0026#39;) { curr.append(path.charAt(i)); i++; } String dir = curr.toString(); // 處理目錄名稱 if (dir.equals(\u0026#34;..\u0026#34;)) { if (sb.length() \u0026gt; 0) { int prevSlash = sb.lastIndexOf(\u0026#34;/\u0026#34;); sb.delete(prevSlash, sb.length()); } } else if (!dir.equals(\u0026#34;.\u0026#34;) \u0026amp;\u0026amp; !dir.isEmpty()) { sb.append(\u0026#34;/\u0026#34;).append(dir); } } return sb.length() == 0 ? \u0026#34;/\u0026#34; : sb.toString(); } } Time: O(n) Space: O(m)\n","permalink":"https://pattysung1.github.io/works/leetcode-71/","tags":["leetcode","Stack"],"title":"Leetcode-71. Simplify Path"},{"categories":["Programming"],"contents":"Given a string s containing just the characters \u0026lsquo;(\u0026rsquo;, \u0026lsquo;)\u0026rsquo;, \u0026lsquo;{\u0026rsquo;, \u0026lsquo;}\u0026rsquo;, \u0026lsquo;[\u0026rsquo; and \u0026lsquo;]\u0026rsquo;, determine if the input string is valid.\nAn input string is valid if:\nOpen brackets must be closed by the same type of brackets. Open brackets must be closed in the correct order. Every close bracket has a corresponding open bracket of the same type.\nExample 1:\nInput: s = \u0026#34;()\u0026#34; Output: true Example 2:\nInput: s = \u0026#34;()[]{}\u0026#34; Output: true Example 3:\nInput: s = \u0026#34;(]\u0026#34; Output: false Example 4: 自己做的測試\nInput: s =\u0026#34;([{])}\u0026#34; Output: false -\u0026gt;所以一定要剛好一個相同的符號正反一對，不然會return false\n\u0026lt;解題\u0026gt; 一定要剛好一個相同的符號正反一對，不然會return false 先把正的符號先push進去stack 如果有一樣的反符號配對，且剛好在最上面的話，就pop出來；不然就false 最後如果都有成對，stack就是空的，所以stack.isEmpty()=true返回 class Solution { public boolean isValid(String s) { if(s.length()%2!=0) return false; Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;\u0026gt;(); //Deque\u0026lt;String\u0026gt; stack = new ArrayDeque\u0026lt;\u0026gt;(); for (char c : s.toCharArray()) { if (c == \u0026#39;(\u0026#39;|| c ==\u0026#39;{\u0026#39; || c==\u0026#39;[\u0026#39;){ stack.push(c); } else if (c ==\u0026#39;}\u0026#39; \u0026amp;\u0026amp; !stack.isEmpty() \u0026amp;\u0026amp; stack.peek()==\u0026#39;{\u0026#39;){ stack.pop(); } else if (c ==\u0026#39;]\u0026#39; \u0026amp;\u0026amp; !stack.isEmpty() \u0026amp;\u0026amp; stack.peek()==\u0026#39;[\u0026#39;){ stack.pop(); } else if (c ==\u0026#39;)\u0026#39; \u0026amp;\u0026amp; !stack.isEmpty() \u0026amp;\u0026amp; stack.peek()==\u0026#39;(\u0026#39;){ stack.pop(); } else{ return false; } } return stack.isEmpty(); } } class Solution { public boolean isValid(String s) { Stack\u0026lt;Character\u0026gt; stack = new Stack\u0026lt;Character\u0026gt;(); for (char c : s.toCharArray()) { if (c == \u0026#39;(\u0026#39;) stack.push(\u0026#39;)\u0026#39;); else if (c == \u0026#39;{\u0026#39;) stack.push(\u0026#39;}\u0026#39;); else if (c == \u0026#39;[\u0026#39;) stack.push(\u0026#39;]\u0026#39;); else{ if(stack.empty(){ return false; } char temp=stack.pop(); if(c!=temp){ return false; } } } return stack.isEmpty(); } //[{()}] // } 補充 STACK.peek() -\u0026gt; 返回值：該方法返回堆棧頂部的元素，如果堆棧為空，則返回NULL。\n舉例：\npublic class StackDemo { public static void main(String args[]) { // Creating an empty Stack Stack\u0026lt;String\u0026gt; STACK = new Stack\u0026lt;String\u0026gt;(); // Use push() to add elements into the Stack STACK.push(\u0026#34;Welcome\u0026#34;); STACK.push(\u0026#34;To\u0026#34;); STACK.push(\u0026#34;Taiwan\u0026#34;); // Displaying the Stack System.out.println(\u0026#34;Initial Stack: \u0026#34; + STACK); // Fetching the element at the head of the Stack System.out.println(\u0026#34;The element at the top of the\u0026#34; + \u0026#34; stack is: \u0026#34; + STACK.peek()); // Displaying the Stack after the Operation System.out.println(\u0026#34;Final Stack: \u0026#34; + STACK); } } 輸出：\nInitial Stack: [Welcome, To, Taiwan] The element at the top of the stack is: Taiwan Final Stack: [Welcome, To, Taiwan] ","permalink":"https://pattysung1.github.io/works/leetcode-20/","tags":["leetcode","Stack"],"title":"Leetcode-20. Valid Parentheses"},{"categories":["Programming"],"contents":"Given the heads of two singly linked-lists headA and headB, return the node at which the two lists intersect. If the two linked lists have no intersection at all, return null.\nFor example, the following two linked lists begin to intersect at node c1:\nThe test cases are generated such that there are no cycles anywhere in the entire linked structure.\nNote that the linked lists must retain their original structure after the function returns.\nExample 1: Input: intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3 Output: Intersected at \u0026#39;8\u0026#39; Explanation: The intersected node\u0026#39;s value is 8 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [4,1,8,4,5]. From the head of B, it reads as [5,6,1,8,4,5]. There are 2 nodes before the intersected node in A; There are 3 nodes before the intersected node in B. Example 2:\nInput: intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1 Output: Intersected at \u0026#39;2\u0026#39; Explanation: The intersected node\u0026#39;s value is 2 (note that this must not be 0 if the two lists intersect). From the head of A, it reads as [1,9,1,2,4]. From the head of B, it reads as [3,2,4]. There are 3 nodes before the intersected node in A; There are 1 node before the intersected node in B. Example 3:\nInput: intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2 Output: No intersection Explanation: From the head of A, it reads as [2,6,4]. From the head of B, it reads as [1,5]. Since the two lists do not intersect, intersectVal must be 0, while skipA and skipB can be arbitrary values. Explanation: The two lists do not intersect, so return null. \u0026lt;解題\u0026gt; 在迴圈中，判斷兩個指針 a 和 b 是否相等。 如果相等，表示找到了交點，跳出迴圈 while( a != b)時，如果短的那條走完，會接著走長的那條，可以確保兩個指針分別走過了鏈表 A 和鏈表 B 的長度之和 若兩者沒有交點，則會在跑完兩個head後，得到值null並返回 public ListNode getIntersectionNode(ListNode headA, ListNode headB) { if(headA == null || headB == null) return null; ListNode a = headA; ListNode b = headB; while( a != b){ a = a == null? headB : a.next; //如果 a 達到鏈表的尾部，則將 a 設置為 headB，以便後續遍歷 headB 的節點 b = b == null? headA : b.next; //如果 b 達到鏈表的尾部，則將 b 設置為 headA，以便後續遍歷 headA 的節點 } return a; } Time : O(m+n) Space : O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-160/","tags":["leetcode"],"title":"Leetcode-160. Intersection of Two Linked Lists"},{"categories":["Programming"],"contents":"Implement a first in first out (FIFO) queue using only two stacks. The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).\nImplement the MyQueue class:\nvoid push(int x) Pushes element x to the back of the queue. int pop() Removes the element from the front of the queue and returns it. int peek() Returns the element at the front of the queue. boolean empty() Returns true if the queue is empty, false otherwise. Notes:\nYou must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid. Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack\u0026rsquo;s standard operations.\nExample 1:\nInput [\u0026#34;MyQueue\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;push\u0026#34;, \u0026#34;peek\u0026#34;, \u0026#34;pop\u0026#34;, \u0026#34;empty\u0026#34;] [[], [1], [2], [], [], []] Output [null, null, null, 1, 1, false] Explanation MyQueue myQueue = new MyQueue(); myQueue.push(1); // queue is: [1] myQueue.push(2); // queue is: [1, 2] (leftmost is front of the queue) myQueue.peek(); // return 1 myQueue.pop(); // return 1, queue is [2] myQueue.empty(); // return false\n\u0026lt;解題\u0026gt; class MyQueue { private Stack\u0026lt;Integer\u0026gt; s1 = new Stack\u0026lt;\u0026gt;(); private Stack\u0026lt;Integer\u0026gt; s2 = new Stack\u0026lt;\u0026gt;(); public void push(int x) { s1.push(x); } public void exchange(){ while(!s1.isEmpty()){ s2.push(s1.pop()); } } public int pop() { if (s2.isEmpty()){ exchange(); } return s2.pop(); } public int peek(){ if(s2.isEmpty()){ exchange(); } return s2.peek(); } public boolean empty() { return s1.isEmpty() \u0026amp;\u0026amp; s2.isEmpty(); } } ","permalink":"https://pattysung1.github.io/works/leetcode-232/","tags":["leetcode","Queue"],"title":"Leetcode-232. Implement Queue using Stacks"},{"categories":["Programming"],"contents":"Given the head of a sorted linked list, delete all nodes that have duplicate numbers, leaving only distinct numbers from the original list. Return the linked list sorted as well.\nExample 1: Input: head = [1,2,3,3,4,4,5] Output: [1,2,5] Example 2:\nInput: head = [1,1,1,2,3] Output: [2,3] -\u0026gt;重複的數字就刪除\n\u0026lt;解題\u0026gt; 用slow、fast指標，若fast.next != null \u0026amp;\u0026amp; fast.val == fast.next.val，fast指標往後移 判斷：slow.next 是否為 fast： -slow.next != fast，代表有重複的數，將他移除（slow.next = fast.next)，記得將指標重置 -else，代表沒有重複的數，兩者指標繼續向後移動 迴圈結束，return dummy.next public class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode dummy = new ListNode(0); ListNode fast = head, slow = dummy; slow.next = fast; while(fast != null) { while (fast.next != null \u0026amp;\u0026amp; fast.val == fast.next.val) { fast = fast.next; //fast指標向後移 } if (slow.next != fast) { //有重複的數 slow.next = fast.next; //remove the dups fast = slow.next; //reposition the fast pointer } else { //no dup, move down both pointer slow = slow.next; fast = fast.next; } } return dummy.next; } } Time : O(n) Space : O(1)\n刪除重複的節點（但會留下重複的數字的一個） Leetcode-83. Remove Duplicates from Sorted List\n","permalink":"https://pattysung1.github.io/works/leetcode-82/","tags":["leetcode"],"title":"Leetcode-82. Remove Duplicates from Sorted List II"},{"categories":["Programming"],"contents":"Given the head of a sorted linked list, delete all duplicates such that each element appears only once. Return the linked list sorted as well.\nExample 1:\nInput: head = [1,1,2] Output: [1,2] Example 2:\nInput: head = [1,1,2,3,3] Output: [1,2,3] \u0026lt;解題\u0026gt; 1. class Solution { public ListNode deleteDuplicates(ListNode head) { ListNode current_node = head; while (current_node!=null \u0026amp;\u0026amp; current_node.next != null){ if(current_node.val == current_node.next.val){ current_node.next = current_node.next.next; } else{ current_node = current_node.next; } } return head; } } Time: O(n) Space: O(1)\n2.利用遞迴 class Solution { public ListNode deleteDuplicates(ListNode head) { if(head == null || head.next == null)return head; head.next = deleteDuplicates(head.next); return head.val == head.next.val ? head.next : head; } } Time: O(n) Space: O(n)\n刪除重複的節點（但不會留下重複的數字的一個） Leetcode-82. Remove Duplicates from Sorted List II\n","permalink":"https://pattysung1.github.io/works/leetcode-83/","tags":["leetcode"],"title":"Leetcode-83. Remove Duplicates from Sorted List"},{"categories":["Programming"],"contents":"Given an input string s, reverse the order of the words.\nA word is defined as a sequence of non-space characters. The words in s will be separated by at least one space.\nReturn a string of the words in reverse order concatenated by a single space.\nNote that s may contain leading or trailing spaces or multiple spaces between two words. The returned string should only have a single space separating the words. Do not include any extra spaces.\nExample 1:\nInput: s = \u0026#34;the sky is blue\u0026#34; Output: \u0026#34;blue is sky the\u0026#34; Example 2:\nInput: s = \u0026#34; hello world \u0026#34; Output: \u0026#34;world hello\u0026#34; Explanation: Your reversed string should not contain leading or trailing spaces. Example 3:\nInput: s = \u0026#34;a good example\u0026#34; Output: \u0026#34;example good a\u0026#34; Explanation: You need to reduce multiple spaces between two words to a single space in the reversed string. \u0026lt;解題\u0026gt; 先創建一個 StringBuilder 物件 sb，用於構建反轉後的字串 從最後一個字符開始向前遍歷原始字串 把空格先排除 找到單字後從最後一個開始找回 public class Solution { public String reverseWords(String s) { StringBuilder sb = new StringBuilder(); int n = s.length(); int i = n - 1; while(i \u0026gt;= 0) { if (s.charAt(i) == \u0026#39; \u0026#39;) { i--; continue; } int j = i; while(j \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(j) != \u0026#39; \u0026#39;) j--; sb.append(\u0026#34; \u0026#34;); sb.append(s.substring(j + 1, i + 1)); i = j; } if (sb.length() \u0026gt; 0) sb.deleteCharAt(0); return sb.toString(); } } ","permalink":"https://pattysung1.github.io/works/leetcode-151/","tags":["leetcode"],"title":"Leetcode-151. Reverse Words in a String"},{"categories":["Programming"],"contents":"Given an integer array nums, rotate the array to the right by k steps, where k is non-negative.\nExample 1:\nInput: nums = [1,2,3,4,5,6,7], k = 3 Output: [5,6,7,1,2,3,4] Explanation: rotate 1 steps to the right: [7,1,2,3,4,5,6] rotate 2 steps to the right: [6,7,1,2,3,4,5] rotate 3 steps to the right: [5,6,7,1,2,3,4] Example 2:\nInput: nums = [-1,-100,3,99], k = 2 Output: [3,99,-1,-100] Explanation: rotate 1 steps to the right: [99,-1,-100,3] rotate 2 steps to the right: [3,99,-1,-100] class Solution { public void rotate(int[] nums, int k) { k %= nums.length; reverse(nums, 0, nums.length - 1); // reverse all nums reverse(nums, 0, k - 1); // reverse first k nums reverse(nums, k, nums.length - 1); // reverse last n-k nums } public void reverse(int[] nums, int start, int end) { while (start \u0026lt; end) { int temp = nums[start]; nums[start] = nums[end]; nums[end] = temp; start++; end--; } } } ","permalink":"https://pattysung1.github.io/works/leetcode-189/","tags":["leetcode"],"title":"Leetcode-189. Rotate Array"},{"categories":["Programming"],"contents":"Given the head of a linked list, remove the nth node from the end of the list and return its head.\nExample 1:\nInput: head = [1,2,3,4,5], n = 2 Output: [1,2,3,5] Example 2:\nInput: head = [1], n = 1 Output: [] Example 3:\nInput: head = [1,2], n = 1 Output: [1] \u0026lt;解題\u0026gt; 使用 fast 指針向前移動 n + 1 步，以創造出 n 個節點的間隔，這樣在 fast 達到鏈表尾部時，slow 將指向倒數第 n 個節點的前一個節點 最後指向倒數n的下一位 class Solution { public ListNode removeNthFromEnd(ListNode head, int n) { ListNode dummy = new ListNode(0); ListNode slow = dummy, fast = dummy; dummy.next = head; //先讓fast走n步 for(int i=0; i\u0026lt;=n; i++) { fast = fast.next; } //slow會走到倒數n的位置 while(fast != null) { slow = slow.next; fast = fast.next; } //跳過倒數n的下一位 dummy.next = slow.next.next; return dummy.next; } } ","permalink":"https://pattysung1.github.io/works/leetcode-19/","tags":["leetcode","linked List"],"title":"Leetcode-19. Remove Nth Node From End of List"},{"categories":["Programming"],"contents":"Given an integer array nums, return true if any value appears at least twice in the array, and return false if every element is distinct.\nExample 1:\nInput: nums = [1,2,3,1] Output: true Example 2:\nInput: nums = [1,2,3,4] Output: false Example 3:\nInput: nums = [1,1,1,3,3,4,3,2,4,2] Output: true -\u0026gt;如果有重複兩次，回傳true\n\u0026lt;解題\u0026gt; 使用迴圈及HashSet看有無重複，有的話就返回true，沒有的的話就加到HashSet中 class Solution { public boolean containsDuplicate(int[] nums) { HashSet\u0026lt;Integer\u0026gt; set = new HashSet\u0026lt;\u0026gt;(); for (int i = 0; i \u0026lt; nums.length; i++) { if (set.contains(nums[i])) { return true; } set.add(nums[i]); } return false; } } Time complexity: O(n) Space complexity: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-217/","tags":["leetcode"],"title":"Leetcode-217. Contains Duplicate"},{"categories":["Programming"],"contents":"Given the head of a linked list, rotate the list to the right by k places.\nExample 1:\nInput: head = [1,2,3,4,5], k = 2 Output: [4,5,1,2,3] Example 2:\nInput: head = [0,1,2], k = 4 Output: [2,0,1] \u0026lt;解題\u0026gt; 判斷若為空，直接返回head 建立一個dummy ListNode，並將他指向head 建立fast, slow ListNode，等於dummy（從頭） 用fast指標來算出總長度 用slow指標找到要旋轉的位置 進行旋轉操作 class Solution { public ListNode rotateRight(ListNode head, int k) { if(head == null||head.next==null) return head; ListNode index = head; int len = 1; //計算長度 while(index.next != null){ index = index.next; len++; } index.next = head; for(int i =1; i\u0026lt; len - k % len;i++){ head = head.next; } ListNode res = head.next; head.next = null; return res; } } Time Complexity: O(n) Space Complexity: O(1)\n自己測試的資料 public class Main { public static void main(String[] args) { Solution solution = new Solution(); // Create a linked list from the array ListNode head = createLinkedList(new int[]{1, 2, 3, 4, 5,6}); // Rotate the linked list int n = 2; ListNode rotatedHead = solution.rotateRight(head, n); // Print the resulting linked list printLinkedList(rotatedHead); } // Helper method to create a linked list from an array private static ListNode createLinkedList(int[] nums) { ListNode dummy = new ListNode(0); ListNode current = dummy; for (int num : nums) { current.next = new ListNode(num); current = current.next; } return dummy.next; } // Helper method to print the elements of a linked list private static void printLinkedList(ListNode head) { ListNode current = head; while (current != null) { System.out.print(current.val + \u0026#34; \u0026#34;); current = current.next; } System.out.println(); } } ","permalink":"https://pattysung1.github.io/works/leetcode-61/","tags":["leetcode"],"title":"Leetcode-61. Rotate List"},{"categories":["Programming"],"contents":"Given an integer array nums sorted in non-decreasing order, remove some duplicates in-place such that each unique element appears at most twice. The relative order of the elements should be kept the same.\nSince it is impossible to change the length of the array in some languages, you must instead have the result be placed in the first part of the array nums. More formally, if there are k elements after removing the duplicates, then the first k elements of nums should hold the final result. It does not matter what you leave beyond the first k elements.\nReturn k after placing the final result in the first k slots of nums.\nDo not allocate extra space for another array. You must do this by modifying the input array in-place with O(1) extra memory.\nExample 1:\nInput: nums = [1,1,1,2,2,3] Output: 5, nums = [1,1,2,2,3,_] Explanation: Your function should return k = 5, with the first five elements of nums being 1, 1, 2, 2 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,1,2,3,3] Output: 7, nums = [0,0,1,1,2,3,3,_,_] Explanation: Your function should return k = 7, with the first seven elements of nums being 0, 0, 1, 1, 2, 3 and 3 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). \u0026lt;解題\u0026gt; 前兩個數值可以直接fixed不用看，加入數組 後面的數字只要大於前兩個的index（重複數字最多兩個），即可加入數組 *圖片資料來源：Youtube-Algorithms Made Easy\npublic int removeDuplicates(int[] nums) { int i = 0; for (int n : nums) if (i \u0026lt; 2 || n \u0026gt; nums[i - 2]) nums[i++] = n; return i; } Time: T(n) Space: T(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-80/","tags":["leetcode"],"title":"Leetcode-80. Remove Duplicates from Sorted Array II"},{"categories":["Programming"],"contents":"You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order, and each of their nodes contains a single digit. Add the two numbers and return the sum as a linked list.\nYou may assume the two numbers do not contain any leading zero, except the number 0 itself.\nExample 1:\nInput: l1 = [2,4,3], l2 = [5,6,4] Output: [7,0,8] Explanation: 342 + 465 = 807. Example 2:\nInput: l1 = [0], l2 = [0] Output: [0] Example 3:\nInput: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9] Output: [8,9,9,9,0,0,0,1] \u0026lt;解題\u0026gt; 因為他是把陣列裡的數字反過來儲存後，再相加，所以我們必須要從第一個節點的值開始處理。 判斷l1, l2值是否處理完畢（為空）-\u0026gt;//l1 != null：表示鏈表 l1 還有數字未處理carry \u0026gt; 0：表示存在進位 同時也要用carry值來儲存值，讓下一位數進位與否。 public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode temp = new ListNode(0); ListNode result = temp; int dummy= 0; int carry = 0; while (l1!=null || l2!=null || carry\u0026gt;0){ //l1 != null：表示鏈表 l1 還有數字未處理carry \u0026gt; 0：表示存在進位 if(l1!=null) { dummy += l1.val; l1 = l1.next; } if (l2!=null){ dummy += l2.val; l2 = l2.next; } dummy += carry; if (dummy\u0026gt;9){ dummy -= 10; carry =1; //進位 } else { carry=0; //沒進位 } temp.next = new ListNode(dummy); temp = temp.next; dummy =0; } return result.next; } } Time: O(Max(m,n)) Space: O(Max(m,n))\nm and n are the size of l1 and l2 \u0026lt;補充\u0026gt; 在寫的時候，自己輸入了數字去驗證\npublic class Main { public static void main(String[] args) { ListNode l1 = createLinkedList(new int[] {2,4,3}); ListNode l2 = createLinkedList(new int[] {5,6,4}); Solution solution = new Solution(); ListNode result = solution.addTwoNumbers(l1, l2); // 輸出結果鏈表 printLinkedList(result); } // 輔助方法，將陣列轉換為鏈表 private static ListNode createLinkedList(int[] nums) { ListNode dummy = new ListNode(0); ListNode curr = dummy; for (int num : nums) { dummy.next = new ListNode(num); dummy = dummy.next; } return curr.next; } // 輔助方法，輸出鏈表的值 private static void printLinkedList(ListNode head) { ListNode curr = head; while (curr != null) { System.out.print(curr.val + \u0026#34; \u0026#34;); curr = curr.next; } System.out.println(); } } public class ListNode { int val; ListNode next; ListNode prev; ListNode(int val) { this.val = val; } } public class Solution { public ListNode addTwoNumbers(ListNode l1, ListNode l2) { ListNode temp = new ListNode(0); ListNode result = temp; int num1 = 0; int num2 = 0; while (l1 != null || l2 != null || num2 \u0026gt; 0) { //l1 != null：表示鏈表 l1 還有數字未處理num2 \u0026gt; 0：表示存在進位 if (l1 != null) { num1 += l1.val; l1 = l1.next; } if (l2 != null) { num1 += l2.val; l2 = l2.next; } num1 += num2; if (num1 \u0026gt; 9) { num1 -= 10; num2 = 1; //進位=1 } else { num2 = 0; //沒進位=0 } temp.next = new ListNode(num1); temp = temp.next; num1 = 0; } return result.next; } } \u0026lt;補充\u0026gt; condition ? expression1 : expression2 -\u0026gt; 這個語法表示如果條件為真，則返回表達式1的結果；否則，返回表達式2的結果 和以下相同： if (condition) expression1; else expression2; ","permalink":"https://pattysung1.github.io/works/leetcode-2/","tags":["leetcode"],"title":"Leetcode-2. Add Two Numbers"},{"categories":["Programming"],"contents":"Given the head of a singly linked list, reverse the list, and return the reversed list.\nExample 1:\nInput: head = [1,2,3,4,5] Output: [5,4,3,2,1] Example 2:\nInput: head = [1,2] Output: [2,1] Example 3:\nInput: head = [] Output: [] \u0026lt;解題\u0026gt; 1. iterative solution class Solution { public ListNode reverseList(ListNode head) { ListNode prev = null; //建新的linkedlist while (head != null) { ListNode next_node = head.next; head.next = prev; prev = head; head = next_node; } return prev; } } 2. recursive solution class Solution { public ListNode reverseList(ListNode head) { return reverseListInt(head, null); } private ListNode reverseListInt(ListNode head, ListNode newHead) { if (head == null) return newHead; ListNode next_node = head.next; head.next = newHead; return reverseListInt(next_node, head); } } ","permalink":"https://pattysung1.github.io/works/leetcode-206/","tags":["leetcode","linked List"],"title":"Leetcode-206. Reverse Linked List"},{"categories":["Programming"],"contents":"You are given the heads of two sorted linked lists list1 and list2.\nMerge the two lists in a one sorted list. The list should be made by splicing together the nodes of the first two lists.\nReturn the head of the merged linked list.\nExample 1:\nInput: list1 = [1,2,4], list2 = [1,3,4] Output: [1,1,2,3,4,4] Example 2:\nInput: list1 = [], list2 = [] Output: [] Example 3:\nInput: list1 = [], list2 = [0] Output: [0] \u0026lt;解題\u0026gt; 先判斷l1,l2是否為null，如果是的話直接返回另外一個list 兩個list皆非null情況下，比較大小，比較小的，就先接上去 若其中一個已空，判斷是哪個非空，非空的直接接回去 1. iteration 迭代 寫法 class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { ListNode dummy = new ListNode(0); ListNode current = dummy; while (l1 != null \u0026amp;\u0026amp; l2 != null) { if (l1.val \u0026lt; l2.val) { current.next = l1; l1 = l1.next; } else { current.next = l2; l2 = l2.next; } current = current.next; } if (l1 != null) { current.next = l1; } else { current.next = l2; } return dummy.next; } } 2. Recursion 遞迴 寫法 class Solution { public ListNode mergeTwoLists(ListNode l1, ListNode l2) { if(l1 == null) return l2; if(l2 == null) return l1; if(l1.val \u0026lt; l2.val){ l1.next = mergeTwoLists(l1.next, l2); return l1; } else{ l2.next = mergeTwoLists(l1, l2.next); return l2; } } } ","permalink":"https://pattysung1.github.io/works/leetcode-21/","tags":["leetcode","linked List"],"title":"Leetcode-21. Merge Two Sorted Lists"},{"categories":["Programming"],"contents":"Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.\nYou may assume that each input would have exactly one solution, and you may not use the same element twice.\nYou can return the answer in any order.\nExample 1:\nInput: nums = [2,7,11,15], target = 9 Output: [0,1] Explanation: Because nums[0] + nums[1] == 9, we return [0, 1]. Example 2:\nInput: nums = [3,2,4], target = 6 Output: [1,2] Example 3:\nInput: nums = [3,3], target = 6 Output: [0,1] \u0026lt;解題\u0026gt; 從迴圈中先找第一個數，及target和此數的相減值diff 如果diff在hashMap中，就回傳這個array 如果沒有的話，就存放在hashmap中-\u0026gt;prevMap.put(num,i); 如果整個迴圈中，沒有成立這樣的組合，就回傳空的array class Solution { public int[] twoSum(int[] nums, int target) { HashMap\u0026lt;Integer, Integer\u0026gt; prevMap = new HashMap\u0026lt;\u0026gt;(); for(int i =0 ; i\u0026lt;nums.length; i++){ int num = nums[i]; int diff = target-num; if(prevMap.containsKey(diff)){ return new int[] {i,prevMap.get(diff)}; } prevMap.put(num,i); } return new int[] {}; } } [2,7,11,15] target = 26 [2,0] [7,1] [11,2] i=3, com=11 [3,2] \u0026lt;補充\u0026gt; 空的array new int[] {} 等於 new int [0] 都表示一個空陣列 Brute Force class Solution { public int[] twoSum(int[] nums, int target) { for(int i =0; i\u0026lt; nums.length; i++){ for(int j=i+1; j\u0026lt; nums.length ; j++){ int complement = target - nums[i]; if( complement == nums[j]){ return new int[] {i,j}; } } } throw new IllegalArgumentException(\u0026#34;no match found\u0026#34;); } } ","permalink":"https://pattysung1.github.io/works/leetcode-1/","tags":["leetcode"],"title":"Leetcode-1. Two Sum"},{"categories":["Programming"],"contents":"Given head, the head of a linked list, determine if the linked list has a cycle in it.\nThere is a cycle in a linked list if there is some node in the list that can be reached again by continuously following the next pointer. Internally, pos is used to denote the index of the node that tail\u0026rsquo;s next pointer is connected to. Note that pos is not passed as a parameter.\nReturn true if there is a cycle in the linked list. Otherwise, return false.\nExample 1:\nInput: head = [3,2,0,-4], pos = 1 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 1st node (0-indexed). Example 2:\nInput: head = [1,2], pos = 0 Output: true Explanation: There is a cycle in the linked list, where the tail connects to the 0th node. Example 3:\nInput: head = [1], pos = -1 Output: false Explanation: There is no cycle in the linked list. -\u0026gt;要找出此linkedlist中是否有環\n\u0026lt;解題\u0026gt; 用快和慢兩指針，快的一次走兩步、慢的一次走一步，如果兩者最後能後相遇，代表當中有環 可以先在一開始確認(head == null)的話，就直接return false public class Solution { public boolean hasCycle(ListNode head) { if (head == null) { return false; } ListNode slow = head; ListNode fast = head.next; while (slow != fast \u0026amp;\u0026amp; fast != null \u0026amp;\u0026amp; fast.next != null) { slow = slow.next; fast = fast.next.next; } return slow == fast; } } Time Complexity: O(N) Space Complexity: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-141/","tags":["leetcode","linked List"],"title":"Leetcode-141. Linked List Cycle"},{"categories":["Programming"],"contents":"You are given an integer array nums. You are initially positioned at the array\u0026rsquo;s first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nInput: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:\nInput: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. \u0026lt;解題\u0026gt; class Solution { public boolean canJump(int[] nums) { int boundary = 0; //最遠範圍 for(int i =0;i\u0026lt;=boundary;i++){ boundary = Math.max(boundary,i+nums[i]); //boundary和跳躍最大跳躍長度取最大值 if(boundary \u0026gt;=nums.length-1) return true; } return false; } } Time Complexity : O(n) Space Complexity: O(n)\n","permalink":"https://pattysung1.github.io/works/leetcode-55/","tags":["leetcode"],"title":"Leetcode-55. Jump Game"},{"categories":["Programming"],"contents":"You are given an array prices where prices[i] is the price of a given stock on the ith day.\nYou want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\nReturn the maximum profit you can achieve from this transaction. If you cannot achieve any profit, return 0.\nExample 1:\nInput: prices = [7,1,5,3,6,4] Output: 5 Explanation: Buy on day 2 (price = 1) and sell on day 5 (price = 6), profit = 6-1 = 5. Note that buying on day 2 and selling on day 1 is not allowed because you must buy before you sell. Example 2:\nInput: prices = [7,6,4,3,1] Output: 0 Explanation: In this case, no transactions are done and the max profit = 0. -\u0026gt;找出最低價（買）和最高價（賣）\n\u0026lt;解題\u0026gt; 找出最低價（買） 找出最高利潤Max(maxProfit, prices[i]-min) class Solution { public int maxProfit(int[] prices) { int n = prices.length; int min = Integer.MAX_VALUE; int maxProfit = 0; for (int i=0 ; i\u0026lt;n ;i++){ if(prices[i]\u0026lt; min) min = prices[i]; maxProfit = Math.max(maxProfit, prices[i]-min); } return maxProfit; } } Time Complexity: O(N) Space Complexity: O(1)\n\u0026lt;補充\u0026gt; Integer.MAX_VALUE //數字最大值 ","permalink":"https://pattysung1.github.io/works/leetcode-121/","tags":["leetcode"],"title":"Leetcode-121. Best Time to Buy and Sell Stock"},{"categories":["Programming"],"contents":"You are given an integer array prices where prices[i] is the price of a given stock on the ith day.\nOn each day, you may decide to buy and/or sell the stock. You can only hold at most one share of the stock at any time. However, you can buy it then immediately sell it on the same day.\nFind and return the maximum profit you can achieve.\nExample 1:\nInput: prices = [7,1,5,3,6,4] Output: 7 Explanation: Buy on day 2 (price = 1) and sell on day 3 (price = 5), profit = 5-1 = 4. Then buy on day 4 (price = 3) and sell on day 5 (price = 6), profit = 6-3 = 3. Total profit is 4 + 3 = 7. Example 2:\nInput: prices = [1,2,3,4,5] Output: 4 Explanation: Buy on day 1 (price = 1) and sell on day 5 (price = 5), profit = 5-1 = 4. Total profit is 4. Example 3:\nInput: prices = [7,6,4,3,1] Output: 0 Explanation: There is no way to make a positive profit, so we never buy the stock to achieve the maximum profit of 0. \u0026lt;解題\u0026gt; 如果後一天比前一天價格高，就相減計算兩者的利潤 返回profit class Solution { public int maxProfit(int[] prices) { int n = prices.length; int profit = 0; for (int i = 1; i \u0026lt; n; i++) { if (prices[i] \u0026gt; prices[i - 1]) { profit = profit + (prices[i] - prices[i - 1]); } } return profit; } } Time Complexity: O(N) Space Complexity: O(1)\n","permalink":"https://pattysung1.github.io/works/leetcode-122/","tags":["leetcode"],"title":"Leetcode-122. Best Time to Buy and Sell Stock II"},{"categories":["Programming"],"contents":"Given two strings s and t, return true if t is an anagram of s, and false otherwise.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: s = \u0026#34;anagram\u0026#34;, t = \u0026#34;nagaram\u0026#34; Output: true Example 2:\nInput: s = \u0026#34;rat\u0026#34;, t = \u0026#34;car\u0026#34; Output: false 判斷s、t字串，排序之後是否相等\n\u0026lt;解法\u0026gt; 1. 用陣列比較 import java.util.Arrays; class Solution { public boolean isAnagram(String s, String t) { char[] sArr = s.toCharArray(); char[] tArr = t.toCharArray(); Arrays.sort(sArr); Arrays.sort(tArr); return Arrays.equals(sArr,tArr); } } 2. 使用一個長度為 26 的陣列來統計字母出現的次數（改善空間複雜度） class Solution { public boolean isAnagram(String s, String t) { if (s.length() != t.length()) { return false; } int[] count = new int[26]; // 使用一個長度為 26 的陣列來統計字母出現的次數 // 將 s 字串中的字母計數加 1 for (char c : s.toCharArray()) { count[c - \u0026#39;a\u0026#39;]++; } // 將 t 字串中的字母計數減 1 for (char c : t.toCharArray()) { count[c - \u0026#39;a\u0026#39;]--; } // 檢查每個字母計數是否為 0，如果有非 0 的計數則表示兩個字串不是異位詞 for (int i = 0; i \u0026lt; 26; i++) { if (count[i] != 0) { return false; } } return true; } } \u0026lt;補充\u0026gt;.toCharArray() 把字串轉成字元 public class Main { public static void main(String args[]) { String Str = new String(\u0026#34;Hello word\u0026#34;); System.out.print(\u0026#34;返回值 :\u0026#34; ); System.out.println( Str.toCharArray() ); } } 將字符數組轉換為字符串 char[] charArray = {\u0026#39;H\u0026#39;, \u0026#39;e\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;l\u0026#39;, \u0026#39;o\u0026#39;}; String str = new String(charArray); // 将字符数组转换为字符串 System.out.println(str); // 输出 \u0026#34;Hello\u0026#34; ","permalink":"https://pattysung1.github.io/works/leetcode-242/","tags":["leetcode"],"title":"Leetcode-242. Valid Anagram"},{"categories":["Programming"],"contents":"Given an array of meeting time intervals where intervals[i] = [starti, endi], determine if a person could attend all meetings.\nExample 1:\nInput: intervals = [[0,30],[5,10],[15,20]] Output: false\nExample 2:\nInput: intervals = [[7,10],[2,4]] Output: true\n\u0026lt;解法\u0026gt; class Solution { public boolean canAttendMeetings(int[][] arr) { Arrays.sort(arr, (a, b) -\u0026gt; Integer.compare(a[0], b[0])); for (int i = 1; i \u0026lt; arr.length; i++) { if (arr[i - 1][1] \u0026gt; arr[i][0]) return false; } return true; } } ","permalink":"https://pattysung1.github.io/works/leetcode-252/","tags":["leetcode","array"],"title":"Leetcode-252. Meeting Rooms"},{"categories":["Programming"],"contents":"Given an integer array nums sorted in non-decreasing order, remove the duplicates in-place such that each unique element appears only once. The relative order of the elements should be kept the same. Then return the number of unique elements in nums.\nConsider the number of unique elements of nums to be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the unique elements in the order they were present in nums initially. The remaining elements of nums are not important as well as the size of nums. Return k.\n給定一個排序數組，你需要在原地刪除重複出現的元素，使得每個元素只出現一次，返回移除後數組的新長度。\n不要使用額外的數組空間，你必須在原地修改輸入數組並使用O（1）額外空間的條件下完成。\nExample 1:\nInput: nums = [1,1,2] Output: 2, nums = [1,2,_] Explanation: Your function should return k = 2, with the first two elements of nums being 1 and 2 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). Example 2:\nInput: nums = [0,0,1,1,1,2,2,3,3,4] Output: 5, nums = [0,1,2,3,4,_,_,_,_,_] Explanation: Your function should return k = 5, with the first five elements of nums being 0, 1, 2, 3, and 4 respectively. It does not matter what you leave beyond the returned k (hence they are underscores). \u0026lt;解題\u0026gt; 條件檢查：程式碼確保nums不為空\u0026amp;\u0026amp;長度不為0 設定初始值=1和不重複元素值為目前第一個元素 將非重複元素放入答案的位置，指標繼續往後動 class Solution { public int removeDuplicates(int[] nums) { if (nums == null || nums.length == 0) { return 0; } int answer = 1; // 初始化答案為1，因為第一個元素肯定是不重複的 int prev = nums[0]; // 用來記錄前一個非重複元素的值 for (int i = 1; i \u0026lt; nums.length; i++) { if (nums[i] != prev) { nums[answer] = nums[i]; // 將非重複元素放入答案的位置 prev = nums[i]; // 更新prev的值為目前的元素 answer++; // 答案位置往後移動 } } return answer; } } ","permalink":"https://pattysung1.github.io/works/leetcode-26/","tags":["leetcode"],"title":"Leetcode-26. Remove Duplicates from Sorted Array"},{"categories":["Programming"],"contents":"Given an integer array nums and an integer val, remove all occurrences of val in nums in-place. The order of the elements may be changed. Then return the number of elements in nums which are not equal to val.\nConsider the number of elements in nums which are not equal to val be k, to get accepted, you need to do the following things:\nChange the array nums such that the first k elements of nums contain the elements which are not equal to val. The remaining elements of nums are not important as well as the size of nums. Return k. Custom Judge:\nThe judge will test your solution with the following code:\nint[] nums = [\u0026hellip;]; // Input array int val = \u0026hellip;; // Value to remove int[] expectedNums = [\u0026hellip;]; // The expected answer with correct length. // It is sorted with no values equaling val.\nint k = removeElement(nums, val); // Calls your implementation\nassert k == expectedNums.length; sort(nums, 0, k); // Sort the first k elements of nums for (int i = 0; i \u0026lt; actualLength; i++) { assert nums[i] == expectedNums[i]; } If all assertions pass, then your solution will be accepted.\nExample 1: Input: nums = [3,2,2,3], val = 3 Output: 2, nums = [2,2,_,_] Explanation: Your function should return k = 2, with the first two elements of nums being 2. It does not matter what you leave beyond the returned k (hence they are underscores).\n-\u0026gt;對於返回的結果中的五個元素，它們的順序並不重要，可以以任意順序返回這五個元素，並且不需要對返回的 k 之後的元素做任何處理（可以用底線表示）\n\u0026lt;解題\u0026gt; 給一個數組nums和一個值val，需要移除所有數值等於val的元素，返回移除後數組的新長度。 建一個迴圈，開始跑每個數值，當數值和val不同，就存在本來的數列（數值相同的不存入） class Solution { public int removeElement(int[] nums, int val) { int returnValue = 0; if (nums != null \u0026amp;\u0026amp; nums.length \u0026gt; 0) { for (int i = 0; i \u0026lt; nums.length; i++) { if (nums[i] != val) { nums[returnValue] = nums[i]; returnValue++; } } } return returnValue; } } ","permalink":"https://pattysung1.github.io/works/leetcode-27/","tags":["leetcode"],"title":"Leetcode-27. Remove Element"},{"categories":["Programming"],"contents":"Given two strings needle and haystack, return the index of the first occurrence of needle in haystack, or -1 if needle is not part of haystack.\nExample 1: Input: haystack = \u0026#34;sadbutsad\u0026#34;, needle = \u0026#34;sad\u0026#34; Output: 0 Explanation: \u0026#34;sad\u0026#34; occurs at index 0 and 6. The first occurrence is at index 0, so we return 0. Example 2: Input: haystack = \u0026#34;leetcode\u0026#34;, needle = \u0026#34;leeto\u0026#34; Output: -1 Explanation: \u0026#34;leeto\u0026#34; did not occur in \u0026#34;leetcode\u0026#34;, so we return -1. \u0026lt;解題\u0026gt; haystack的長度比needle的長度長，故if(haystack.length\u0026lt;needle.length)-\u0026gt;return -1 兩者相等-\u0026gt;return 0 迴圈：從haystack中跑到每個字母的substring和needle一樣，return i 1.直接使用substring public int strStr(String haystack, String needle) { int l1=haystack.length(); int l2=needle.length(); if(l1\u0026lt;l2) { return -1; } else if(l2==0) { return 0; } for(int i=0;i\u0026lt;=l1-l2;i++) { if(haystack.substring(i,i+l2).equals(needle)) { return i; } } return -1; } 2.如果不能使用substring class Solution { public int strStr(String haystack, String needle) { int l1 = haystack.length(); int l2 = needle.length(); if (l1 \u0026lt; l2) { return -1; } else if (l2 == 0) { return 0; } else { for (int i = 0; i \u0026lt;= l1 - l2; i++) { boolean found = true; //先預設為true for (int j = 0; j \u0026lt; l2; j++) { //找接下來字母有無相同 if (haystack.charAt(i+j) != needle.charAt(j)){ found =false; break; } } if (found){ return i; } } } return -1; } } ","permalink":"https://pattysung1.github.io/works/leetcode-28/","tags":["leetcode"],"title":"Leetcode-28. Find the Index of the First Occurrence in a String"},{"categories":["Programming"],"contents":"Given an array of strings strs, group the anagrams together. You can return the answer in any order.\nAn Anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.\nExample 1:\nInput: strs = [\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;,\u0026#34;tan\u0026#34;,\u0026#34;ate\u0026#34;,\u0026#34;nat\u0026#34;,\u0026#34;bat\u0026#34;] Output: [[\u0026#34;bat\u0026#34;],[\u0026#34;nat\u0026#34;,\u0026#34;tan\u0026#34;],[\u0026#34;ate\u0026#34;,\u0026#34;eat\u0026#34;,\u0026#34;tea\u0026#34;]] Example 2:\nInput: strs = [\u0026#34;\u0026#34;] Output: [[\u0026#34;\u0026#34;]] Example 3:\nInput: strs = [\u0026#34;a\u0026#34;] Output: [[\u0026#34;a\u0026#34;]] 給一字符串數組，將錯位詞(相同字符不同排列的字符串)分組\n\u0026lt;解題\u0026gt; 用HashMap去建Map\u0026lt;String, ArrayList\u0026gt;，用排序後的字串為key 先把String 轉成 Char以排序 -\u0026gt;.toCharArray() 排序以作為key 再轉回String -\u0026gt; String.valueOf(str) 解法一 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { Map\u0026lt;String, ArrayList\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String s: strs){ char[] key_str = s.toCharArray(); //string 轉成char Arrays.sort(key_str); String key = String.valueOf(key_str);//轉回string if(map.containsKey(key)){//判斷此key是否在map map.get(key).add(s); //有的話將s加入該key的value中 } else{ map.put(key, new ArrayList\u0026lt;\u0026gt;());//沒有的話將key加入map，並在value建立一個類別 map.get(key).add(s); } } return new ArrayList\u0026lt;\u0026gt;(map.values()); //最後把map.values()的值，在新的ArrayList中回傳 } } 解法二 class Solution { public List\u0026lt;List\u0026lt;String\u0026gt;\u0026gt; groupAnagrams(String[] strs) { Map\u0026lt;String, List\u0026lt;String\u0026gt;\u0026gt; map = new HashMap\u0026lt;\u0026gt;(); for (String s : strs) { int[] charCounts = new int[26]; // 统计字符串中每个字符的出现次数 for (char c : s.toCharArray()) { charCounts[c - \u0026#39;a\u0026#39;]++; } // 将字符计数数组转换为唯一的字符串表示 StringBuilder sb = new StringBuilder(); for (int count : charCounts) { sb.append(count); sb.append(\u0026#39;#\u0026#39;); // 使用 \u0026#39;#\u0026#39; 分隔字符计数 } String key = sb.toString(); // 将字符串添加到对应的分组中 if (!map.containsKey(key)) { map.put(key, new ArrayList\u0026lt;\u0026gt;()); } map.get(key).add(s); } return new ArrayList\u0026lt;\u0026gt;(map.values()); } } { \u0026ldquo;1#0#0#0#1#0#0#0#0#0#0#1#0#0#0#0#0#0#0#0#0#0#0#0#0#0#\u0026rdquo; =\u0026gt; [\u0026ldquo;eat\u0026rdquo;, \u0026ldquo;tea\u0026rdquo;, \u0026ldquo;ate\u0026rdquo;], \u0026ldquo;1#0#0#0#1#0#0#0#0#0#0#1#0#0#0#0#0#0#0#0#0#0#0#0#0#0#\u0026rdquo; =\u0026gt; [\u0026ldquo;tan\u0026rdquo;, \u0026ldquo;nat\u0026rdquo;], \u0026ldquo;0#0#0#0#0#1#0#0#0#0#0#0#0#0#0#0#0#0#0#1#0#0#0#0#0#0#\u0026rdquo; =\u0026gt; [\u0026ldquo;bat\u0026rdquo;] }\nmap.values()-\u0026gt; [ [\u0026ldquo;eat\u0026rdquo;, \u0026ldquo;tea\u0026rdquo;, \u0026ldquo;ate\u0026rdquo;], [\u0026ldquo;tan\u0026rdquo;, \u0026ldquo;nat\u0026rdquo;], [\u0026ldquo;bat\u0026rdquo;] ]\nTime: O(N * K * log(K)) Space: O(N * K) //k is the longest length of String\n","permalink":"https://pattysung1.github.io/works/leetcode-49/","tags":["leetcode"],"title":"Leetcode-49. Group Anagrams"},{"categories":["Programming"],"contents":"You are given an integer array nums. You are initially positioned at the array\u0026rsquo;s first index, and each element in the array represents your maximum jump length at that position.\nReturn true if you can reach the last index, or false otherwise.\nExample 1:\nInput: nums = [2,3,1,1,4] Output: true Explanation: Jump 1 step from index 0 to 1, then 3 steps to the last index. Example 2:\nInput: nums = [3,2,1,0,4] Output: false Explanation: You will always arrive at index 3 no matter what. Its maximum jump length is 0, which makes it impossible to reach the last index. \u0026lt;解題\u0026gt; ","permalink":"https://pattysung1.github.io/works/leetcode-55/","tags":["leetcode"],"title":"Leetcode-55. Jump Game"},{"categories":["Programming"],"contents":"You are given two integer arrays nums1 and nums2, sorted in non-decreasing order, and two integers m and n, representing the number of elements in nums1 and nums2 respectively.\nMerge nums1 and nums2 into a single array sorted in non-decreasing order.\nThe final sorted array should not be returned by the function, but instead be stored inside the array nums1. To accommodate this, nums1 has a length of m + n, where the first m elements denote the elements that should be merged, and the last n elements are set to 0 and should be ignored. nums2 has a length of n.\nExample 1:\nInput: nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3 Output: [1,2,2,3,5,6] Explanation: The arrays we are merging are [1,2,3] and [2,5,6]. The result of the merge is [1,2,2,3,5,6] with the underlined elements coming from nums1. Example 2:\nInput: nums1 = [1], m = 1, nums2 = [], n = 0 Output: [1] Explanation: The arrays we are merging are [1] and []. The result of the merge is [1]. Example 3:\nInput: nums1 = [0], m = 0, nums2 = [1], n = 1 Output: [1] Explanation: The arrays we are merging are [] and [1]. The result of the merge is [1]. Note that because m = 0, there are no elements in nums1. The 0 is only there to ensure the merge result can fit in nums1. 給定兩個有序整數數組 nums1和nums2，將nums2合併到 nums1 中，使得 num1成為一個有序數組。\n\u0026lt;解題\u0026gt; 把nums1和nums2的最後一個不含0字元設指標，接著比大小，比較大的從nums1的最後一位開始放，放完之後指標往前移 p2\u0026lt;0，代表 nums2 數組中的元素已經全部合併到 nums1，所以把num1剩下的元素處理完 p1\u0026gt;= 0，要確認num1的元素都有處理到 class Solution { public void merge(int[] nums1, int m, int[] nums2, int n) { if (null != nums1 \u0026amp;\u0026amp; null != nums2 \u0026amp;\u0026amp; nums1.length == m + n) { int p1 = m - 1 int p2 = n - 1; for (int i = m + n - 1; i \u0026gt;= 0; i--) { if (p2 \u0026lt; 0 ||(p1 \u0026gt;= 0 \u0026amp;\u0026amp; nums1[p1] \u0026gt; nums2[p2])) { nums1[i] = nums1[p1]; p1--; } else { nums1[i] = nums2[p2]; p2--; } } } } } ","permalink":"https://pattysung1.github.io/works/leetcode-88/","tags":["leetcode"],"title":"Leetcode-88. Merge Sorted Array"},{"categories":["Programming"],"contents":"以下是幾種方法可以將字元轉換為 ASCII 值： 1. 使用 (int) 類型轉換： char c = \u0026#39;a\u0026#39;; int asciiValue = (int) c; System.out.println(asciiValue); // 輸出: 97 2. 使用 Character.getNumericValue 方法： char c = \u0026#39;A\u0026#39;; int asciiValue = Character.getNumericValue(c); System.out.println(asciiValue); // 輸出: 10 3. 使用數學運算，減去對應的 ASCII 值： Copy code char c = \u0026#39;0\u0026#39;; int asciiValue = c - \u0026#39;0\u0026#39;; System.out.println(asciiValue); // 輸出: 0 ","permalink":"https://pattysung1.github.io/works/leetcode-ascii/","tags":["ASCII"],"title":"將字元轉換成ASCII值"},{"categories":["Programming"],"contents":"Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.\nSymbol Value I 1 V 5 X 10 L 50 C 100 D 500 M 1000 For example, 2 is written as II in Roman numeral, just two ones added together. 12 is written as XII, which is simply X + II. The number 27 is written as XXVII, which is XX + V + II.\nRoman numerals are usually written largest to smallest from left to right. However, the numeral for four is not IIII. Instead, the number four is written as IV. Because the one is before the five we subtract it making four. The same principle applies to the number nine, which is written as IX. There are six instances where subtraction is used:\nI can be placed before V (5) and X (10) to make 4 and 9. X can be placed before L (50) and C (100) to make 40 and 90. C can be placed before D (500) and M (1000) to make 400 and 900. Given a roman numeral, convert it to an integer.\nExample 1: Input: s = \u0026#34;III\u0026#34; Output: 3 Explanation: III = 3. Example 2: Input: s = \u0026#34;LVIII\u0026#34; Output: 58 Explanation: L = 50, V= 5, III = 3. Example 3: Input: s = \u0026#34;MCMXCIV\u0026#34; Output: 1994 Explanation: M = 1000, CM = 900, XC = 90 and IV = 4. \u0026lt;解題\u0026gt; 先定義每一個字元對應的Value -\u0026gt; HashMap 值大的字母擺在越前面，故從前面往後找，當下一位字母的值比前位大時，要用減法 減法計算：記得減去前一位的2倍（因為本來被加過一次了，所以要扣回） 1. 對應字元-\u0026gt;直接用字元比較好 class Solution { public int romanToInt(String s) { int result = 0; if(s != \u0026#34;\u0026#34;){ HashMap\u0026lt;Character,Integer\u0026gt; map = new HashMap\u0026lt;Character,Integer\u0026gt;(); map.put(\u0026#39;I\u0026#39;, 1); map.put(\u0026#39;V\u0026#39;, 5); map.put(\u0026#39;X\u0026#39;, 10); map.put(\u0026#39;L\u0026#39;, 50); map.put(\u0026#39;C\u0026#39;, 100); map.put(\u0026#39;D\u0026#39;, 500); map.put(\u0026#39;M\u0026#39;, 1000); for(int i = 0 ; i\u0026lt;s.length() ; i++){ Character temp = s.charAt(i); int value = 0; if(map.containsKey(temp)){ value = map.get(temp); //字元的值 if(i != 0 \u0026amp;\u0026amp; (map.get(s.charAt(i-1)) \u0026lt; value) ){ value = value - (map.get(s.charAt(i-1))*2); //減去前面數本身*2 } result = result + value; } } } return result; } } 2. 對應字串，但之後記得要轉換 class Solution { public int romanToInt(String s) { int result = 0; if(s != \u0026#34;\u0026#34;){ HashMap\u0026lt;String,Integer\u0026gt; map = new HashMap\u0026lt;String,Integer\u0026gt;(); map.put(\u0026#34;I\u0026#34;, 1); map.put(\u0026#34;V\u0026#34;, 5); map.put(\u0026#34;X\u0026#34;, 10); map.put(\u0026#34;L\u0026#34;, 50); map.put(\u0026#34;C\u0026#34;, 100); map.put(\u0026#34;D\u0026#34;, 500); map.put(\u0026#34;M\u0026#34;, 1000); for(int i = 0 ; i\u0026lt;s.length() ; i++){ String temp = s.charAt(i)+\u0026#34;\u0026#34;; //把字元轉成字串 // String temp = Character.toString(s.charAt(i)); //把字元轉成字串 int value = 0; if(map.containsKey(temp)){ value = map.get(temp); if(i != 0 \u0026amp;\u0026amp; (map.get(s.charAt(i-1)+\u0026#34;\u0026#34;) \u0026lt; value) ){ value = value - (map.get(s.charAt(i-1)+\u0026#34;\u0026#34;))*2; } result = result + value; } } } return result; } } \u0026lt;補充\u0026gt;字元轉字串 1. String temp = s.charAt(i)+\u0026#34;\u0026#34;; //把字元轉成字串 2. String temp = Character.toString(s.charAt(i)); //把字元轉成字串 3. Integer.valueOf() 方法用於將字串轉換為整數，而不是將單個\u0026#34;字元\u0026#34;轉換為整數。 \u0026lt;補充\u0026gt;HashMap containsKey() 方法 import java.util.HashMap; class Main { public static void main(String[] args) { HashMap\u0026lt;Integer, String\u0026gt; sites = new HashMap\u0026lt;\u0026gt;(); sites.put(1, \u0026#34;Google\u0026#34;); sites.put(2, \u0026#34;Yahoo\u0026#34;); sites.put(3, \u0026#34;Apple\u0026#34;); System.out.println(\u0026#34;sites HashMap: \u0026#34; + sites); //檢查是否存在 if(sites.containsKey(1)) { System.out.printf(\u0026#34;key %d 存在於 sites 中%n\u0026#34;, 1); //若要使用格式化字符 System.out.println(\u0026#34;key \u0026#34; + 1 + \u0026#34; 存在於 sites 中\u0026#34;); } //若不存在，則新增 if (!sites.containsKey(4)){ sites.put(4, \u0026#34;Tesla\u0026#34;); } System.out.println(\u0026#34;New sites HashMap:\u0026#34; + sites); } } \u0026lt;補充\u0026gt;格式化字符 //檢查是否存在 if(sites.containsKey(1)) { System.out.printf(\u0026#34;key %d 存在於 sites 中%n\u0026#34;, 1); //若要使用格式化字符 System.out.println(\u0026#34;key \u0026#34; + 1 + \u0026#34; 存在於 sites 中\u0026#34;); } ","permalink":"https://pattysung1.github.io/works/leetcode-13/","tags":["leetcode"],"title":"Leetcode-13. Roman to Integer"},{"categories":["Programming"],"contents":"Given a string s consisting of words and spaces, return the length of the last word in the string.\nA word is a maximal substring consisting of non-space characters only.\nExample 1:\nInput: s = \u0026ldquo;Hello World\u0026rdquo; Output: 5 Explanation: The last word is \u0026ldquo;World\u0026rdquo; with length 5.\n\u0026lt;解題1\u0026gt; 想用空格分離後，在找出最後一個單字的長度\nclass Solution { public int lengthOfLastWord(String s) { if( s!= null \u0026amp; s.length()\u0026gt;0){ String[] temp = s.split(\u0026#34; \u0026#34;); if (temp != null \u0026amp;\u0026amp; temp.length\u0026gt;0){ String last = temp[temp.length-1]; return last.length(); } } return 0; } } \u0026lt;解題2\u0026gt; 從最後一個字元開始算，加總字元個數，如果遇到空白就結束，代表已經數完最後一個單字\npublic static int lengthOfLastWord2(String s) { int len = 0; //計算最後一個單字的長度 int tail = s.length() - 1; //整個字串的長度 while (tail \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(tail) == \u0026#39; \u0026#39;) { tail--; //減去後面的空白 } //從後面往前算到該字元為空白為止 while (tail \u0026gt;= 0 \u0026amp;\u0026amp; s.charAt(tail) != \u0026#39; \u0026#39;) { len++; tail--; } return len; } 1. s.length() 是字串 s 的方法 length() 的調用，用於獲取字串的長度。它會返回一個整數值，表示字串的長度，所以在調用時需要使用括號。 2. temp.length 是陣列 temp 的屬性 length，用於獲取陣列的長度。在Java中，陣列的長度屬性是一個公開的屬性，不需要使用括號。 \u0026lt;補充-字串符分割\u0026gt;\npublic static void main(String args[]){ String str = \u0026#34;www-hello_world-com\u0026#34;; String[] temp; String delimeter = \u0026#34;-\u0026#34;; // 指定分割字符 temp = str.split(delimeter); // 分割字符串 for(int i =0; i \u0026lt; temp.length ; i++){ System.out.println(temp[i]); System.out.println(\u0026#34;\u0026#34;); } String str1 = \u0026#34;www.hello.world.com\u0026#34;; String[] temp1; String delimeter1 = \u0026#34;\\\\.\u0026#34;; // 指定分割字符(\\\\.) temp1 = str1.split(delimeter1); // 分割字符串 for(String x : temp1){ System.out.println(x); System.out.println(\u0026#34;\u0026#34;); } } \u0026lt;補充-chatAt()\u0026gt;\npublic class Main { public static void main(String args[]) { String s = \u0026#34;www.helloworld.com\u0026#34;; char find = s.charAt(9); System.out.println(find); } } -\u0026gt;w\n*排版快捷鍵： option + command + L\n","permalink":"https://pattysung1.github.io/works/leetcode-58/","tags":["leetcode"],"title":"Leetcode-58. Length of Last Word"},{"categories":["Programming"],"contents":"之前在寫Android Studio的時候，會使用\nLog.d(\u0026#34;Patty\u0026#34;, \u0026#34;xx功能\u0026#34;) 來追蹤程式的執行流程，看有沒有印出的值是否正確或有異常，最近在寫Java Spring Boot，這邊的Log功能，需要先於class中撰寫logger，才可以使用：\nimport org.slf4j.Logger; import org.slf4j.LoggerFactory; public class LoggingExample { private static final Logger logger = Logger.getLogger(LoggingExample.class.getName()); public static void main(String[] args) { logger.info(\u0026#34;This is an informational message.\u0026#34;); logger.warning(\u0026#34;This is a warning message.\u0026#34;); logger.severe(\u0026#34;This is a severe message.\u0026#34;); } } 另外，可以將參數帶入印出：\npublic class MyService { private static final Logger logger = LoggerFactory.getLogger(MyService.class); public void doSomething(String parameter) { logger.info(\u0026#34;Received parameter: {}\u0026#34;, parameter); logger.debug(\u0026#34;Debug message with parameter: \u0026#34; + parameter); } } ","permalink":"https://pattysung1.github.io/works/log/","tags":["Java"],"title":"Log紀錄"},{"categories":["Programming"],"contents":"目前在幫ShinyBear品牌做電商網站，在前後端的傳遞資訊時，時常使用到Json，而使用ObjectMapper，可以將Json字串及Java Object互相作轉換。\n但注意，要記得在pom.xql中加上spring-boot-starter-web\n\u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; 說明 ObjectMapper是一個Java庫，用於處理Java對象和JSON之間的相互轉換。它提供了一種簡單而靈活的方法，可將Java對象序列化為JSON格式的字符串，並將JSON字符串反序列化為Java對象。使用ObjectMapper能夠在處理JSON數據時變得更加便捷。\n以下是ObjectMapper的一些常見用法(1.2較常用)： 將Java對象轉換為JSON字符串：(writeValueAsString()) ObjectMapper objectMapper = new ObjectMapper(); YourObject obj = new YourObject(); String jsonString = objectMapper.writeValueAsString(obj); 2.將JSON字符串轉換為Java對象：(readValue())\nObjectMapper objectMapper = new ObjectMapper(); String jsonString = \u0026#34;{\\\u0026#34;name\\\u0026#34;:\\\u0026#34;John\\\u0026#34;,\\\u0026#34;age\\\u0026#34;:30}\u0026#34;; YourObject obj = objectMapper.readValue(jsonString, YourObject.class); 3.格式化JSON輸出：\nObjectMapper objectMapper = new ObjectMapper(); YourObject obj = new YourObject(); String jsonString = objectMapper.writerWithDefaultPrettyPrinter().writeValueAsString(obj); 可以使用ObjectMapper生成格式化的JSON字符串，以提高可讀性。\n4.處理特殊情況：\nObjectMapper objectMapper = new ObjectMapper(); objectMapper.setDateFormat(new SimpleDateFormat(\u0026#34;yyyy-MM-dd\u0026#34;)); YourObject obj = new YourObject(); String jsonString = objectMapper.writeValueAsString(obj); ObjectMapper提供了處理日期格式、處理集合類型、自定義序列化和反序列化等特殊情況的功能。 可以依照要規劃的功能做使用，不過主要還是前兩者使用的多。\n@Jsonproperty: 註解使得Json的key和Java變數可以做轉換 public class Person { @JsonProperty(\u0026#34;first_name\u0026#34;) private String firstName; @JsonProperty(\u0026#34;last_name\u0026#34;) private String lastName; @JsonProperty(\u0026#34;age\u0026#34;) private int age; // getters and setters... } ","permalink":"https://pattysung1.github.io/works/objectmapper/","tags":["Java","ObjectMapper"],"title":"ObjectMapper- Java Object和JSON之間的相互轉換"},{"categories":["Japan日本"],"contents":"自從畢業以及疫情後，已經3年多沒有出國了。看著IG上，朋友們一個個的出國旅遊，心裡好羨慕啊。終於這次趁出國唸書之前，和家人也一起出國囉！\n記得上次去日本大約是快十年前，剛要升高中的時候去的大阪\u0026hellip; 時間真的過得飛快。\n由於看到環球影城有新的瑪利歐世界，因為很喜歡瑪利歐相關的遊戲（瑪利歐、瑪利歐派對、瑪利歐賽車等等）， 於是當然想看看實際去到瑪利歐世界會是怎麼樣子囉！\n▲Mario Parade\n▲Lovely Minion\n如果有興趣看到更多的旅遊照片，可以到Pooh.travel.blog笑咪咪Pooh的旅遊日記觀看！\nps 我最喜歡的角色是耀西和害羞幽靈\n5/14-5/22的行程 由於不想再回到原點，所以搭飛機由大阪進、名古屋出。 因此，我們選擇了5/14桃園機場至大阪的長榮航空， 以及5/22早上從名古屋回桃園機場的華航。 先放上一張總覽圖： 由於主要大阪部分的其他景點以前都去過了，所以只有安排環球影城(主要想去馬力歐樂園)和購物，建議如果第一次來大阪，其實是可以停留4-5天漫遊。\n現在日幣貶值，加上信用卡回饋，買Uniqlo真的就跟台灣價格打75折差不多！ DHC藍莓精華和合力他命的價差也很大，DHC藍莓精華在台灣買大概500-600不等，在那邊的藥妝店比價，平均大概300台幣左右，如果平常會常吃這些保健食品的話，真的很推薦在日本大買特買。\n- 關於交通 這趟旅行的交通部分，主要先訂好票的有關西機場至大阪市區的特快車、大阪至名古屋的JR車票、大阪地鐵巴士一日乘車券。\n另外，有在名古屋車地鐵站，購買一日的地鐵票。\n1.關西機場至大阪市區 由於到大阪已經5點多，出關的時候人滿多的，所以當天晚上就直接到環球影城飯店入住，等待隔天早上直接開始玩。 從大阪關西機場至大阪車站，我們是直接至Klook買。\n訂票方式 關西樂享周遊券（3項設施）+ 關空特快 HARUKA 車票（關西機場→新大阪／天王寺站），除了有從關西機場至市區（可選擇至天王寺、大阪或新大阪車站）外，亦有關西樂享周遊券（3項設施）券可以使用（不過這部分後來因為時間的關係，所以我們也沒有使用到）\nps.購買此票券的時候，klook會有說明如何取票，如果是在關西機場的話，出來之後左轉直直走，接著上二樓到另一棟樓的搭車處的取票機取票，在刷卡進入站前，可以看到班次表。\n2.大阪至名古屋 大阪至名古屋的交通，我們選擇搭乘JR：新大阪到名古屋車站，車程大約50分鐘，售價折合台幣約1500多(匯率1:4左右)。\n訂票方式 官網訂票： 雖然不是中文的，但是按照上面的步驟和翻譯，一步一步的點擊購買，另外，可以選擇適合放置大行李的位子，一個月前就開放可以訂票了。 Klook訂票： Klook真的非常方便，涵蓋旅遊行程、住宿、交通、租車，都可以預訂。當然，JR車票也可以在上面預定囉～！不過，雖然方便，但每張票都要收額外的台幣300元手續費，看到的當下，立馬關掉去訂官網。 3.大阪地鐵票 大阪有one-day和two-day地鐵巴士乘車券，這部分也可以在klook上先訂票。\n訂票方式 大阪地鐵巴士乘車券(1日/2日)\n4.名古屋地鐵票 名古屋地鐵票，是在地鐵站內至詢問處購買的，同時也拿了一張捷運路線圖（也可以拍下來用手機看） ▲One day pass in Nagoya\n▲subway in Nagoya\n▲每週六日及每月8號，購買使用一日乘車券是比較便宜的：大人620日圓、小孩310日圓；剛好我們購買使用那天是星期六XD\n5.名古屋巴士站-愛·地球博紀念公園車站（吉卜力公園) 從名古屋-吉卜力公園，除了搭地鐵外，也可以搭乘巴士，地鐵的價格比巴士便宜一些，但搭乘巴士的話，車程大概35分鐘左右就到了。\n搭乘巴士的位置在名鐵巴士中心的四樓24號，可以上車之後再買付款（一人1000日圓）\n回程在愛·地球博紀念公園車站的3號車牌，就可以搭乘回名鐵巴士中心了。 ▲班次表\n▲地圖相對位置\n","permalink":"https://pattysung1.github.io/travel/post-1/","tags":["Travel","Pooh","大阪","名古屋","吉卜力公園","日本環遊影城"],"title":"2023【大阪-名古屋-黑部立山-吉卜力公園】-交通篇"},{"categories":["Japan日本"],"contents":"關於訂票 吉卜力公園門票 2022年11月1日才開幕的吉卜力公園，目前只開放開個部分：大倉庫、青春之丘、DONDOKO之森。本來想使用官網訂票，但發現好像需要有日本的手機號碼還是相關的認證（有點忘記是什麼），所以後來是在蝦皮代購（可以至上面搜尋吉卜力公園），請人幫忙買票券。價格和官網上的沒有差到很多。但因為只有提前一個多月購買，所以只有買到大倉庫門票。\n官方網站 1.吉卜力大倉庫 2.青春之丘和吉卜力大倉庫門票 3.DONDOKO之森 - 關於黑部立山三日遊 由於四月初準備預定行程時，手邊比較多忙的事情，所以是選擇KKday三天兩夜的白川鄉/高山陣屋、黑部立山、上高地/河童橋遊，包含當中的吃飯及住宿。雖然跟著遊覽車很方便，不過由於喜歡自助，所以還是不太習慣跟團\u0026hellip;.，到每個景點都在趕趕趕和集合，後來發現其實去黑部立山的交通，也可以規劃坐巴士等等，而且費用也便宜很多很多，也不用一直在坐遊覽車以及一直等集合。\n購票平台：KKday Photos 合掌村，5/17到訪天氣超熱 維尼們與mini合掌村 黑部立山上山口 維尼們與雪山 變成冰中雪人 雪的大谷 維尼與雪人 維尼與同團的夥伴 旅遊團採草莓行程，日本的草莓真的很好吃！ 河童橋 ","permalink":"https://pattysung1.github.io/travel/post-2/","tags":["Travel","Pooh","大阪","名古屋","黑部立山","吉卜力公園"],"title":"2023【大阪-名古屋-黑部立山-吉卜力公園】-訂票篇"},{"categories":null,"contents":"let uploadParams = { \u0026lsquo;id\u0026rsquo;: 9999, \u0026lsquo;image\u0026rsquo;: img_file, // img_file should be the variable holding the image data \u0026rsquo;type\u0026rsquo;: 3 };\nlet attemptCount = 0; const MAX_ATTEMPTS = 20;\nfunction uploadImage() { request(URL_UPLOAD, uploadParams, handleUploadSuccess, handleUploadError); }\nfunction handleUploadSuccess(response) { if (response.success === 1) { checkImageStatus(); } else { // If the API response is not success, retry upload. uploadImage(); } }\nfunction handleUploadError(error) { // Handle error, possibly by retrying upload or logging the error. console.error(\u0026ldquo;Upload failed with error:\u0026rdquo;, error); uploadImage(); }\nfunction checkImageStatus() { if (attemptCount \u0026lt; MAX_ATTEMPTS) { request(URL_POLLING, { \u0026lsquo;id\u0026rsquo;: 9999 }, handleStatusSuccess, handleStatusError); attemptCount++; } else { showMessage(\u0026ldquo;The image is still processing, do you want to continue waiting?\u0026rdquo;, function(result) { if (result === true) { attemptCount = 0; // Reset the attempt count if user wants to continue. checkImageStatus(); } else { finishProcess(false); } }); } }\nfunction handleStatusSuccess(response) { switch (response.status) { case 0: // Processing // Wait for 2 seconds before polling again. setDelay(checkImageStatus, 2000); break; case 1: // Done finishProcess(true); break; case 2: // Error finishProcess(false); break; default: console.error(\u0026ldquo;Unknown status\u0026rdquo;); finishProcess(false); } }\nfunction handleStatusError(error) { // Handle error, possibly by retrying status check or logging the error. console.error(\u0026ldquo;Status check failed with error:\u0026rdquo;, error); setDelay(checkImageStatus, 2000); // Wait for 2 seconds before polling again. }\n// Initiate the upload process uploadImage();\n","permalink":"https://pattysung1.github.io/works/try/","tags":null,"title":""},{"categories":["Programming"],"contents":"Design a time-based key-value data structure that can store multiple values for the same key at different time stamps and retrieve the key\u0026rsquo;s value at a certain timestamp.\nImplement the TimeMap class:\nTimeMap() Initializes the object of the data structure. void set(String key, String value, int timestamp) Stores the key key with the value value at the given time timestamp. String get(String key, int timestamp) Returns a value such that set was called previously, with timestamp_prev \u0026lt;= timestamp. If there are multiple such values, it returns the value associated with the largest timestamp_prev. If there are no values, it returns \u0026ldquo;\u0026rdquo;.\nExample 1:\nInput [\u0026ldquo;TimeMap\u0026rdquo;, \u0026ldquo;set\u0026rdquo;, \u0026ldquo;get\u0026rdquo;, \u0026ldquo;get\u0026rdquo;, \u0026ldquo;set\u0026rdquo;, \u0026ldquo;get\u0026rdquo;, \u0026ldquo;get\u0026rdquo;] [[], [\u0026ldquo;foo\u0026rdquo;, \u0026ldquo;bar\u0026rdquo;, 1], [\u0026ldquo;foo\u0026rdquo;, 1], [\u0026ldquo;foo\u0026rdquo;, 3], [\u0026ldquo;foo\u0026rdquo;, \u0026ldquo;bar2\u0026rdquo;, 4], [\u0026ldquo;foo\u0026rdquo;, 4], [\u0026ldquo;foo\u0026rdquo;, 5]] Output [null, null, \u0026ldquo;bar\u0026rdquo;, \u0026ldquo;bar\u0026rdquo;, null, \u0026ldquo;bar2\u0026rdquo;, \u0026ldquo;bar2\u0026rdquo;]\nExplanation TimeMap timeMap = new TimeMap(); timeMap.set(\u0026ldquo;foo\u0026rdquo;, \u0026ldquo;bar\u0026rdquo;, 1); // store the key \u0026ldquo;foo\u0026rdquo; and value \u0026ldquo;bar\u0026rdquo; along with timestamp = 1. timeMap.get(\u0026ldquo;foo\u0026rdquo;, 1); // return \u0026ldquo;bar\u0026rdquo; timeMap.get(\u0026ldquo;foo\u0026rdquo;, 3); // return \u0026ldquo;bar\u0026rdquo;, since there is no value corresponding to foo at timestamp 3 and timestamp 2, then the only value is at timestamp 1 is \u0026ldquo;bar\u0026rdquo;. timeMap.set(\u0026ldquo;foo\u0026rdquo;, \u0026ldquo;bar2\u0026rdquo;, 4); // store the key \u0026ldquo;foo\u0026rdquo; and value \u0026ldquo;bar2\u0026rdquo; along with timestamp = 4. timeMap.get(\u0026ldquo;foo\u0026rdquo;, 4); // return \u0026ldquo;bar2\u0026rdquo; timeMap.get(\u0026ldquo;foo\u0026rdquo;, 5); // return \u0026ldquo;bar2\u0026rdquo;\n\u0026lt;解題\u0026gt; class TimeMap { private Map\u0026lt;String, TreeMap\u0026lt;Integer, String\u0026gt;\u0026gt; timeMap; public TimeMap() { timeMap = new HashMap\u0026lt;\u0026gt;(); } public void set(String key, String value, int timestamp) { if(!timeMap.containsKey(key)){ timeMap.put(key, new TreeMap\u0026lt;\u0026gt;()); } timeMap.get(key).put(timestamp, value); } public String get(String key, int timestamp) { if(!timeMap.containsKey(key)){ return \u0026#34;\u0026#34;; } //使用floorKey(timestamp)方法來找到小於或等於指定時間戳的最大時間戳（prevTimestamp） Integer prevTimestamp = timeMap.get(key).floorKey(timestamp); if(prevTimestamp == null){ return \u0026#34;\u0026#34;; } return timeMap.get(key).get(prevTimestamp); } } /** * Your TimeMap object will be instantiated and called as such: * TimeMap obj = new TimeMap(); * obj.set(key,value,timestamp); * String param_2 = obj.get(key,timestamp); */ Time: O(N) Space: O(N)\n\u0026lt;補充\u0026gt; TreeMap，並使用自定義比較器實現降序排列 import java.util.*; public class TreeMapDemo { public static void main(String[] args) { // 創建一個 TreeMap，並使用自定義比較器實現降序排列 TreeMap\u0026lt;Integer, String\u0026gt; descendingTreeMap = new TreeMap\u0026lt;\u0026gt;(Collections.reverseOrder()); // 添加元素到 TreeMap descendingTreeMap.put(3, \u0026#34;Three\u0026#34;); descendingTreeMap.put(1, \u0026#34;One\u0026#34;); descendingTreeMap.put(2, \u0026#34;Two\u0026#34;); // 遍歷 TreeMap，元素將按照降序排列 for (Map.Entry\u0026lt;Integer, String\u0026gt; entry : descendingTreeMap.entrySet()) { System.out.println(entry.getKey() + \u0026#34;: \u0026#34; + entry.getValue()); } } } ","permalink":"https://pattysung1.github.io/works/leetcode-981/","tags":["leetcode","Binary Search"],"title":"Leetcode-981. Time Based Key-Value Store"}]